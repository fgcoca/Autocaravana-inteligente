{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introducci\u00f3n \u00b6 Vamos a trabajar con un kit programable de c\u00f3digo abierto, f\u00e1cil de construir y de bajo costo que integra una casa inteligente y coche robot. Podemos crear el robot a partir de los tableros que se ensamblan por encaje en ranuras y burlones, montaje de las partes electr\u00f3nicas y cableado. En el proceso de ensamblaje, las actividades ir\u00e1n detallando el principio de funcionamiento de sensores y m\u00f3dulos. El aspecto final de la motorhome o autocaravana lo vemos en la figura siguiente: Aspecto del mobilhome montado Caracter\u00edsticas: Funci\u00f3n multiprop\u00f3sito: evitaci\u00f3n de obst\u00e1culos, seguimiento de l\u00ednea, control por Bluetooth, seguimiento ultras\u00f3nico, sensaci\u00f3n inteligente, etc. F\u00e1cil de construir: ensamble por ranura y burl\u00f3n y sin soldaduras. Estilo: tableros de madera y acr\u00edlicos, m\u00f3dulos RGB y LCD1602. Voltaje de alimentaci\u00f3n: 5v Voltaje de entrada: 7 a 12V Corriente m\u00e1xima de salida: 3A Disipaci\u00f3n de potencia m\u00e1xima: 15W Velocidad del motor: 200 rpm (4,5 V) \u00c1ngulo de detecci\u00f3n ultras\u00f3nico: <15 grados Distancia de detecci\u00f3n ultras\u00f3nica: de 2 a 400cm Distancia de control remoto Bluetooth: 50 metros Control de aplicaciones Bluetooth: compatible con sistema Android e iOS.","title":"Introducci\u00f3n"},{"location":"#introduccion","text":"Vamos a trabajar con un kit programable de c\u00f3digo abierto, f\u00e1cil de construir y de bajo costo que integra una casa inteligente y coche robot. Podemos crear el robot a partir de los tableros que se ensamblan por encaje en ranuras y burlones, montaje de las partes electr\u00f3nicas y cableado. En el proceso de ensamblaje, las actividades ir\u00e1n detallando el principio de funcionamiento de sensores y m\u00f3dulos. El aspecto final de la motorhome o autocaravana lo vemos en la figura siguiente: Aspecto del mobilhome montado Caracter\u00edsticas: Funci\u00f3n multiprop\u00f3sito: evitaci\u00f3n de obst\u00e1culos, seguimiento de l\u00ednea, control por Bluetooth, seguimiento ultras\u00f3nico, sensaci\u00f3n inteligente, etc. F\u00e1cil de construir: ensamble por ranura y burl\u00f3n y sin soldaduras. Estilo: tableros de madera y acr\u00edlicos, m\u00f3dulos RGB y LCD1602. Voltaje de alimentaci\u00f3n: 5v Voltaje de entrada: 7 a 12V Corriente m\u00e1xima de salida: 3A Disipaci\u00f3n de potencia m\u00e1xima: 15W Velocidad del motor: 200 rpm (4,5 V) \u00c1ngulo de detecci\u00f3n ultras\u00f3nico: <15 grados Distancia de detecci\u00f3n ultras\u00f3nica: de 2 a 400cm Distancia de control remoto Bluetooth: 50 metros Control de aplicaciones Bluetooth: compatible con sistema Android e iOS.","title":"Introducci\u00f3n"},{"location":"IoT_basico/","text":"Teor\u00eda b\u00e1sica de IoT \u00b6 1.- \u00bfQu\u00e9 es la Internet de las Cosas? \u00b6 La expresi\u00f3n \u201cInternet de las cosas\u201d o IoT (del ingl\u00e9s, Internet of Things), internet de todas las cosas o internet en las cosas, hace referencia al uso que hacen de Internet los dispositivos conectados (las cosas) para comunicarse sin intervenci\u00f3n humana directa. Tambi\u00e9n se usa el t\u00e9rmino IoT para referirse al conjunto de estos dispositivos conectados comunicando \u201centre m\u00e1quinas\u201d (M2M) sin requerir interacci\u00f3n humana. No existe una Internet especial o diferente para \u201clas cosas\u201d, en principio, se opera con las mismas redes que en otros usos de Internet. En la imagen siguiente se grafica la conexi\u00f3n de elementos con la nube a trav\u00e9s de la red. Conexi\u00f3n de elementos IoT con la nube El IoT sirve para monitorizaci\u00f3n y control electr\u00f3nico y toma de decisiones inteligente. Es decir, conectar dispositivos a Internet permite enviar y recibir informaci\u00f3n usando una infraestructura global y as\u00ed poder monitorizar y/o controlar autom\u00e1ticamente y a distancia multitud de contextos. Por ejemplo, en entornos urbanos (ciudades inteligentes) se puede conocer la actividad humana, del medio ambiente, del tr\u00e1fico\u2026 tanto para informar de su estado (como las plazas de aparcamiento disponibles, la densidad o velocidad de la circulaci\u00f3n, la contaminaci\u00f3n\u2026) como para tomar decisiones de forma manual o autom\u00e1tica para optimizar los recursos disponibles (iluminaci\u00f3n, riego de jardines, funcionamiento de los sem\u00e1foros\u2026) Para conectar a la red las placas Arduino, sus clones o basadas en el mismo usaremos los m\u00f3dulos ESP8266. El ESP8266 es un chip de bajo costo Wi-Fi que contiene su propio microcontrolador, un Tensilica L106 de 32-bit. Es un chip de bajo bajo coste y reducido tama\u00f1o. El chip ESP8266 forma parte de multitud de m\u00f3dulos comerciales a trav\u00e9s de diferentes soluciones con distintas funciones, pines, tama\u00f1os y precios. Modelos ESP El m\u00e1s simple es el ESP-01, que solo dispone de 2 puertos digitales y necesita un adaptador USB para poder ser programado y es el que vamos a usar aqu\u00ed. Hay otros muchos sistemas como por ejemplo la placa ESP32 STEAMakers de Keyestudio, ESP-12E de ESP8266, la placa de desarrollo NodeMCU, tambi\u00e9n basada en el ESP-12E, Adem\u00e1s, hay placas con WiFi que usan otros chip WiFi diferentes, como la Arduino MKR1000. ESP32 STEAMakers ESP-12E NodeMCU de Keyestudio Arduino MKR1000 2.- M\u00f3dulo ESP8266 ESP-01 \u00b6 Introducci\u00f3n \u00b6 El m\u00f3dulo WiFi ESP-01 es uno de las m\u00e1s populares y econ\u00f3micos, pese a no ser el m\u00e1s potente ni vers\u00e1til. Actualmente, otros modelos como la ESP-12 o el el ESP32 se est\u00e1n integrando en la mayor\u00eda de placas de desarrollo, cobrando un peso e importancia mucho mayor. Sin embargo, nosotros vamos a asociar nuestro peque\u00f1o ESP-01 a una placa UNO, con el \u00fanico fin de darle conectividad WiFi. El ESP-01 trae instalado una versi\u00f3n de firmware con la que podemos comunicarnos con el ESP8266 mediante comandos AT (veremos a continuaci\u00f3n algunos de ellos) a trav\u00e9s del puerto serie. Este tipo de comunicaci\u00f3n nos va a permitir crear un puente entre la placa TdR STEAM y el ESP8266, consiguiendo as\u00ed conectar a una red WiFi y dar un primer paso de gigantes en el mundo IoT. Veamos el aspecto del ESP-01 y algunas de sus caracter\u00edsticas: Imagen ESP-01 Descripci\u00f3n - ESP8266 es el microcontrolador del m\u00f3dulo ESP-01. - La memoria flash es la BG25Q80A - Los LEDs informan de si est\u00e1 encendido o no y de la transmisi\u00f3n de datos (Tx y Rx). - La antena WiFi para la conexi\u00f3n a una internet. - Los pines permiten conectar alimentaci\u00f3n, sensores, \u2026 Toda la informaci\u00f3n en el datasheet del fabricante Los pines est\u00e1n distribuidos de la siguiente forma: Pines ESP-01 Descripci\u00f3n 1 - GND 2 - Pin digital n\u00famero 2 3 - Pin digital n\u00famero 0 4 - RXD es el pin por donde se van a recibir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO3 5 - TXD es el pin por donde se van a transmitir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO1 6 - CH_PD es el pin para apagar y encender el ESP-01: si lo ponemos a 0 V (LOW) se apaga, y a 3,3 V (HIGH) se enciende. 7 - RESET pin a 0V resetea el ESP-01 - Vcc es el pin de alimentaci\u00f3n. Funciona a 3,3V y admite un m\u00e1ximo de 3,6 V. La corriente suministrada debe ser mayor que 200 mA. GPIO (del ingl\u00e9s, General Purpose Input Output) son entradas o salidas de prop\u00f3sito general, o sea pines digitales. El ESP-01 soporta comunicaci\u00f3n I2C, por lo que, pese a tener solo un par de GPIOs, podemos conectarle multitud de sensores y actuadores a trav\u00e9s del mencionado bus de datos I2C. Programaci\u00f3n \u00b6 El ESP-01 dispone de un microcontrolador y una memoria donde poder almacenar programas, luego es un dispositivo programable en si mismo. Cargar programas en el dispositivo es algo mas complejo de lo que hemos visto hasta ahora dado que tiene dos modos de operaci\u00f3n, el modo flash o de ejecuci\u00f3n y el modo UART o de grabaci\u00f3n y debemos ser nosotros quienes activemos un modo u otro, cosa que hasta ahora el entorno ArduinoBlocks ha sido el encargado de hacerlo. Los modos de operaci\u00f3n se configuran a trav\u00e9s de los puertos GPIO0 y GPIO2. Para programar el ESP-01 hay que usar los pines Rx y Tx para transmitir los datos a la memoria Flash, donde se almacenar\u00e1 el sketch o programa. En las placas de control los pines Rx y Tx est\u00e1n en los pines D0 y D1 respectivamente y tambi\u00e9n son los que se utilizan para cargar programas a una velocidad de 115200 baudios, as\u00ed que si estos pines los ocupamos con el ESP8266 no podremos cargar programas en nuestra placa. Ahora bien, es posible utilizar otros pines para usar WiFi y evitar este problema, pero el resto de pines digitales solamente trabajan a 9600 baudios y el ESP-01 por defecto viene a 115200, luego para utilizarlo en pines distintos a los D0 y D1 de la placa tendremos que reprogramarlo para que la velocidad sea de 9600 baudios. Aunque sea bastante t\u00e9cnico debemos exponer c\u00f3mo configurar los dos modos de funcionamiento de forma breve. Modo de funcionamiento UART . Para cargar un programa en el ESP-01 debemos o bien encenderlo o bien resetearlo pero teniendo los siguientes estados de pines:GPIO0 = 0 (nivel bajo o LOW = 0 V). GPIO2 = 1 (nivel alto o HIGH = 3,3 V = Vcc). Recordemos siempre que el ESP8266 trabaja con niveles l\u00f3gicos de 3,3 V. El pin GPIO2 est\u00e1 por defecto a HIGH, ya que tiene un pull-up interno, por lo que podemos dejarlo simplemente desconectado. Modo de funcionamiento Flash . Para ejecutar un programa en el ESP-01 una vez cargado debemos tener la siguiente configuraci\u00f3n de pines: GPIO0 = 1 GPIO2 = 1 Tanto el GPIO0 como el GPIO2 est\u00e1n por defecto a HIGH, ya que ambos tienen un pull-up interno, por lo que podemos dejarlos simplemente desconectados. En este momento reflexionamos sobre el uso de Rx y Tx ya que si los estamos utilizando para cargar el programa en la placa y GPIO0 y GPIO2 para indicar el modo de trabajo \u00bfc\u00f3mo conectamos los sensores y actuadores al ESP-01?. Veamos: Rx y Tx los utilizamos para cargar el programa. Una vez finalizada la carga los podemos utilizar como pines de entrada y salida digitales. Los modos de trabajo se indican cuando se resetea o reinicia la placa. Una vez que tengamos el modo de ejecuci\u00f3n podemos conectar cualquier componente a estos pines. Los programas los podemos subir a nuestro ESP-01 mediante el IDE de Arduino o por medio de un convertidor USB-serie igual o similar al de la imagen siguiente: Conversor USB-serial Se trata de un escudo o shield para el m\u00f3dulo WiFi ESP-01 que est\u00e1 provisto de un chip conversor de USB a puerto serie, en concActividad el CH340G. El proceso de reprogramaci\u00f3n con esta placa es bastante sencillo pero requiere de comando AT que pasamos a introducir antes de continuar. 3.- Comando AT en el ESP8266 \u00b6 El ESP-01 viene por defecto con el firmware AT ai-thinker V0.9.2.4. Los m\u00f3dems ven\u00edan con un conjunto de comandos que permiten que nos podamos comunicar con ellos para configurarlos y que lo podamos hacer a trav\u00e9s del puerto serie de ordenador al que est\u00e1n conectados. A estos comandos se les llama AT (de attention). Despu\u00e9s de cada comando AT, el ESP8266 espera los caracteres especiales de nueva linea para ejecutar el comando. El car\u00e1cter no imprimible CR (del ingl\u00e9s, Carriage Return) significa Actividadrno de carro y LF ( del ingl\u00e9s, Line Feed) es salto de l\u00ednea. El origen de la nomenclatura est\u00e1 en las m\u00e1quinas de escribir. En el enlace tenemos un pdf de la empresa Espressif Systems con el juego de comandos AT para el ESP8266. En la tabla siguiente damos un resumen de los comandos con una informaci\u00f3n ampliada de los que vamos a usar para la configuraci\u00f3n inicial que necesitamos. Unos comandos AT 4.- Preparaci\u00f3n del m\u00f3dulo ESP-01 \u00b6 Primero conectamos el m\u00f3dulo ESP8266 a la shield USB-serie y este a su vez a un puerto USB de nuestro ordenador. Nos aseguramos de que el interruptor est\u00e1 en modo Flash Boot. Entramos en ArduinoBlocks con ArduinoBlocks-Connector en funcionamiento, realizamos un refresco de la lectura del puerto para que detecte a la shield del m\u00f3dulo WiFi si es necesario, abrimos la consola, escogeremos la opci\u00f3n de 115200 en baudrate y tambi\u00e9n la de NL + LF (NL + LF es igual que CR + LF) para comunicarnos con el m\u00f3dulo WiFi. Hacemos clic en Conectar y conectamos la consola, escribimos \u201cAT\u201d en ella y clic en enviar. La situaci\u00f3n es la de la imagen siguiente: Comando AT en consola AB Si todo es correcto debe respondernos \u201cOK\u201d. Si responde algo sin sentido o no contesta, significa que est\u00e1 configurado en alguna otra velocidad. En este segundo caso deberemos cambiar la opci\u00f3n de baudrate y repetir la operaci\u00f3n con diferentes velocidades hasta que nos responda \u201cOK\u201d. La situaci\u00f3n correcta en la consola de comandos es la siguiente: Respuesta al comando AT Una vez que nos responda \u201cOK\u201d, le enviamos el texto \u201cAT+UART_DEF=9600,8,1,0,0\u201d y nos debe responder otra vez \u201cOK\u201d. Comando AT para establecer velocidad a 9600 baudios Con esto hemos cambiado la velocidad a 9600 baudios mediante el comando AT+UART_DEF que nos permite cambiar la definici\u00f3n a 9600 baudios, con 8 bits de datos, 1 bit de parada, sin paridad y sin habilitar el control de flujo. Una vez que hemos configurado el m\u00f3dulo WiFi a la velocidad que nos interesa debemos crear un canal en un servidor MQTT donde enviar los datos y visualizarlos. Esto lo vamos a hacer a trav\u00e9s de la web de Thingspeak , pero antes de nada vamos a describir que es MQTT. Para saber mas acerca de la reprogramaci\u00f3n de la velocidad de comunicaci\u00f3n con ESP8266 visita el enlace: Reprogramar la velocidad de comunicaci\u00f3n del ESP8266 . 5.- Una introducci\u00f3n al IoT a trav\u00e9s de MQTT \u00b6 Si queremos trabajar en tareas de IoT debemos de utilizar alg\u00fan protocolo de comunicaci\u00f3n y hoy por hoy el principal es MQTT, pero antes de citar protocolos vamos a tratar algunos conceptos necesarios. Un protocolo de comunicaci\u00f3n no es otra cosa que una serie de normas definidas para que dos o m\u00e1s dispositivos puedan comunicarse entre si de forma comprensible para ambos. Requisitos del IoT Estamos bastante acostumbrados a realizar un tipo de comunicaci\u00f3n denominada M2M (machine-to-machine) utilizando internet, pero cuando trabajamos en IoT debemos establecer una serie de requisitos que hacen que la comunicaci\u00f3n M2M no sea la mas adecuada. Algunos de estos requisitos son: Cantidad: se puede llegar a tener un gran n\u00famero de dispositivos diferentes, desde sensores, actuadores, servidores, etc. Escalabilidad: los sistemas deben permitir a\u00f1adir o eliminar dispositivos sin que el sistema global resulte afectado. Variedad: normalmente necesitaremos que el sistema funcione con diferentes sistemas operativos, lenguajes de programaci\u00f3n y el mayor n\u00famero posible de dispositivos. Simultaneidad: gran cantidad de comunicaciones simultaneas, lo que requiere respuestas r\u00e1pidas para lo que es necesario que los mensajes transmitidos sean lo mas cortos posibles. Seguridad: internet no es un sitio muy seguro y estos dispositivos van a estar conectados a internet controlando dispositivos f\u00edsicos. Accesibilidad: tendremos que trabajar en condiciones muy variadas en lo que se refiere a ancho de banda, firewall, direccionamiento,\u2026 La soluci\u00f3n mas com\u00fan consiste en disponer un servidor denominado \u2018broker\u2019, o a veces \u2018Router\u2019, que ser\u00e1 el que reciba los mensajes de los dispositivos emisores y los distribuir\u00e1 a los receptores. Broker El broker va a tener una direcci\u00f3n IP fija y ser\u00e1 accesible para todos los dispositivos, puede mantener un registro de los dispositivos conectados, recibir y distribuir mensajes y establecer filtros de destinatarios. Esto permite algo fundamental, y es que cada dispositivo no dependa del resto de dispositivos. Veamos algunos conceptos que nos permitan entender las infraestructuras de los servicios IoT: Message Queue o cola de mensajes. En este tipo el broker genera una cola de mensajes \u00fanica para cada uno de los clientes que inician la suscripci\u00f3n. Message Service o servicio de mensajer\u00eda. En este tipo el broker distribuye inmediatamente los mensajes filtrados por alg\u00fan criterio a los clientes conectados. A diferencia de Message Queue, los mensajes entregados mientras el cliente est\u00e1 desconectado se pierden. Publish/Susbcribe (PubSub). Se trata de un sistema de mensajer\u00eda donde el 'Subscriber' informa al broker de que quiere recibir un tipo de mensajes y el 'Publisher' entonces puede publicarlos. Router Remoder Procedure Calls (RRPC). Se trata de la ejecuci\u00f3n remota de procedimientos donde 'Callee' comunica al broker que proporciona un procedimiento y el 'Caller', puede llamar a este procedimiento. Algunos de los protocolos para IoT son: MQTT (del ingl\u00e9s Message Queuing Telemetry Transport) es un protocolo PubSub de servicio de mensajer\u00eda que act\u00faa sobre TCP. Es ligero y f\u00e1cil de implementar resultando apropiado para dispositivos de baja potencia, tan habituales en IoT. TCP es un protocolo de control de transmisi\u00f3n (del ingl\u00e9s, Transmission Control Protocol) fundamental en Internet. AMQP (Advanced Message Queuing Protocol) es un protocolo PubSub de cola de mensajes que asegura la confiabilidad e interoperabilidad necesaria en aplicaciones corporativas. STOMP (Streaming Text Oriented Messaging Protocol). Es un protocolo sencillo que emplea HTTP y mensajes de texto. XMPP (Extensible Messaging and Presence Protocol). Es un protocolo abierto basado en XML dise\u00f1ado para aplicaciones de mensajer\u00eda instant\u00e1nea. WAMP (Web Application Messaging Protocol). Es un protocolo abierto que se ejecuta sobre WebSockets, y provee tanto aplicaciones de PubSub como RRPC. CoAP (Constrained Application Protocol) es un protocolo pensado para emplearse en dispositivos de IoT de baja capacidad. MQTT Dentro de una arquitectura de MQTT, es muy importante el concepto topic (tema en espa\u00f1ol) ya que la comunicaci\u00f3n se realiza a trav\u00e9s de topics debiendo estar los emisores y receptores subscritos a un topic com\u00fan para poder establecer la comunicaci\u00f3n. Este tipo de arquitectura permite que la comunicaci\u00f3n pueda ser de uno a uno o de uno a muchos. Los topics tienen estructura jer\u00e1rquica pudiendo establecer relaciones padre-hijo de manera que cuando nos suscribimos a un topic padre podemos recibir tambi\u00e9n la informaci\u00f3n de sus hijos. En un ejemplo lo podemos ver m\u00e1s claramente. Estructura jerarquica de un topic Un topic se representa mediante una cadena con las jerarquias separadas por /. Por ejemplo: Vivienda/Planta baja/Cocina/Arduino/Luz Vivienda/Planta alta/Dorm.1/Arduino/Temperatura. De esta forma podemos suscribirnos a un topic concActividad o a varios, por ejemplo: Un topic: Vivienda/Planta baja/Cocina/Arduino/Luz Varios topics: Vivienda/Planta baja/# Existen b\u00e1sicamente tres tipos de brokers, los privados, los p\u00fablicos y los locales. A continuaci\u00f3n citamos alguno de los m\u00e1s utilizados: a .- Private MQTT Broker: solamente los dispositivos que establezcamos pueden publicar o suscribirse a un topic. Se utiliza en producci\u00f3n y prototipado. Algunos de ellos son: Azure de Microsoft. AWS de Amazon. CloudMQTT disponible en: https://www.cloudmqtt.com/plans.html . ThingSpeak de Mathworks (MATLAB). b .- Public MQTT Broker: cualquier dispositivo puede publicar y suscribirse a topics. Algunos de ellos son: Eclipse Mosquitto HiveMQ: Enlace - Direcci\u00f3n del broker Flespi Dioty Fluux Thingspeak Si queremos instalar nuestro propio broker en una raspberry o PC, sin duda Mosquito es la opci\u00f3n m\u00e1s extendida. 6.- Creaci\u00f3n de un canal en un servidor MQTT \u00b6 En nuestro caso vamos a utilizar Thingspeak en su versi\u00f3n p\u00fablica. Lo primero que debemos hacer es crear una cuenta, para lo que clicamos en Sign Up. Seguidamente, introducimos un correo electr\u00f3nico v\u00e1lido y el resto de datos que nos pide. Lo vemos en la imagen siguiente: Pagina inicial de Thingspeaks Debemos aceptar que use la direcci\u00f3n de correo electr\u00f3nico para nuestra cuenta de MathWorks, como se ve en la imagen siguiente: Aceptaci\u00f3n a Mathwork Tras esto recibiremos un correo en la direcci\u00f3n que hemos dado para confirmar la creaci\u00f3n de la cuenta y confirmarla. Debemos ver algo similar a la imagen siguiente: Confirmacion aceptaci\u00f3n cuenta correo Una vez confirmada la direcci\u00f3n de correo electr\u00f3nico, volvemos a la p\u00e1gina donde est\u00e1bamos y hacemos click en continuar. Nos pedir\u00e1 un nombre de usuario y una contrase\u00f1a que usaremos a partir de ahora para iniciar sesi\u00f3n. Finalizada la creaci\u00f3n de la cuenta iniciamos sesi\u00f3n desde la p\u00e1gina principal haciendo clic en \u201cSign In\u201d. Veremos una ventana como la de la imagen siguiente: Ventana para identificaci\u00f3n en Thingspeaks Escribimos nuestra contrase\u00f1a y hacemos clic en el bot\u00f3n Sign in. Acceso a Thingspeaks Con esto entramos en el broker y est\u00e1 todo listo para iniciar el trabajo. Acceso correcto al broker Podemos aprender mas sobre el tema visitando los siguientes enlaces: Primeros pasos con Wifi: Servidor sin clave y contrase\u00f1a Wifi con servidor gratuito con clave y contrase\u00f1a y app m\u00f3vil C\u00f3mo publicar y almacenar datos por Wifi en Internet con Thingspeak 7.- Filtrado por MAC \u00b6 Si por cualquier motivo nuestra red WiFi tiene filtrado MAC debemos de dar de alta en la misma de nuestro dispositivo ESP-01. Esta es una tarea que va a depender de nuestro router y suministrador y que no resulta especialmente complicada. Lo primero que debemos hacer es averiguar la direcci\u00f3n MAC de nuestro dispositivo ESP8266. Esta tarea no la vamos a hacer desde ArduinoBlocks sino que vamos a recurrir al IDE de Arduino. Si necesitas ayuda para este tema seguro que la encuentras en estos tutoriales de Luis Llamas , o tambi\u00e9n puedes buscar informaci\u00f3n en tu navegador pues existen multitud de p\u00e1ginas referentes al tema de programaci\u00f3n desde el IDE de Arduino. Los elementos que vamos a utilizar para conectar nuestro m\u00f3dulo ESP-01 a la placa TdR STEAM los vemos en la imagen siguiente: Shield WiFi serial M\u00f3dulo ESP-01 Conector de comunicaciones en la TdR STEAM Cables tipo Dupont M-H Conexionado Nos encontramos con el problema de que el orden de pines en el conector de la TdR STEAM (RX-TX-GND-VCC) no coinicede con el de la Shield WiFi serial (RX-TX-VCC-GND) por lo que no lo vamos a poder \"pinchar\" directamente en el conector y debemos utilizar cables tipo Dupont. Debemos tener muy presente que la placa TdR STEAM ya realiza una conexi\u00f3n cruzada entre los pines Tx y Rx , es decir: Rx de la TdR STEAM va conectada a Tx de la placa UNO Tx de la TdR STEAM va conectada a Rx de la placa UNO En la imagen siguiente vemos gr\u00e1ficamente como debemos hacer el conexionado al que nos estamos refiriendo. Conexi\u00f3n NO CRUZADA TdR - Shield Para nuestro prop\u00f3sito de comunicar el ordenador con el ESP-01 a trav\u00e9s del IDE y averiguar la MAC de nuestro dispositivo creo que lo mas conveniente y claro es realizar el montaje que vemos en la imagen siguiente: Conexi\u00f3n cruzada UNO a Shield wifi En este caso si es totalmente imprescindible realizar la conexi\u00f3n cruzada mostrada en la imagen entre Tx y Rx. Comunicaci\u00f3n entre PC y ESP01 Con la conexi\u00f3n cruzada descrita y un sketch vac\u00edo en el IDE que subimos a la placa UNO, conectamos el UNO al ordenador y establecemos la configuraci\u00f3n de nuestra placa UNO y el puerto USB al que estamos conectados. Lo que en realidad hacemos es usar la placa UNO como un convertidor bidireccional USB a RS232 que nos permite comunicar el ordenador con la placa ESP8266 ESP01. Abrimos el monitor serie desde el IDE de Arduino y lo configuramos como vemos en la imagen siguiente: Configuraci\u00f3n del monitor serie Escribimos AT y pulsamos Enter o hacemos clic en Enviar y el m\u00f3dulo deber\u00e1 responder OK si todo es correcto. Si la velocidad por defecto del m\u00f3dulo no es de 115200 no responder\u00e1 y posiblemente se vean caracteres extra\u00f1os en el monitor serie. En este caso habr\u00e1 que probar distintas velocidades hasta conseguir que el m\u00f3dulo responda OK al comando AT. El resultado correcto lo vemos en la imagen siguiente: Comando AT OK Direcci\u00f3n MAC El \u00faltimo paso es teclear el comando AT para conseguir la direcci\u00f3n f\u00edsica o MAC del dispositivo conectado. Este comando es AT+CIFSR y es que el que vemos en la imagen siguiente: Comando AT para obtener la MAC El comando AT+CIFSR nos devuelve un resultado similar al que vemos en la imagen siguiente: MAC obtenida Ya podemos dar de alta la MAC del dispositivo en nuestro filtrado MAC y poder as\u00ed comunicarnos a trav\u00e9s de WiFi.","title":"Teor\u00eda b\u00e1sica de IoT"},{"location":"IoT_basico/#teoria-basica-de-iot","text":"","title":"Teor\u00eda b\u00e1sica de IoT"},{"location":"IoT_basico/#1-que-es-la-internet-de-las-cosas","text":"La expresi\u00f3n \u201cInternet de las cosas\u201d o IoT (del ingl\u00e9s, Internet of Things), internet de todas las cosas o internet en las cosas, hace referencia al uso que hacen de Internet los dispositivos conectados (las cosas) para comunicarse sin intervenci\u00f3n humana directa. Tambi\u00e9n se usa el t\u00e9rmino IoT para referirse al conjunto de estos dispositivos conectados comunicando \u201centre m\u00e1quinas\u201d (M2M) sin requerir interacci\u00f3n humana. No existe una Internet especial o diferente para \u201clas cosas\u201d, en principio, se opera con las mismas redes que en otros usos de Internet. En la imagen siguiente se grafica la conexi\u00f3n de elementos con la nube a trav\u00e9s de la red. Conexi\u00f3n de elementos IoT con la nube El IoT sirve para monitorizaci\u00f3n y control electr\u00f3nico y toma de decisiones inteligente. Es decir, conectar dispositivos a Internet permite enviar y recibir informaci\u00f3n usando una infraestructura global y as\u00ed poder monitorizar y/o controlar autom\u00e1ticamente y a distancia multitud de contextos. Por ejemplo, en entornos urbanos (ciudades inteligentes) se puede conocer la actividad humana, del medio ambiente, del tr\u00e1fico\u2026 tanto para informar de su estado (como las plazas de aparcamiento disponibles, la densidad o velocidad de la circulaci\u00f3n, la contaminaci\u00f3n\u2026) como para tomar decisiones de forma manual o autom\u00e1tica para optimizar los recursos disponibles (iluminaci\u00f3n, riego de jardines, funcionamiento de los sem\u00e1foros\u2026) Para conectar a la red las placas Arduino, sus clones o basadas en el mismo usaremos los m\u00f3dulos ESP8266. El ESP8266 es un chip de bajo costo Wi-Fi que contiene su propio microcontrolador, un Tensilica L106 de 32-bit. Es un chip de bajo bajo coste y reducido tama\u00f1o. El chip ESP8266 forma parte de multitud de m\u00f3dulos comerciales a trav\u00e9s de diferentes soluciones con distintas funciones, pines, tama\u00f1os y precios. Modelos ESP El m\u00e1s simple es el ESP-01, que solo dispone de 2 puertos digitales y necesita un adaptador USB para poder ser programado y es el que vamos a usar aqu\u00ed. Hay otros muchos sistemas como por ejemplo la placa ESP32 STEAMakers de Keyestudio, ESP-12E de ESP8266, la placa de desarrollo NodeMCU, tambi\u00e9n basada en el ESP-12E, Adem\u00e1s, hay placas con WiFi que usan otros chip WiFi diferentes, como la Arduino MKR1000. ESP32 STEAMakers ESP-12E NodeMCU de Keyestudio Arduino MKR1000","title":"1.- \u00bfQu\u00e9 es la Internet de las Cosas?"},{"location":"IoT_basico/#2-modulo-esp8266-esp-01","text":"","title":"2.- M\u00f3dulo ESP8266 ESP-01"},{"location":"IoT_basico/#introduccion","text":"El m\u00f3dulo WiFi ESP-01 es uno de las m\u00e1s populares y econ\u00f3micos, pese a no ser el m\u00e1s potente ni vers\u00e1til. Actualmente, otros modelos como la ESP-12 o el el ESP32 se est\u00e1n integrando en la mayor\u00eda de placas de desarrollo, cobrando un peso e importancia mucho mayor. Sin embargo, nosotros vamos a asociar nuestro peque\u00f1o ESP-01 a una placa UNO, con el \u00fanico fin de darle conectividad WiFi. El ESP-01 trae instalado una versi\u00f3n de firmware con la que podemos comunicarnos con el ESP8266 mediante comandos AT (veremos a continuaci\u00f3n algunos de ellos) a trav\u00e9s del puerto serie. Este tipo de comunicaci\u00f3n nos va a permitir crear un puente entre la placa TdR STEAM y el ESP8266, consiguiendo as\u00ed conectar a una red WiFi y dar un primer paso de gigantes en el mundo IoT. Veamos el aspecto del ESP-01 y algunas de sus caracter\u00edsticas: Imagen ESP-01 Descripci\u00f3n - ESP8266 es el microcontrolador del m\u00f3dulo ESP-01. - La memoria flash es la BG25Q80A - Los LEDs informan de si est\u00e1 encendido o no y de la transmisi\u00f3n de datos (Tx y Rx). - La antena WiFi para la conexi\u00f3n a una internet. - Los pines permiten conectar alimentaci\u00f3n, sensores, \u2026 Toda la informaci\u00f3n en el datasheet del fabricante Los pines est\u00e1n distribuidos de la siguiente forma: Pines ESP-01 Descripci\u00f3n 1 - GND 2 - Pin digital n\u00famero 2 3 - Pin digital n\u00famero 0 4 - RXD es el pin por donde se van a recibir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO3 5 - TXD es el pin por donde se van a transmitir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO1 6 - CH_PD es el pin para apagar y encender el ESP-01: si lo ponemos a 0 V (LOW) se apaga, y a 3,3 V (HIGH) se enciende. 7 - RESET pin a 0V resetea el ESP-01 - Vcc es el pin de alimentaci\u00f3n. Funciona a 3,3V y admite un m\u00e1ximo de 3,6 V. La corriente suministrada debe ser mayor que 200 mA. GPIO (del ingl\u00e9s, General Purpose Input Output) son entradas o salidas de prop\u00f3sito general, o sea pines digitales. El ESP-01 soporta comunicaci\u00f3n I2C, por lo que, pese a tener solo un par de GPIOs, podemos conectarle multitud de sensores y actuadores a trav\u00e9s del mencionado bus de datos I2C.","title":"Introducci\u00f3n"},{"location":"IoT_basico/#programacion","text":"El ESP-01 dispone de un microcontrolador y una memoria donde poder almacenar programas, luego es un dispositivo programable en si mismo. Cargar programas en el dispositivo es algo mas complejo de lo que hemos visto hasta ahora dado que tiene dos modos de operaci\u00f3n, el modo flash o de ejecuci\u00f3n y el modo UART o de grabaci\u00f3n y debemos ser nosotros quienes activemos un modo u otro, cosa que hasta ahora el entorno ArduinoBlocks ha sido el encargado de hacerlo. Los modos de operaci\u00f3n se configuran a trav\u00e9s de los puertos GPIO0 y GPIO2. Para programar el ESP-01 hay que usar los pines Rx y Tx para transmitir los datos a la memoria Flash, donde se almacenar\u00e1 el sketch o programa. En las placas de control los pines Rx y Tx est\u00e1n en los pines D0 y D1 respectivamente y tambi\u00e9n son los que se utilizan para cargar programas a una velocidad de 115200 baudios, as\u00ed que si estos pines los ocupamos con el ESP8266 no podremos cargar programas en nuestra placa. Ahora bien, es posible utilizar otros pines para usar WiFi y evitar este problema, pero el resto de pines digitales solamente trabajan a 9600 baudios y el ESP-01 por defecto viene a 115200, luego para utilizarlo en pines distintos a los D0 y D1 de la placa tendremos que reprogramarlo para que la velocidad sea de 9600 baudios. Aunque sea bastante t\u00e9cnico debemos exponer c\u00f3mo configurar los dos modos de funcionamiento de forma breve. Modo de funcionamiento UART . Para cargar un programa en el ESP-01 debemos o bien encenderlo o bien resetearlo pero teniendo los siguientes estados de pines:GPIO0 = 0 (nivel bajo o LOW = 0 V). GPIO2 = 1 (nivel alto o HIGH = 3,3 V = Vcc). Recordemos siempre que el ESP8266 trabaja con niveles l\u00f3gicos de 3,3 V. El pin GPIO2 est\u00e1 por defecto a HIGH, ya que tiene un pull-up interno, por lo que podemos dejarlo simplemente desconectado. Modo de funcionamiento Flash . Para ejecutar un programa en el ESP-01 una vez cargado debemos tener la siguiente configuraci\u00f3n de pines: GPIO0 = 1 GPIO2 = 1 Tanto el GPIO0 como el GPIO2 est\u00e1n por defecto a HIGH, ya que ambos tienen un pull-up interno, por lo que podemos dejarlos simplemente desconectados. En este momento reflexionamos sobre el uso de Rx y Tx ya que si los estamos utilizando para cargar el programa en la placa y GPIO0 y GPIO2 para indicar el modo de trabajo \u00bfc\u00f3mo conectamos los sensores y actuadores al ESP-01?. Veamos: Rx y Tx los utilizamos para cargar el programa. Una vez finalizada la carga los podemos utilizar como pines de entrada y salida digitales. Los modos de trabajo se indican cuando se resetea o reinicia la placa. Una vez que tengamos el modo de ejecuci\u00f3n podemos conectar cualquier componente a estos pines. Los programas los podemos subir a nuestro ESP-01 mediante el IDE de Arduino o por medio de un convertidor USB-serie igual o similar al de la imagen siguiente: Conversor USB-serial Se trata de un escudo o shield para el m\u00f3dulo WiFi ESP-01 que est\u00e1 provisto de un chip conversor de USB a puerto serie, en concActividad el CH340G. El proceso de reprogramaci\u00f3n con esta placa es bastante sencillo pero requiere de comando AT que pasamos a introducir antes de continuar.","title":"Programaci\u00f3n"},{"location":"IoT_basico/#3-comando-at-en-el-esp8266","text":"El ESP-01 viene por defecto con el firmware AT ai-thinker V0.9.2.4. Los m\u00f3dems ven\u00edan con un conjunto de comandos que permiten que nos podamos comunicar con ellos para configurarlos y que lo podamos hacer a trav\u00e9s del puerto serie de ordenador al que est\u00e1n conectados. A estos comandos se les llama AT (de attention). Despu\u00e9s de cada comando AT, el ESP8266 espera los caracteres especiales de nueva linea para ejecutar el comando. El car\u00e1cter no imprimible CR (del ingl\u00e9s, Carriage Return) significa Actividadrno de carro y LF ( del ingl\u00e9s, Line Feed) es salto de l\u00ednea. El origen de la nomenclatura est\u00e1 en las m\u00e1quinas de escribir. En el enlace tenemos un pdf de la empresa Espressif Systems con el juego de comandos AT para el ESP8266. En la tabla siguiente damos un resumen de los comandos con una informaci\u00f3n ampliada de los que vamos a usar para la configuraci\u00f3n inicial que necesitamos. Unos comandos AT","title":"3.- Comando AT en el ESP8266"},{"location":"IoT_basico/#4-preparacion-del-modulo-esp-01","text":"Primero conectamos el m\u00f3dulo ESP8266 a la shield USB-serie y este a su vez a un puerto USB de nuestro ordenador. Nos aseguramos de que el interruptor est\u00e1 en modo Flash Boot. Entramos en ArduinoBlocks con ArduinoBlocks-Connector en funcionamiento, realizamos un refresco de la lectura del puerto para que detecte a la shield del m\u00f3dulo WiFi si es necesario, abrimos la consola, escogeremos la opci\u00f3n de 115200 en baudrate y tambi\u00e9n la de NL + LF (NL + LF es igual que CR + LF) para comunicarnos con el m\u00f3dulo WiFi. Hacemos clic en Conectar y conectamos la consola, escribimos \u201cAT\u201d en ella y clic en enviar. La situaci\u00f3n es la de la imagen siguiente: Comando AT en consola AB Si todo es correcto debe respondernos \u201cOK\u201d. Si responde algo sin sentido o no contesta, significa que est\u00e1 configurado en alguna otra velocidad. En este segundo caso deberemos cambiar la opci\u00f3n de baudrate y repetir la operaci\u00f3n con diferentes velocidades hasta que nos responda \u201cOK\u201d. La situaci\u00f3n correcta en la consola de comandos es la siguiente: Respuesta al comando AT Una vez que nos responda \u201cOK\u201d, le enviamos el texto \u201cAT+UART_DEF=9600,8,1,0,0\u201d y nos debe responder otra vez \u201cOK\u201d. Comando AT para establecer velocidad a 9600 baudios Con esto hemos cambiado la velocidad a 9600 baudios mediante el comando AT+UART_DEF que nos permite cambiar la definici\u00f3n a 9600 baudios, con 8 bits de datos, 1 bit de parada, sin paridad y sin habilitar el control de flujo. Una vez que hemos configurado el m\u00f3dulo WiFi a la velocidad que nos interesa debemos crear un canal en un servidor MQTT donde enviar los datos y visualizarlos. Esto lo vamos a hacer a trav\u00e9s de la web de Thingspeak , pero antes de nada vamos a describir que es MQTT. Para saber mas acerca de la reprogramaci\u00f3n de la velocidad de comunicaci\u00f3n con ESP8266 visita el enlace: Reprogramar la velocidad de comunicaci\u00f3n del ESP8266 .","title":"4.- Preparaci\u00f3n del m\u00f3dulo ESP-01"},{"location":"IoT_basico/#5-una-introduccion-al-iot-a-traves-de-mqtt","text":"Si queremos trabajar en tareas de IoT debemos de utilizar alg\u00fan protocolo de comunicaci\u00f3n y hoy por hoy el principal es MQTT, pero antes de citar protocolos vamos a tratar algunos conceptos necesarios. Un protocolo de comunicaci\u00f3n no es otra cosa que una serie de normas definidas para que dos o m\u00e1s dispositivos puedan comunicarse entre si de forma comprensible para ambos. Requisitos del IoT Estamos bastante acostumbrados a realizar un tipo de comunicaci\u00f3n denominada M2M (machine-to-machine) utilizando internet, pero cuando trabajamos en IoT debemos establecer una serie de requisitos que hacen que la comunicaci\u00f3n M2M no sea la mas adecuada. Algunos de estos requisitos son: Cantidad: se puede llegar a tener un gran n\u00famero de dispositivos diferentes, desde sensores, actuadores, servidores, etc. Escalabilidad: los sistemas deben permitir a\u00f1adir o eliminar dispositivos sin que el sistema global resulte afectado. Variedad: normalmente necesitaremos que el sistema funcione con diferentes sistemas operativos, lenguajes de programaci\u00f3n y el mayor n\u00famero posible de dispositivos. Simultaneidad: gran cantidad de comunicaciones simultaneas, lo que requiere respuestas r\u00e1pidas para lo que es necesario que los mensajes transmitidos sean lo mas cortos posibles. Seguridad: internet no es un sitio muy seguro y estos dispositivos van a estar conectados a internet controlando dispositivos f\u00edsicos. Accesibilidad: tendremos que trabajar en condiciones muy variadas en lo que se refiere a ancho de banda, firewall, direccionamiento,\u2026 La soluci\u00f3n mas com\u00fan consiste en disponer un servidor denominado \u2018broker\u2019, o a veces \u2018Router\u2019, que ser\u00e1 el que reciba los mensajes de los dispositivos emisores y los distribuir\u00e1 a los receptores. Broker El broker va a tener una direcci\u00f3n IP fija y ser\u00e1 accesible para todos los dispositivos, puede mantener un registro de los dispositivos conectados, recibir y distribuir mensajes y establecer filtros de destinatarios. Esto permite algo fundamental, y es que cada dispositivo no dependa del resto de dispositivos. Veamos algunos conceptos que nos permitan entender las infraestructuras de los servicios IoT: Message Queue o cola de mensajes. En este tipo el broker genera una cola de mensajes \u00fanica para cada uno de los clientes que inician la suscripci\u00f3n. Message Service o servicio de mensajer\u00eda. En este tipo el broker distribuye inmediatamente los mensajes filtrados por alg\u00fan criterio a los clientes conectados. A diferencia de Message Queue, los mensajes entregados mientras el cliente est\u00e1 desconectado se pierden. Publish/Susbcribe (PubSub). Se trata de un sistema de mensajer\u00eda donde el 'Subscriber' informa al broker de que quiere recibir un tipo de mensajes y el 'Publisher' entonces puede publicarlos. Router Remoder Procedure Calls (RRPC). Se trata de la ejecuci\u00f3n remota de procedimientos donde 'Callee' comunica al broker que proporciona un procedimiento y el 'Caller', puede llamar a este procedimiento. Algunos de los protocolos para IoT son: MQTT (del ingl\u00e9s Message Queuing Telemetry Transport) es un protocolo PubSub de servicio de mensajer\u00eda que act\u00faa sobre TCP. Es ligero y f\u00e1cil de implementar resultando apropiado para dispositivos de baja potencia, tan habituales en IoT. TCP es un protocolo de control de transmisi\u00f3n (del ingl\u00e9s, Transmission Control Protocol) fundamental en Internet. AMQP (Advanced Message Queuing Protocol) es un protocolo PubSub de cola de mensajes que asegura la confiabilidad e interoperabilidad necesaria en aplicaciones corporativas. STOMP (Streaming Text Oriented Messaging Protocol). Es un protocolo sencillo que emplea HTTP y mensajes de texto. XMPP (Extensible Messaging and Presence Protocol). Es un protocolo abierto basado en XML dise\u00f1ado para aplicaciones de mensajer\u00eda instant\u00e1nea. WAMP (Web Application Messaging Protocol). Es un protocolo abierto que se ejecuta sobre WebSockets, y provee tanto aplicaciones de PubSub como RRPC. CoAP (Constrained Application Protocol) es un protocolo pensado para emplearse en dispositivos de IoT de baja capacidad. MQTT Dentro de una arquitectura de MQTT, es muy importante el concepto topic (tema en espa\u00f1ol) ya que la comunicaci\u00f3n se realiza a trav\u00e9s de topics debiendo estar los emisores y receptores subscritos a un topic com\u00fan para poder establecer la comunicaci\u00f3n. Este tipo de arquitectura permite que la comunicaci\u00f3n pueda ser de uno a uno o de uno a muchos. Los topics tienen estructura jer\u00e1rquica pudiendo establecer relaciones padre-hijo de manera que cuando nos suscribimos a un topic padre podemos recibir tambi\u00e9n la informaci\u00f3n de sus hijos. En un ejemplo lo podemos ver m\u00e1s claramente. Estructura jerarquica de un topic Un topic se representa mediante una cadena con las jerarquias separadas por /. Por ejemplo: Vivienda/Planta baja/Cocina/Arduino/Luz Vivienda/Planta alta/Dorm.1/Arduino/Temperatura. De esta forma podemos suscribirnos a un topic concActividad o a varios, por ejemplo: Un topic: Vivienda/Planta baja/Cocina/Arduino/Luz Varios topics: Vivienda/Planta baja/# Existen b\u00e1sicamente tres tipos de brokers, los privados, los p\u00fablicos y los locales. A continuaci\u00f3n citamos alguno de los m\u00e1s utilizados: a .- Private MQTT Broker: solamente los dispositivos que establezcamos pueden publicar o suscribirse a un topic. Se utiliza en producci\u00f3n y prototipado. Algunos de ellos son: Azure de Microsoft. AWS de Amazon. CloudMQTT disponible en: https://www.cloudmqtt.com/plans.html . ThingSpeak de Mathworks (MATLAB). b .- Public MQTT Broker: cualquier dispositivo puede publicar y suscribirse a topics. Algunos de ellos son: Eclipse Mosquitto HiveMQ: Enlace - Direcci\u00f3n del broker Flespi Dioty Fluux Thingspeak Si queremos instalar nuestro propio broker en una raspberry o PC, sin duda Mosquito es la opci\u00f3n m\u00e1s extendida.","title":"5.- Una introducci\u00f3n al IoT a trav\u00e9s de MQTT"},{"location":"IoT_basico/#6-creacion-de-un-canal-en-un-servidor-mqtt","text":"En nuestro caso vamos a utilizar Thingspeak en su versi\u00f3n p\u00fablica. Lo primero que debemos hacer es crear una cuenta, para lo que clicamos en Sign Up. Seguidamente, introducimos un correo electr\u00f3nico v\u00e1lido y el resto de datos que nos pide. Lo vemos en la imagen siguiente: Pagina inicial de Thingspeaks Debemos aceptar que use la direcci\u00f3n de correo electr\u00f3nico para nuestra cuenta de MathWorks, como se ve en la imagen siguiente: Aceptaci\u00f3n a Mathwork Tras esto recibiremos un correo en la direcci\u00f3n que hemos dado para confirmar la creaci\u00f3n de la cuenta y confirmarla. Debemos ver algo similar a la imagen siguiente: Confirmacion aceptaci\u00f3n cuenta correo Una vez confirmada la direcci\u00f3n de correo electr\u00f3nico, volvemos a la p\u00e1gina donde est\u00e1bamos y hacemos click en continuar. Nos pedir\u00e1 un nombre de usuario y una contrase\u00f1a que usaremos a partir de ahora para iniciar sesi\u00f3n. Finalizada la creaci\u00f3n de la cuenta iniciamos sesi\u00f3n desde la p\u00e1gina principal haciendo clic en \u201cSign In\u201d. Veremos una ventana como la de la imagen siguiente: Ventana para identificaci\u00f3n en Thingspeaks Escribimos nuestra contrase\u00f1a y hacemos clic en el bot\u00f3n Sign in. Acceso a Thingspeaks Con esto entramos en el broker y est\u00e1 todo listo para iniciar el trabajo. Acceso correcto al broker Podemos aprender mas sobre el tema visitando los siguientes enlaces: Primeros pasos con Wifi: Servidor sin clave y contrase\u00f1a Wifi con servidor gratuito con clave y contrase\u00f1a y app m\u00f3vil C\u00f3mo publicar y almacenar datos por Wifi en Internet con Thingspeak","title":"6.- Creaci\u00f3n de un canal en un servidor MQTT"},{"location":"IoT_basico/#7-filtrado-por-mac","text":"Si por cualquier motivo nuestra red WiFi tiene filtrado MAC debemos de dar de alta en la misma de nuestro dispositivo ESP-01. Esta es una tarea que va a depender de nuestro router y suministrador y que no resulta especialmente complicada. Lo primero que debemos hacer es averiguar la direcci\u00f3n MAC de nuestro dispositivo ESP8266. Esta tarea no la vamos a hacer desde ArduinoBlocks sino que vamos a recurrir al IDE de Arduino. Si necesitas ayuda para este tema seguro que la encuentras en estos tutoriales de Luis Llamas , o tambi\u00e9n puedes buscar informaci\u00f3n en tu navegador pues existen multitud de p\u00e1ginas referentes al tema de programaci\u00f3n desde el IDE de Arduino. Los elementos que vamos a utilizar para conectar nuestro m\u00f3dulo ESP-01 a la placa TdR STEAM los vemos en la imagen siguiente: Shield WiFi serial M\u00f3dulo ESP-01 Conector de comunicaciones en la TdR STEAM Cables tipo Dupont M-H Conexionado Nos encontramos con el problema de que el orden de pines en el conector de la TdR STEAM (RX-TX-GND-VCC) no coinicede con el de la Shield WiFi serial (RX-TX-VCC-GND) por lo que no lo vamos a poder \"pinchar\" directamente en el conector y debemos utilizar cables tipo Dupont. Debemos tener muy presente que la placa TdR STEAM ya realiza una conexi\u00f3n cruzada entre los pines Tx y Rx , es decir: Rx de la TdR STEAM va conectada a Tx de la placa UNO Tx de la TdR STEAM va conectada a Rx de la placa UNO En la imagen siguiente vemos gr\u00e1ficamente como debemos hacer el conexionado al que nos estamos refiriendo. Conexi\u00f3n NO CRUZADA TdR - Shield Para nuestro prop\u00f3sito de comunicar el ordenador con el ESP-01 a trav\u00e9s del IDE y averiguar la MAC de nuestro dispositivo creo que lo mas conveniente y claro es realizar el montaje que vemos en la imagen siguiente: Conexi\u00f3n cruzada UNO a Shield wifi En este caso si es totalmente imprescindible realizar la conexi\u00f3n cruzada mostrada en la imagen entre Tx y Rx. Comunicaci\u00f3n entre PC y ESP01 Con la conexi\u00f3n cruzada descrita y un sketch vac\u00edo en el IDE que subimos a la placa UNO, conectamos el UNO al ordenador y establecemos la configuraci\u00f3n de nuestra placa UNO y el puerto USB al que estamos conectados. Lo que en realidad hacemos es usar la placa UNO como un convertidor bidireccional USB a RS232 que nos permite comunicar el ordenador con la placa ESP8266 ESP01. Abrimos el monitor serie desde el IDE de Arduino y lo configuramos como vemos en la imagen siguiente: Configuraci\u00f3n del monitor serie Escribimos AT y pulsamos Enter o hacemos clic en Enviar y el m\u00f3dulo deber\u00e1 responder OK si todo es correcto. Si la velocidad por defecto del m\u00f3dulo no es de 115200 no responder\u00e1 y posiblemente se vean caracteres extra\u00f1os en el monitor serie. En este caso habr\u00e1 que probar distintas velocidades hasta conseguir que el m\u00f3dulo responda OK al comando AT. El resultado correcto lo vemos en la imagen siguiente: Comando AT OK Direcci\u00f3n MAC El \u00faltimo paso es teclear el comando AT para conseguir la direcci\u00f3n f\u00edsica o MAC del dispositivo conectado. Este comando es AT+CIFSR y es que el que vemos en la imagen siguiente: Comando AT para obtener la MAC El comando AT+CIFSR nos devuelve un resultado similar al que vemos en la imagen siguiente: MAC obtenida Ya podemos dar de alta la MAC del dispositivo en nuestro filtrado MAC y poder as\u00ed comunicarnos a trav\u00e9s de WiFi.","title":"7.- Filtrado por MAC"},{"location":"conex/","text":"Conexionado y fin de ensamblado \u00b6 Describiremos principalmente de una forma gr\u00e1fica donde va conectado cada elemento. Motores \u00b6 La figura siguiente muestra gr\u00e1ficamente como van conectados los motores a la placa de control. Gr\u00e1fico de conexiones de motores en la placa de control Vamos pasando uno a uno los cables de los motores por el orificio circular de la placa C llegando a la placa de control a trav\u00e9s del orificio cuadrado dispuesto para el paso de cables. Lo hacemos uno a uno o bien etiquetamos a que motor pertenece cada grupo de cables con su conector. En la figura siguiente vemos ambas caras con los cables en su lugar y conectados. Conexionado de los motores Amplificador \u00b6 El amplificador va conectado al pin digital D49 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del amplificador Pasamos el cable hacia la placa de control y lo conectamos en el pin D49 teniendo precauci\u00f3n de respetar la polaridad, tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del amplificador Sensor DHT11 \u00b6 El sensor de temperatura y humedad DHT11 va conectado al pin digital D48 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del DHT11 Pasamos el cable hacia la placa de control y lo conectamos en el pin D48 teniendo precauci\u00f3n de respetar la polaridad, tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del DHT11 Sensor PIR \u00b6 El sensor de presencia PIR va conectado al pin digital D47 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del sensor PIR Pasamos el cable hacia la placa de control y lo conectamos en el pin D47 teniendo precauci\u00f3n de respetar la polaridad, tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del sensor PIR Tiras de LEDs RGB \u00b6 Las tiras van conectadas al pin digital D53 que en la placa de control tiene dos conectores y se hace seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n de LEDs RGB Conectamos cada tira de LEDs RGB en uno de los bloques de pines D53 teniendo precauci\u00f3n de respetar la polaridad, tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n de LEDs RGB LED blanco interior \u00b6 El LED blanco que proporciona la luz dentro de la autocaravana va conectado al pin digital D13 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del LED blanco Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular trasero y conectamos el LED tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del LED blanco Pulsador \u00b6 El pulsador va conectado al pin digital D2 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del pulsador Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular trasero y conectamos el LED tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del pulsador Servomotores \u00b6 Puerta lateral \u00b6 El servo de la puerta lateral va conectado al pin digital D6 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del servo de la puerta lateral Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular trasero y conectamos el servo tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del servo de la puerta lateral Puerta trasera abatible \u00b6 El servo de la puerta trasera abatible o de carga va conectado al pin digital D7 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del servo de la puerta trasera abatible Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular trasero y conectamos el servo tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del servo de la puerta trasera abatible Techo corredizo \u00b6 El servo del techo corredizo va conectado al pin digital D8 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del servo del techo Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular trasero y conectamos el servo tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del servo del techo Sensor HC-SR04 \u00b6 El sensor de ultrasonidos HC-SR04 va al conector de cuatro pines con los pines digitales D22 y D23 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del sensor de ultrasonidos Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular grande y conectamos el sensor tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del sensor de ultrasonidos LEDs de 10mm \u00b6 Los LEDs de los faros van al conector doble de cuatro patillas con los pines digitales D3, D4 y D5 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n de los LEDS de 10mm Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular grande y conectamos el sensor tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n de los LEDS de 10mm Sensor de luz ambiente \u00b6 El sensor anal\u00f3gico de luz ambiente va conectado al pin A4 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del sensor de luz ambiente Conectamos el sensor tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del sensor de luz ambiente Potenci\u00f3metro \u00b6 El potenci\u00f3metro va conectado al pin A3 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del potenci\u00f3metro Conectamos el potenci\u00f3metro tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del potenci\u00f3metro Sensor de vapor \u00b6 El sensor de vapor va conectado al pin A2 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del sensor de vapor Conectamos el sensor de vapor tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del sensor de vapor Teclado \u00b6 El teclado va conectado mediante el conector de 8 patillas a los pines A8 a A15 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del teclado Conectamos el teclado tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del teclado Pantalla LCD I2C \u00b6 La pantalla LCD I2C 1602 va conectada a los pines marcados con IIC seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n de la LCD Conectamos la LCD tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n de la LCD Sensor de gases MQ-2 \u00b6 El sensor de gases va conectado a los pines A0 y A1 que est\u00e1n en un bloque de conectores junto a I2C y seg\u00fan el esquema siguiente: Esquema del sensor de gases Conectamos el sensor de gases tal y como vemos en la figura siguiente: Detalle del sensor de gases M\u00f3dulo seguidor de l\u00ednea \u00b6 El m\u00f3dulo seguidor de l\u00ednea va conectado a los pines D50, D51 y D52 en el conector JST de 5 pines utilizando el cable de 5 conductores y seg\u00fan el esquema siguiente: Esquema del seguidor de l\u00ednea Conectamos el sensor de gases tal y como vemos en la figura siguiente: Detalle del seguidor de l\u00ednea Finalizaci\u00f3n del ensamblado \u00b6 Una vez terminadas las conexiones ya podemos proceder a colocar los paneles faltantes para terminar de montar la autocaravana y comenzar a divertirnos programando su comportamiento. El siguiente paso de ensamblado es colocar el panel N montado en su lugar y sujetarlo con un burl\u00f3n peque\u00f1o teniendo cuidado en la manipulaci\u00f3n porque hay partes que se pueden da\u00f1ar o romper. Montaje panel N Ahora podemos colocar el dispositivo Bluetooth en su lugar aprovechando la abertura del panel N. Los pines extremos se quedan fuera del conector de la placa de control. Colocaci\u00f3n del Bluetooth Sujetamos la puerta trasera basculante o panel J en su lugar utilizando dos burlones peque\u00f1os. Montaje panel J En la figura siguiente vemos el montaje finalizado visto desde la parte posterior del veh\u00edculo. Montaje finalizado","title":"Conexionado"},{"location":"conex/#conexionado-y-fin-de-ensamblado","text":"Describiremos principalmente de una forma gr\u00e1fica donde va conectado cada elemento.","title":"Conexionado y fin de ensamblado"},{"location":"conex/#motores","text":"La figura siguiente muestra gr\u00e1ficamente como van conectados los motores a la placa de control. Gr\u00e1fico de conexiones de motores en la placa de control Vamos pasando uno a uno los cables de los motores por el orificio circular de la placa C llegando a la placa de control a trav\u00e9s del orificio cuadrado dispuesto para el paso de cables. Lo hacemos uno a uno o bien etiquetamos a que motor pertenece cada grupo de cables con su conector. En la figura siguiente vemos ambas caras con los cables en su lugar y conectados. Conexionado de los motores","title":"Motores"},{"location":"conex/#amplificador","text":"El amplificador va conectado al pin digital D49 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del amplificador Pasamos el cable hacia la placa de control y lo conectamos en el pin D49 teniendo precauci\u00f3n de respetar la polaridad, tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del amplificador","title":"Amplificador"},{"location":"conex/#sensor-dht11","text":"El sensor de temperatura y humedad DHT11 va conectado al pin digital D48 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del DHT11 Pasamos el cable hacia la placa de control y lo conectamos en el pin D48 teniendo precauci\u00f3n de respetar la polaridad, tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del DHT11","title":"Sensor DHT11"},{"location":"conex/#sensor-pir","text":"El sensor de presencia PIR va conectado al pin digital D47 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del sensor PIR Pasamos el cable hacia la placa de control y lo conectamos en el pin D47 teniendo precauci\u00f3n de respetar la polaridad, tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del sensor PIR","title":"Sensor PIR"},{"location":"conex/#tiras-de-leds-rgb","text":"Las tiras van conectadas al pin digital D53 que en la placa de control tiene dos conectores y se hace seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n de LEDs RGB Conectamos cada tira de LEDs RGB en uno de los bloques de pines D53 teniendo precauci\u00f3n de respetar la polaridad, tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n de LEDs RGB","title":"Tiras de LEDs RGB"},{"location":"conex/#led-blanco-interior","text":"El LED blanco que proporciona la luz dentro de la autocaravana va conectado al pin digital D13 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del LED blanco Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular trasero y conectamos el LED tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del LED blanco","title":"LED blanco interior"},{"location":"conex/#pulsador","text":"El pulsador va conectado al pin digital D2 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del pulsador Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular trasero y conectamos el LED tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del pulsador","title":"Pulsador"},{"location":"conex/#servomotores","text":"","title":"Servomotores"},{"location":"conex/#puerta-lateral","text":"El servo de la puerta lateral va conectado al pin digital D6 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del servo de la puerta lateral Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular trasero y conectamos el servo tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del servo de la puerta lateral","title":"Puerta lateral"},{"location":"conex/#puerta-trasera-abatible","text":"El servo de la puerta trasera abatible o de carga va conectado al pin digital D7 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del servo de la puerta trasera abatible Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular trasero y conectamos el servo tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del servo de la puerta trasera abatible","title":"Puerta trasera abatible"},{"location":"conex/#techo-corredizo","text":"El servo del techo corredizo va conectado al pin digital D8 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del servo del techo Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular trasero y conectamos el servo tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del servo del techo","title":"Techo corredizo"},{"location":"conex/#sensor-hc-sr04","text":"El sensor de ultrasonidos HC-SR04 va al conector de cuatro pines con los pines digitales D22 y D23 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del sensor de ultrasonidos Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular grande y conectamos el sensor tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del sensor de ultrasonidos","title":"Sensor HC-SR04"},{"location":"conex/#leds-de-10mm","text":"Los LEDs de los faros van al conector doble de cuatro patillas con los pines digitales D3, D4 y D5 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n de los LEDS de 10mm Llevamos el cable a la cara de la placa de control a trav\u00e9s del orificio rectangular grande y conectamos el sensor tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n de los LEDS de 10mm","title":"LEDs de 10mm"},{"location":"conex/#sensor-de-luz-ambiente","text":"El sensor anal\u00f3gico de luz ambiente va conectado al pin A4 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del sensor de luz ambiente Conectamos el sensor tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del sensor de luz ambiente","title":"Sensor de luz ambiente"},{"location":"conex/#potenciometro","text":"El potenci\u00f3metro va conectado al pin A3 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del potenci\u00f3metro Conectamos el potenci\u00f3metro tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del potenci\u00f3metro","title":"Potenci\u00f3metro"},{"location":"conex/#sensor-de-vapor","text":"El sensor de vapor va conectado al pin A2 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del sensor de vapor Conectamos el sensor de vapor tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del sensor de vapor","title":"Sensor de vapor"},{"location":"conex/#teclado","text":"El teclado va conectado mediante el conector de 8 patillas a los pines A8 a A15 seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n del teclado Conectamos el teclado tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n del teclado","title":"Teclado"},{"location":"conex/#pantalla-lcd-i2c","text":"La pantalla LCD I2C 1602 va conectada a los pines marcados con IIC seg\u00fan el esquema siguiente: Esquema de conexi\u00f3n de la LCD Conectamos la LCD tal y como vemos en la figura siguiente: Detalle de conexi\u00f3n de la LCD","title":"Pantalla LCD I2C"},{"location":"conex/#sensor-de-gases-mq-2","text":"El sensor de gases va conectado a los pines A0 y A1 que est\u00e1n en un bloque de conectores junto a I2C y seg\u00fan el esquema siguiente: Esquema del sensor de gases Conectamos el sensor de gases tal y como vemos en la figura siguiente: Detalle del sensor de gases","title":"Sensor de gases MQ-2"},{"location":"conex/#modulo-seguidor-de-linea","text":"El m\u00f3dulo seguidor de l\u00ednea va conectado a los pines D50, D51 y D52 en el conector JST de 5 pines utilizando el cable de 5 conductores y seg\u00fan el esquema siguiente: Esquema del seguidor de l\u00ednea Conectamos el sensor de gases tal y como vemos en la figura siguiente: Detalle del seguidor de l\u00ednea","title":"M\u00f3dulo seguidor de l\u00ednea"},{"location":"conex/#finalizacion-del-ensamblado","text":"Una vez terminadas las conexiones ya podemos proceder a colocar los paneles faltantes para terminar de montar la autocaravana y comenzar a divertirnos programando su comportamiento. El siguiente paso de ensamblado es colocar el panel N montado en su lugar y sujetarlo con un burl\u00f3n peque\u00f1o teniendo cuidado en la manipulaci\u00f3n porque hay partes que se pueden da\u00f1ar o romper. Montaje panel N Ahora podemos colocar el dispositivo Bluetooth en su lugar aprovechando la abertura del panel N. Los pines extremos se quedan fuera del conector de la placa de control. Colocaci\u00f3n del Bluetooth Sujetamos la puerta trasera basculante o panel J en su lugar utilizando dos burlones peque\u00f1os. Montaje panel J En la figura siguiente vemos el montaje finalizado visto desde la parte posterior del veh\u00edculo. Montaje finalizado","title":"Finalizaci\u00f3n del ensamblado"},{"location":"montaje/","text":"Montaje de las partes \u00b6 Vamos a ir viendo paso a paso como montar cada una de las partes anteriores en su lugar para ensamblar el veh\u00edculo completo. Lo haremos con cuidado de que todo est\u00e9 bien colocado, siendo pacientes y sin forzar ning\u00fan elemento. Sobre la parte 7 montamos la parte 2 utilizando dos burlones grandes, teniendo cuidado con la orientaci\u00f3n y de no aplastar ning\u00fan cable. En la figura siguiente vemos el proceso a seguir. Si los burlones entran demasiado justos es mejor limarlos un poco por sus laterales para no forzar el encaje en su lugar dada la debilidad de las paredes mas finas de los orificios. Montaje de las partes 2 y 7 Y ahora montamos la parte 1 de manera similar. Montaje de las parte 1 Colocamos el panel G en el lugar indicado en la figura siguiente dejando las letras orientadas hac\u00eda arriba. Montaje del panel G Colocamos el panel acr\u00edlico marcado con la letra P en la posici\u00f3n que observamos en la figura siguiente dejando la letra hac\u00eda el exterior. El ensamble de este panel y el G se hace de manera simultanea. Montaje del panel P A continuaci\u00f3n encajamos el panel K en las ranuras de los paneles A y B y los hacemos coincidir con los orificios de la base, dondee lo sujetamos con dos burlones peque\u00f1os, tal y como vemos en la figura siguiente: Montaje del panel K El siguiente paso en el montaje es instalar en su lugar el panel M teniendo precauci\u00f3n al instalarlo porque las partees que sobresalen son d\u00e9biles. En la figura siguiente vemos como proceder. Montaje del panel M Opcional: Si es necesario retiramos el panel E antes de instalar el F y lo colocamos posteriormente. Desmontaje del panel E En las im\u00e1genes siguientes y establecido el orden por numeraci\u00f3n tenemos el proceso de colocaci\u00f3n de los dos paneles D en su lugar. \u00bc Insertar las placa en las ranuras del panel F. Montaje paneles D 2/4 Deslizamos los paneles D por la ranura superior hasta que encajen en los orificios de los paneles laterales. Montaje paneles D \u00be Colocamos dos burlones peque\u00f1os en los orificios verticales de los paneles D. Montaje paneles D 4/4 Colocamos dos burlones peque\u00f1os en los orificios horizontales de los paneles D. Montaje paneles D El siguiente paso es colocar el panel L con la LCD en su lugar de manera similar a como hicimos con el panel K y lo sujetamos con dos burlones peque\u00f1os. Montaje panel L Antes de finalizar el montaje con la colocaci\u00f3n del techo y la puerta abatible trasera es necesario cablear el conjunto por lo que estos pasos finales los incluiremos en el apartado Conexionado .","title":"Montaje de las partes"},{"location":"montaje/#montaje-de-las-partes","text":"Vamos a ir viendo paso a paso como montar cada una de las partes anteriores en su lugar para ensamblar el veh\u00edculo completo. Lo haremos con cuidado de que todo est\u00e9 bien colocado, siendo pacientes y sin forzar ning\u00fan elemento. Sobre la parte 7 montamos la parte 2 utilizando dos burlones grandes, teniendo cuidado con la orientaci\u00f3n y de no aplastar ning\u00fan cable. En la figura siguiente vemos el proceso a seguir. Si los burlones entran demasiado justos es mejor limarlos un poco por sus laterales para no forzar el encaje en su lugar dada la debilidad de las paredes mas finas de los orificios. Montaje de las partes 2 y 7 Y ahora montamos la parte 1 de manera similar. Montaje de las parte 1 Colocamos el panel G en el lugar indicado en la figura siguiente dejando las letras orientadas hac\u00eda arriba. Montaje del panel G Colocamos el panel acr\u00edlico marcado con la letra P en la posici\u00f3n que observamos en la figura siguiente dejando la letra hac\u00eda el exterior. El ensamble de este panel y el G se hace de manera simultanea. Montaje del panel P A continuaci\u00f3n encajamos el panel K en las ranuras de los paneles A y B y los hacemos coincidir con los orificios de la base, dondee lo sujetamos con dos burlones peque\u00f1os, tal y como vemos en la figura siguiente: Montaje del panel K El siguiente paso en el montaje es instalar en su lugar el panel M teniendo precauci\u00f3n al instalarlo porque las partees que sobresalen son d\u00e9biles. En la figura siguiente vemos como proceder. Montaje del panel M Opcional: Si es necesario retiramos el panel E antes de instalar el F y lo colocamos posteriormente. Desmontaje del panel E En las im\u00e1genes siguientes y establecido el orden por numeraci\u00f3n tenemos el proceso de colocaci\u00f3n de los dos paneles D en su lugar. \u00bc Insertar las placa en las ranuras del panel F. Montaje paneles D 2/4 Deslizamos los paneles D por la ranura superior hasta que encajen en los orificios de los paneles laterales. Montaje paneles D \u00be Colocamos dos burlones peque\u00f1os en los orificios verticales de los paneles D. Montaje paneles D 4/4 Colocamos dos burlones peque\u00f1os en los orificios horizontales de los paneles D. Montaje paneles D El siguiente paso es colocar el panel L con la LCD en su lugar de manera similar a como hicimos con el panel K y lo sujetamos con dos burlones peque\u00f1os. Montaje panel L Antes de finalizar el montaje con la colocaci\u00f3n del techo y la puerta abatible trasera es necesario cablear el conjunto por lo que estos pasos finales los incluiremos en el apartado Conexionado .","title":"Montaje de las partes"},{"location":"operadores/","text":"Operadores en programaci\u00f3n C++ \u00b6 \u00bfQue es un operador? \u00b6 En general se puede decir que un operador es un elemento de programa que se aplica a uno o varios operandos en una expresi\u00f3n o instrucci\u00f3n. Existen muchos tipos de operadores y nosotros vamos a mostrar aqu\u00ed solamente algunos de los mas utilizados. Los mostraremos por tipos como sistema para clasificarlos. Operadores de asignaci\u00f3n \u00b6 Sirven para asignar un valor especifico a una variable mediante asignaci\u00f3n simple o por dos operadores. En la tabla siguiente vemos algunos de estos operadores: Operador Nombre Sintaxis = Asignaci\u00f3n a = b += Suma y asignaci\u00f3n a += b; a = a + b -= Resta y asignaci\u00f3n a -= b; a = a - b *= Multiplicaci\u00f3n y asignaci\u00f3n a *= b; a = a * b /= Divisi\u00f3n y asignaci\u00f3n a /= b; a = a / b ++ Posincremento o preincremento a++ ; ++a -- Posdecremento o predecremento a-- ; --a Operadores Aritm\u00e9ticos \u00b6 Nos permiten hacer operaciones o c\u00e1lculos simples. Los vemos en la tabla siguiente: Operador Nombre Sintaxis + Suma a + b - Resta a - b * Multiplicaci\u00f3n a * b / Divisi\u00f3n a / b % M\u00f3dulo o resto de divisi\u00f3n a % b ++ Incremento en 1 a++; a = a+1 -- Decremento en 1 a--; a = a-1 Operadores Relacionales o de comparaci\u00f3n \u00b6 Sirven para comparar dos variables o expresiones o bien probar la veracidad de una condici\u00f3n. La respuesta es tipo booleano (falso = 0 y verdadero = 1). Los vemos en la tabla siguiente: Operador Nombre Sintaxis < Menor que a < b > Mayor que a > b <= Menor o igual que a <= b <= Mayor o igual que a >= b == Igual a == b != Distinto a != b Operadores l\u00f3gicos \u00b6 Siempre generan un resultado de tipo booleano y se corresponden con la idea de funcionamiento de las tablas de verdad de la puertas l\u00f3gicas elementales. En la tabla siguiente se dan las tablas de verdad y los operadores. a b AND OR NOT a NOT b Operador Nombre Sintaxis 0 0 0 0 1 1 0 1 0 1 1 0 && Y l\u00f3gico-AND a&&b 1 0 0 1 0 1 1 1 1 1 0 0 ! Negaci\u00f3n l\u00f3gica-NOT !a Existen otros muchos operadores que se pueden consultar en la web.","title":"Operadores en C++"},{"location":"operadores/#operadores-en-programacion-c","text":"","title":"Operadores en programaci\u00f3n C++"},{"location":"operadores/#que-es-un-operador","text":"En general se puede decir que un operador es un elemento de programa que se aplica a uno o varios operandos en una expresi\u00f3n o instrucci\u00f3n. Existen muchos tipos de operadores y nosotros vamos a mostrar aqu\u00ed solamente algunos de los mas utilizados. Los mostraremos por tipos como sistema para clasificarlos.","title":"\u00bfQue es un operador?"},{"location":"operadores/#operadores-de-asignacion","text":"Sirven para asignar un valor especifico a una variable mediante asignaci\u00f3n simple o por dos operadores. En la tabla siguiente vemos algunos de estos operadores: Operador Nombre Sintaxis = Asignaci\u00f3n a = b += Suma y asignaci\u00f3n a += b; a = a + b -= Resta y asignaci\u00f3n a -= b; a = a - b *= Multiplicaci\u00f3n y asignaci\u00f3n a *= b; a = a * b /= Divisi\u00f3n y asignaci\u00f3n a /= b; a = a / b ++ Posincremento o preincremento a++ ; ++a -- Posdecremento o predecremento a-- ; --a","title":"Operadores de asignaci\u00f3n"},{"location":"operadores/#operadores-aritmeticos","text":"Nos permiten hacer operaciones o c\u00e1lculos simples. Los vemos en la tabla siguiente: Operador Nombre Sintaxis + Suma a + b - Resta a - b * Multiplicaci\u00f3n a * b / Divisi\u00f3n a / b % M\u00f3dulo o resto de divisi\u00f3n a % b ++ Incremento en 1 a++; a = a+1 -- Decremento en 1 a--; a = a-1","title":"Operadores Aritm\u00e9ticos"},{"location":"operadores/#operadores-relacionales-o-de-comparacion","text":"Sirven para comparar dos variables o expresiones o bien probar la veracidad de una condici\u00f3n. La respuesta es tipo booleano (falso = 0 y verdadero = 1). Los vemos en la tabla siguiente: Operador Nombre Sintaxis < Menor que a < b > Mayor que a > b <= Menor o igual que a <= b <= Mayor o igual que a >= b == Igual a == b != Distinto a != b","title":"Operadores Relacionales o de comparaci\u00f3n"},{"location":"operadores/#operadores-logicos","text":"Siempre generan un resultado de tipo booleano y se corresponden con la idea de funcionamiento de las tablas de verdad de la puertas l\u00f3gicas elementales. En la tabla siguiente se dan las tablas de verdad y los operadores. a b AND OR NOT a NOT b Operador Nombre Sintaxis 0 0 0 0 1 1 0 1 0 1 1 0 && Y l\u00f3gico-AND a&&b 1 0 0 1 0 1 1 1 1 1 0 0 ! Negaci\u00f3n l\u00f3gica-NOT !a Existen otros muchos operadores que se pueden consultar en la web.","title":"Operadores l\u00f3gicos"},{"location":"parte1/","text":"Parte 1: Tableros B y H \u00b6 Materiales \u00b6 En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 1. N. Cantidad Imagen Descripci\u00f3n 1 2 Tableros de madera con las letras B y H 2 1 Bot\u00f3n pulsador 3 1 M\u00f3dulo amplificador de potencia 4 1 Servo 9g de 180\u00ba 5 1 Tira de luces LED WS2812B a color 6 1 Tornillos cabeza redonda M2x4mm (incluido con el servo) 7 4 Tornillos autoroscante cabeza redonda M1.2x4mm 8 2 Tornillos cabeza redonda M2x16mm 9 2 Tornillos cabeza redonda M3x8mm 10 2 Tuercas M2 11 2 Tuercas M3 12 1 Cable 26AWG (negro-rojo-amarillo) dupont de 15cm 3 pines H-H para el pulsador 13 1 Cable 26AWG (negro-rojo-verde) dupont de 15cm 3 pines H-H para el pulsador para tiras de LEDs 14 1 Cable 26AWG (negro-rojo-amarillo) dupont de 20cm 3 pines H-H para el amplificador 15 1 Destornillador 3.0x40mm 16 1 Destornillador 2.0x40mm Ensamble \u00b6 Seguimos la siguiente secuencia de colocaci\u00f3n de elementos: Pulsador \u00b6 Colocamos el pulsador, en la cara marcada con \"Back side\", en la posici\u00f3n marcada con el n\u00famero 19 en el tablero B y lo sujetamos con un tornillo M3x8mm y una tuerca M3. Amplificador \u00b6 Montamos el amplificador de potencia en el \u00e1rea marcada con 4 en la otra cara del panel B y lo sujetamos con un tornillo M3x8 y una tuerca M3. Dejamos el potenci\u00f3metro colocado en su punto central de forma aproximada. Servomotor \u00b6 Inicializamos el servo de la puerta abatible trasera (0\u00ba - pin D7) y lo colocamos en su posici\u00f3n junto al amplificador debiendo quedar el lado del engranaje del eje en la misma cara que el amplificador. Lo sujetamos en su posici\u00f3n utilizando dos tornillos M2x10mm y dos tuercas M2. Aspa del servo y tablero H \u00b6 Fijamos el aspa en forma de cruz en la pieza H utilizando 4 tornillos M1.2x4mm. Utilizando el tornillo M2x4mm que viene con el servo fijamos el conjunto de aspa y panel H al eje del servo. Debemos tenemos la precauci\u00f3n de que no se mueva el eje del servo de su posici\u00f3n prefijada. Tira de LEDs RGB \u00b6 Colocamos la tira de LEDs en la posici\u00f3n marcada con el n\u00famero 21 en el tablero B. Resultado final \u00b6 En la figura siguiente vemos el tablero B montado por la cara del pulsador. Montaje tablero B En la figura siguiente vemos el tablero B montado por la cara del amplificador. Montaje tablero B En la figura siguiente vemos en detalle el montaje del servo. Detalles del montaje del tablero B","title":"Parte 1. Tableros B y H"},{"location":"parte1/#parte-1-tableros-b-y-h","text":"","title":"Parte 1: Tableros B y H"},{"location":"parte1/#materiales","text":"En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 1. N. Cantidad Imagen Descripci\u00f3n 1 2 Tableros de madera con las letras B y H 2 1 Bot\u00f3n pulsador 3 1 M\u00f3dulo amplificador de potencia 4 1 Servo 9g de 180\u00ba 5 1 Tira de luces LED WS2812B a color 6 1 Tornillos cabeza redonda M2x4mm (incluido con el servo) 7 4 Tornillos autoroscante cabeza redonda M1.2x4mm 8 2 Tornillos cabeza redonda M2x16mm 9 2 Tornillos cabeza redonda M3x8mm 10 2 Tuercas M2 11 2 Tuercas M3 12 1 Cable 26AWG (negro-rojo-amarillo) dupont de 15cm 3 pines H-H para el pulsador 13 1 Cable 26AWG (negro-rojo-verde) dupont de 15cm 3 pines H-H para el pulsador para tiras de LEDs 14 1 Cable 26AWG (negro-rojo-amarillo) dupont de 20cm 3 pines H-H para el amplificador 15 1 Destornillador 3.0x40mm 16 1 Destornillador 2.0x40mm","title":"Materiales"},{"location":"parte1/#ensamble","text":"Seguimos la siguiente secuencia de colocaci\u00f3n de elementos:","title":"Ensamble"},{"location":"parte1/#pulsador","text":"Colocamos el pulsador, en la cara marcada con \"Back side\", en la posici\u00f3n marcada con el n\u00famero 19 en el tablero B y lo sujetamos con un tornillo M3x8mm y una tuerca M3.","title":"Pulsador"},{"location":"parte1/#amplificador","text":"Montamos el amplificador de potencia en el \u00e1rea marcada con 4 en la otra cara del panel B y lo sujetamos con un tornillo M3x8 y una tuerca M3. Dejamos el potenci\u00f3metro colocado en su punto central de forma aproximada.","title":"Amplificador"},{"location":"parte1/#servomotor","text":"Inicializamos el servo de la puerta abatible trasera (0\u00ba - pin D7) y lo colocamos en su posici\u00f3n junto al amplificador debiendo quedar el lado del engranaje del eje en la misma cara que el amplificador. Lo sujetamos en su posici\u00f3n utilizando dos tornillos M2x10mm y dos tuercas M2.","title":"Servomotor"},{"location":"parte1/#aspa-del-servo-y-tablero-h","text":"Fijamos el aspa en forma de cruz en la pieza H utilizando 4 tornillos M1.2x4mm. Utilizando el tornillo M2x4mm que viene con el servo fijamos el conjunto de aspa y panel H al eje del servo. Debemos tenemos la precauci\u00f3n de que no se mueva el eje del servo de su posici\u00f3n prefijada.","title":"Aspa del servo y tablero H"},{"location":"parte1/#tira-de-leds-rgb","text":"Colocamos la tira de LEDs en la posici\u00f3n marcada con el n\u00famero 21 en el tablero B.","title":"Tira de LEDs RGB"},{"location":"parte1/#resultado-final","text":"En la figura siguiente vemos el tablero B montado por la cara del pulsador. Montaje tablero B En la figura siguiente vemos el tablero B montado por la cara del amplificador. Montaje tablero B En la figura siguiente vemos en detalle el montaje del servo. Detalles del montaje del tablero B","title":"Resultado final"},{"location":"parte2/","text":"Parte 2: Tableros A e I \u00b6 Materiales \u00b6 En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 2. N. Cantidad Imagen Descripci\u00f3n 1 2 Tableros de madera con las letras A e I 2 1 Teclado 4x4 de membrana 3 1 Sensor de gases 4 1 Sensor de presencia PIR 5 1 Tira de luces LED WS2812B a color 6 1 Tornillos cabeza redonda M2x4mm (incluido con el servo) 7 2 Tornillos cabeza redonda M3x8mm 8 2 Separadores o columnas de pl\u00e1stico ABS 9 2 Tuercas M3 9 1 Tuercas M3 autoblocante 10 2 Cable 26AWG (negro-rojo-amarillo) dupont de 15cm 3 pines H-H para el sensor PIR 11 1 Cable 26AWG (negro-rojo-verde) dupont de 15cm 3 pines H-H para el pulsador para tiras de LEDs 12 1 Cable 26AWG (negro-rojo-azul-verde) dupont de 20cm 4 pines H-H para el sensor de gases 13 1 Destornillador 3.0x40mm Ensamble \u00b6 Seguimos la siguiente secuencia de colocaci\u00f3n de elementos: Sensor de gases \u00b6 Colocamos el sensor de gases MQ2 en la posici\u00f3n marcada con el n\u00famero 3 en el tablero A y lo sujetamos con un tornillo M3x8mm y una tuerca M3. Sensor de presencia PIR \u00b6 Montamos el sensor de presencia PIR en el \u00e1rea marcada con 2 en el panel A y lo sujetamos con un tornillo M3x8 y una tuerca M3. Tira de LEDs RGB \u00b6 Colocamos la tira de LEDs en la posici\u00f3n marcada con el n\u00famero 20 en el tablero A. Teclado \u00b6 Retiramos el protector y adherimos el teclado de membrana de 4x4 en el \u00e1rea marcada con 1 en el panel A. Nos aseguramos de que quede bien pegado. Panel I \u00b6 Montamos el panel I en el A utilizando el tornillo M3x20, los dos separadores de pl\u00e1stico ABS colocados uno encima del otro y una tuerca M3, de forma que el panel I quede por el lado contrario al teclado. No apretar mucho la tuerca de forma que el panel I gire libremente. Resultado final \u00b6 En la figura siguiente vemos el tablero A montado por la cara de los sensores y el teclado. Montaje tablero A En la figura siguiente vemos en detalle el montaje del panel I. Detalles del montaje del tablero I","title":"Parte 2. Tableros A e I"},{"location":"parte2/#parte-2-tableros-a-e-i","text":"","title":"Parte 2: Tableros A e I"},{"location":"parte2/#materiales","text":"En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 2. N. Cantidad Imagen Descripci\u00f3n 1 2 Tableros de madera con las letras A e I 2 1 Teclado 4x4 de membrana 3 1 Sensor de gases 4 1 Sensor de presencia PIR 5 1 Tira de luces LED WS2812B a color 6 1 Tornillos cabeza redonda M2x4mm (incluido con el servo) 7 2 Tornillos cabeza redonda M3x8mm 8 2 Separadores o columnas de pl\u00e1stico ABS 9 2 Tuercas M3 9 1 Tuercas M3 autoblocante 10 2 Cable 26AWG (negro-rojo-amarillo) dupont de 15cm 3 pines H-H para el sensor PIR 11 1 Cable 26AWG (negro-rojo-verde) dupont de 15cm 3 pines H-H para el pulsador para tiras de LEDs 12 1 Cable 26AWG (negro-rojo-azul-verde) dupont de 20cm 4 pines H-H para el sensor de gases 13 1 Destornillador 3.0x40mm","title":"Materiales"},{"location":"parte2/#ensamble","text":"Seguimos la siguiente secuencia de colocaci\u00f3n de elementos:","title":"Ensamble"},{"location":"parte2/#sensor-de-gases","text":"Colocamos el sensor de gases MQ2 en la posici\u00f3n marcada con el n\u00famero 3 en el tablero A y lo sujetamos con un tornillo M3x8mm y una tuerca M3.","title":"Sensor de gases"},{"location":"parte2/#sensor-de-presencia-pir","text":"Montamos el sensor de presencia PIR en el \u00e1rea marcada con 2 en el panel A y lo sujetamos con un tornillo M3x8 y una tuerca M3.","title":"Sensor de presencia PIR"},{"location":"parte2/#tira-de-leds-rgb","text":"Colocamos la tira de LEDs en la posici\u00f3n marcada con el n\u00famero 20 en el tablero A.","title":"Tira de LEDs RGB"},{"location":"parte2/#teclado","text":"Retiramos el protector y adherimos el teclado de membrana de 4x4 en el \u00e1rea marcada con 1 en el panel A. Nos aseguramos de que quede bien pegado.","title":"Teclado"},{"location":"parte2/#panel-i","text":"Montamos el panel I en el A utilizando el tornillo M3x20, los dos separadores de pl\u00e1stico ABS colocados uno encima del otro y una tuerca M3, de forma que el panel I quede por el lado contrario al teclado. No apretar mucho la tuerca de forma que el panel I gire libremente.","title":"Panel I"},{"location":"parte2/#resultado-final","text":"En la figura siguiente vemos el tablero A montado por la cara de los sensores y el teclado. Montaje tablero A En la figura siguiente vemos en detalle el montaje del panel I. Detalles del montaje del tablero I","title":"Resultado final"},{"location":"parte3/","text":"Parte 3: Tablero K \u00b6 Materiales \u00b6 En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 3. N. Cantidad Imagen Descripci\u00f3n 1 1 Tablero de madera con la letra K 2 1 Sensor de ultrasonidos HC-SR04 3 2 LED RGB de 10mm de alto brillo 4 2 Tornillos cabeza redonda M3x8mm 5 4 Tornillos cabeza redonda M1.4x8mm 6 2 Tuercas M3 7 4 Tuercas M1.4 8 1 Cable 26AWG (rojo-azul-verde-negro) dupont de 35cm 4 pines H-H para HC-SR04 9 2 Cable 26AWG (rojo-rojo-azul-verde) dupont de 35cm 4 pines H-H para LEDs RGB alto brillo 10 1 Destornillador 3.0x40mm 16 1 Destornillador 2.0x40mm Ensamble \u00b6 Seguimos la siguiente secuencia de colocaci\u00f3n de elementos: Sensor de ultrasonidos \u00b6 Colocamos el cable 26AWG (rojo-azul-verde-negro) dupont de 35cm 4 pines H-H en el sensor de ultrasonidos HC-SR04 de forma que el cable negro coincida con GND. Colocamos el sensor de ultrasonidos HC-SR04 en la posici\u00f3n marcada con el n\u00famero 8 en el tablero K y lo sujetamos con 4 tornillos M1.4x8mm y cuatro tuercas M1.4. Diodos LEDs RGB de 10mm \u00b6 Cableamos los diodos LED RGB de alto brillo de 10mm con los cables 26AWG (rojo-rojo-azul-verde) dupont de 35cm 4 pines H-H de forma que el primer cable rojo coincida con VCC y as\u00ed el resto coinciden con el color RGB correspondiente. Instalamos los m\u00f3dulos con diodo LED en las zonas marcadas con los n\u00famero 9 y 10 en el panel K y los fijamos en su posici\u00f3n con dos tornillos M3x8mm y dos tuercas M3. Resultado final \u00b6 En la figura siguiente vemos el tablero K montado por la cara frontal. Montaje tablero K En la figura siguiente vemos el tablero K montado por la cara posterior. Montaje tablero K","title":"Parte 3. Tablero K"},{"location":"parte3/#parte-3-tablero-k","text":"","title":"Parte 3: Tablero K"},{"location":"parte3/#materiales","text":"En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 3. N. Cantidad Imagen Descripci\u00f3n 1 1 Tablero de madera con la letra K 2 1 Sensor de ultrasonidos HC-SR04 3 2 LED RGB de 10mm de alto brillo 4 2 Tornillos cabeza redonda M3x8mm 5 4 Tornillos cabeza redonda M1.4x8mm 6 2 Tuercas M3 7 4 Tuercas M1.4 8 1 Cable 26AWG (rojo-azul-verde-negro) dupont de 35cm 4 pines H-H para HC-SR04 9 2 Cable 26AWG (rojo-rojo-azul-verde) dupont de 35cm 4 pines H-H para LEDs RGB alto brillo 10 1 Destornillador 3.0x40mm 16 1 Destornillador 2.0x40mm","title":"Materiales"},{"location":"parte3/#ensamble","text":"Seguimos la siguiente secuencia de colocaci\u00f3n de elementos:","title":"Ensamble"},{"location":"parte3/#sensor-de-ultrasonidos","text":"Colocamos el cable 26AWG (rojo-azul-verde-negro) dupont de 35cm 4 pines H-H en el sensor de ultrasonidos HC-SR04 de forma que el cable negro coincida con GND. Colocamos el sensor de ultrasonidos HC-SR04 en la posici\u00f3n marcada con el n\u00famero 8 en el tablero K y lo sujetamos con 4 tornillos M1.4x8mm y cuatro tuercas M1.4.","title":"Sensor de ultrasonidos"},{"location":"parte3/#diodos-leds-rgb-de-10mm","text":"Cableamos los diodos LED RGB de alto brillo de 10mm con los cables 26AWG (rojo-rojo-azul-verde) dupont de 35cm 4 pines H-H de forma que el primer cable rojo coincida con VCC y as\u00ed el resto coinciden con el color RGB correspondiente. Instalamos los m\u00f3dulos con diodo LED en las zonas marcadas con los n\u00famero 9 y 10 en el panel K y los fijamos en su posici\u00f3n con dos tornillos M3x8mm y dos tuercas M3.","title":"Diodos LEDs RGB de 10mm"},{"location":"parte3/#resultado-final","text":"En la figura siguiente vemos el tablero K montado por la cara frontal. Montaje tablero K En la figura siguiente vemos el tablero K montado por la cara posterior. Montaje tablero K","title":"Resultado final"},{"location":"parte4/","text":"Parte 4: Tablero L \u00b6 Materiales \u00b6 En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 3. N. Cantidad Imagen Descripci\u00f3n 1 1 Tablero de madera con la letra L 2 1 Pantatalla LCD 16x2 I2C 3 4 Tornillos cabeza redonda M3x8mm 4 4 Tuercas M3 5 1 Cable 26AWG (negro-rojo-azul-verde) dupont de 20cm 4 pines H-H para LCD I2C 6 1 Destornillador 3.0x40mm Ensamble \u00b6 Seguimos la siguiente secuencia de colocaci\u00f3n de elementos: Pantalla LCD \u00b6 Colocamos en el display LCD con el cable 26AWG (negro-rojo-azul-verde) dupont de 20cm 4 pines H-H en el conector de la LCD de forma que el cable negro coincida con GND. Montamos el display LCD en la posici\u00f3n marcada con el n\u00famero 11 en el tablero L y lo sujetamos con 4 tornillos M3x8mm y cuatro tuercas M3. Resultado final \u00b6 En la figura siguiente vemos el tablero L montado por la cara frontal. Montaje tablero L En la figura siguiente vemos el tablero L montado por la cara posterior. Montaje tablero L","title":"Parte 4. Tablero L"},{"location":"parte4/#parte-4-tablero-l","text":"","title":"Parte 4: Tablero L"},{"location":"parte4/#materiales","text":"En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 3. N. Cantidad Imagen Descripci\u00f3n 1 1 Tablero de madera con la letra L 2 1 Pantatalla LCD 16x2 I2C 3 4 Tornillos cabeza redonda M3x8mm 4 4 Tuercas M3 5 1 Cable 26AWG (negro-rojo-azul-verde) dupont de 20cm 4 pines H-H para LCD I2C 6 1 Destornillador 3.0x40mm","title":"Materiales"},{"location":"parte4/#ensamble","text":"Seguimos la siguiente secuencia de colocaci\u00f3n de elementos:","title":"Ensamble"},{"location":"parte4/#pantalla-lcd","text":"Colocamos en el display LCD con el cable 26AWG (negro-rojo-azul-verde) dupont de 20cm 4 pines H-H en el conector de la LCD de forma que el cable negro coincida con GND. Montamos el display LCD en la posici\u00f3n marcada con el n\u00famero 11 en el tablero L y lo sujetamos con 4 tornillos M3x8mm y cuatro tuercas M3.","title":"Pantalla LCD"},{"location":"parte4/#resultado-final","text":"En la figura siguiente vemos el tablero L montado por la cara frontal. Montaje tablero L En la figura siguiente vemos el tablero L montado por la cara posterior. Montaje tablero L","title":"Resultado final"},{"location":"parte5/","text":"Parte 5: Tableros N y O \u00b6 Materiales \u00b6 En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 5. N. Cantidad Imagen Descripci\u00f3n 1 1 Tablero de madera con la letra N 2 1 Tablero acr\u00edlico con la letra O 3 1 Engranaje de madera 4 1 Sensor de vapor 5 1 Sensor anal\u00f3gico ratativo o Potenci\u00f3metro 6 1 Servo 9g de 180\u00ba 7 2 Separadores o columnas de pl\u00e1stico ABS 8 2 Separadores o columnas met\u00e1licas de 10mm con rosca M3 interior 9 4 Tornillos autoroscante cabeza redonda M1.2x4mm 10 2 Tornillos cabeza redonda M2x16mm 11 1 Tornillos cabeza redonda M2x4mm (incluido con el servo) 12 4 Tornillos cabeza redonda M3x8mm 13 4 Tornillos cabeza redonda M3x10mm 14 4 Tuercas M3 autoblocante 15 2 Tuercas M2 16 4 Tuercas M3 17 2 Cable 26AWG (negro-rojo-amarillo) dupont de 20cm 3 pines H-H para sensor de vapor y potenci\u00f3metro 18 1 Destornillador 3.0x40mm 19 1 Destornillador 2.0x40mm Ensamble \u00b6 Seguimos la siguiente secuencia de colocaci\u00f3n de elementos: Sensor de vapor y potenci\u00f3metro \u00b6 Colocamos el sensor de vapor en la posici\u00f3n marcada con el n\u00famero 17 y el potenci\u00f3metro en el 16 en el tablero N y los sujetamos con un tornillo M3x8mm y una tuerca M3 cada uno. Servomotor \u00b6 Inicializamos el servo de la ventana del techo (0\u00ba - pin D8) y lo colocamos en su posici\u00f3n junto al amplificador debiendo quedar el lado del engranaje del eje en la cara opusta a los sensores. Lo sujetamos en su posici\u00f3n utilizando las dos columnas de pl\u00e1stico, los dos tornillos M2x16mm y dos tuercas M2. Aspa del servo y engranaje \u00b6 Fijamos el aspa en forma de cruz en el engranaje utilizando 4 tornillos M1.2x4mm y fijamos el conjunto con el tornillo M2x4mm (viene con el motor) al eje del servo teniendo mucho cuidado para no mover el eje sel mismo. Panel acr\u00edlico O \u00b6 Instalamos el panel O en el panel N utilizado la torniller\u00eda que vemos en la figura siguiente. No es necesario apretar los tornillos firmemente. Los dos tornillos M3x8 que nos quedan los utilizamos para sujetar los separadores y los de M3x10 los utilizamos para sujetar el panel O junto con las tuercas M3 autoblocantees. Resultado final \u00b6 En la figura siguiente vemos los tableros N y O por la cara de sensores. Montaje tableros N y O En la figura siguiente vemos los tableros N y O montados por la cara del engranaje. Montaje tableros N y O En la figura siguiente vemos en detalle el montaje del servo. Detalles del montaje del tablero B","title":"Parte 5. Tableros N y O"},{"location":"parte5/#parte-5-tableros-n-y-o","text":"","title":"Parte 5: Tableros N y O"},{"location":"parte5/#materiales","text":"En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 5. N. Cantidad Imagen Descripci\u00f3n 1 1 Tablero de madera con la letra N 2 1 Tablero acr\u00edlico con la letra O 3 1 Engranaje de madera 4 1 Sensor de vapor 5 1 Sensor anal\u00f3gico ratativo o Potenci\u00f3metro 6 1 Servo 9g de 180\u00ba 7 2 Separadores o columnas de pl\u00e1stico ABS 8 2 Separadores o columnas met\u00e1licas de 10mm con rosca M3 interior 9 4 Tornillos autoroscante cabeza redonda M1.2x4mm 10 2 Tornillos cabeza redonda M2x16mm 11 1 Tornillos cabeza redonda M2x4mm (incluido con el servo) 12 4 Tornillos cabeza redonda M3x8mm 13 4 Tornillos cabeza redonda M3x10mm 14 4 Tuercas M3 autoblocante 15 2 Tuercas M2 16 4 Tuercas M3 17 2 Cable 26AWG (negro-rojo-amarillo) dupont de 20cm 3 pines H-H para sensor de vapor y potenci\u00f3metro 18 1 Destornillador 3.0x40mm 19 1 Destornillador 2.0x40mm","title":"Materiales"},{"location":"parte5/#ensamble","text":"Seguimos la siguiente secuencia de colocaci\u00f3n de elementos:","title":"Ensamble"},{"location":"parte5/#sensor-de-vapor-y-potenciometro","text":"Colocamos el sensor de vapor en la posici\u00f3n marcada con el n\u00famero 17 y el potenci\u00f3metro en el 16 en el tablero N y los sujetamos con un tornillo M3x8mm y una tuerca M3 cada uno.","title":"Sensor de vapor y potenci\u00f3metro"},{"location":"parte5/#servomotor","text":"Inicializamos el servo de la ventana del techo (0\u00ba - pin D8) y lo colocamos en su posici\u00f3n junto al amplificador debiendo quedar el lado del engranaje del eje en la cara opusta a los sensores. Lo sujetamos en su posici\u00f3n utilizando las dos columnas de pl\u00e1stico, los dos tornillos M2x16mm y dos tuercas M2.","title":"Servomotor"},{"location":"parte5/#aspa-del-servo-y-engranaje","text":"Fijamos el aspa en forma de cruz en el engranaje utilizando 4 tornillos M1.2x4mm y fijamos el conjunto con el tornillo M2x4mm (viene con el motor) al eje del servo teniendo mucho cuidado para no mover el eje sel mismo.","title":"Aspa del servo y engranaje"},{"location":"parte5/#panel-acrilico-o","text":"Instalamos el panel O en el panel N utilizado la torniller\u00eda que vemos en la figura siguiente. No es necesario apretar los tornillos firmemente. Los dos tornillos M3x8 que nos quedan los utilizamos para sujetar los separadores y los de M3x10 los utilizamos para sujetar el panel O junto con las tuercas M3 autoblocantees.","title":"Panel acr\u00edlico O"},{"location":"parte5/#resultado-final","text":"En la figura siguiente vemos los tableros N y O por la cara de sensores. Montaje tableros N y O En la figura siguiente vemos los tableros N y O montados por la cara del engranaje. Montaje tableros N y O En la figura siguiente vemos en detalle el montaje del servo. Detalles del montaje del tablero B","title":"Resultado final"},{"location":"parte6/","text":"Parte 6: Tableros M y E \u00b6 Materiales \u00b6 En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 6. N. Cantidad Imagen Descripci\u00f3n 1 1 Tablero de madera con la letra M 2 1 Tablero de madera con la letra E 3 1 Diodo LED blanco 4 1 Sensor de temperatura y humedad DHT11 5 1 Sensor de luz ambiente TEMT6000 6 1 Servo 9g de 180\u00ba 7 1 Placa de control basada en Mega 2560 8 4 Separadores o columnas de pl\u00e1stico ABS 9 4 Tornillos autoroscante cabeza redonda M1.2x4mm 10 2 Tornillos cabeza redonda M2x16mm 11 1 Tornillos cabeza redonda M2x4mm (incluido con el servo) 12 4 Tornillos cabeza redonda M3x8mm 13 4 Tornillos cabeza redonda M3x12mm 14 2 Tuercas M2 15 8 Tuercas M3 16 1 Cable 26AWG (negro-rojo-amarillo) dupont de 20cm 3 pines H-H para DHT11 17 1 Cable 26AWG (negro-rojo-amarillo) dupont de 15cm 3 pines H-H para el TEMT6000 18 1 Destornillador 3.0x40mm 19 1 Destornillador 2.0x40mm Ensamble \u00b6 Seguimos la siguiente secuencia de colocaci\u00f3n de elementos: Sensores DHT11 y TEMT6000 \u00b6 Colocamos el sensor de temperatura y humedad en la posici\u00f3n marcada con el n\u00famero 14 y sensor de luz ambiente en el 15 en el tablero M y los sujetamos con dos tornillos M3 el DHT11 y un tornillo M3x8mm el TEMT6000 y tres tuercas M3, una para cada uno. LED blanco \u00b6 Colocamos el LED blanco en la posici\u00f3n marcada con el n\u00famero 12 que est\u00e1 en la otra cara del panel M y lo sujetamos con un tornillo M3x8mm y una tuerca M3. Servomotor \u00b6 Inicializamos el servo de la puerta (80\u00ba - pin D6) y lo colocamos en su posici\u00f3n debiendo quedar el lado del engranaje del eje en la cara del diodo LED. Lo sujetamos en su posici\u00f3n utilizando las dos columnas de pl\u00e1stico, los dos tornillos M2x16mm y dos tuercas M2. Aspa del servo y panel E \u00b6 Fijamos el aspa en forma de cruz en el panel E utilizando 4 tornillos M1.2x4mm. Fijamos el conjunto con el tornillo M2x4mm (viene con el motor) al eje del servo teniendo mucho cuidado para no mover el eje sel mismo. Placa de control \u00b6 Instalamos la placa de control en el panel M y la fijamos utilizando cuatro tornillos M3x12mm, cuatro separados de pl\u00e1stico y 4 tuercas M3. Resultado final \u00b6 En la figura siguiente vemos los tableros N y O por la cara de sensor DHT11. Montaje tableros M y E En la figura siguiente vemos los tableros M y E montados por la cara del LED. Montaje tableros M y E En la figura siguiente vemos en detalle el montaje del servo. Detalles del montaje del tablero E","title":"Parte 6. Tableros M y E"},{"location":"parte6/#parte-6-tableros-m-y-e","text":"","title":"Parte 6: Tableros M y E"},{"location":"parte6/#materiales","text":"En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 6. N. Cantidad Imagen Descripci\u00f3n 1 1 Tablero de madera con la letra M 2 1 Tablero de madera con la letra E 3 1 Diodo LED blanco 4 1 Sensor de temperatura y humedad DHT11 5 1 Sensor de luz ambiente TEMT6000 6 1 Servo 9g de 180\u00ba 7 1 Placa de control basada en Mega 2560 8 4 Separadores o columnas de pl\u00e1stico ABS 9 4 Tornillos autoroscante cabeza redonda M1.2x4mm 10 2 Tornillos cabeza redonda M2x16mm 11 1 Tornillos cabeza redonda M2x4mm (incluido con el servo) 12 4 Tornillos cabeza redonda M3x8mm 13 4 Tornillos cabeza redonda M3x12mm 14 2 Tuercas M2 15 8 Tuercas M3 16 1 Cable 26AWG (negro-rojo-amarillo) dupont de 20cm 3 pines H-H para DHT11 17 1 Cable 26AWG (negro-rojo-amarillo) dupont de 15cm 3 pines H-H para el TEMT6000 18 1 Destornillador 3.0x40mm 19 1 Destornillador 2.0x40mm","title":"Materiales"},{"location":"parte6/#ensamble","text":"Seguimos la siguiente secuencia de colocaci\u00f3n de elementos:","title":"Ensamble"},{"location":"parte6/#sensores-dht11-y-temt6000","text":"Colocamos el sensor de temperatura y humedad en la posici\u00f3n marcada con el n\u00famero 14 y sensor de luz ambiente en el 15 en el tablero M y los sujetamos con dos tornillos M3 el DHT11 y un tornillo M3x8mm el TEMT6000 y tres tuercas M3, una para cada uno.","title":"Sensores DHT11 y TEMT6000"},{"location":"parte6/#led-blanco","text":"Colocamos el LED blanco en la posici\u00f3n marcada con el n\u00famero 12 que est\u00e1 en la otra cara del panel M y lo sujetamos con un tornillo M3x8mm y una tuerca M3.","title":"LED blanco"},{"location":"parte6/#servomotor","text":"Inicializamos el servo de la puerta (80\u00ba - pin D6) y lo colocamos en su posici\u00f3n debiendo quedar el lado del engranaje del eje en la cara del diodo LED. Lo sujetamos en su posici\u00f3n utilizando las dos columnas de pl\u00e1stico, los dos tornillos M2x16mm y dos tuercas M2.","title":"Servomotor"},{"location":"parte6/#aspa-del-servo-y-panel-e","text":"Fijamos el aspa en forma de cruz en el panel E utilizando 4 tornillos M1.2x4mm. Fijamos el conjunto con el tornillo M2x4mm (viene con el motor) al eje del servo teniendo mucho cuidado para no mover el eje sel mismo.","title":"Aspa del servo y panel E"},{"location":"parte6/#placa-de-control","text":"Instalamos la placa de control en el panel M y la fijamos utilizando cuatro tornillos M3x12mm, cuatro separados de pl\u00e1stico y 4 tuercas M3.","title":"Placa de control"},{"location":"parte6/#resultado-final","text":"En la figura siguiente vemos los tableros N y O por la cara de sensor DHT11. Montaje tableros M y E En la figura siguiente vemos los tableros M y E montados por la cara del LED. Montaje tableros M y E En la figura siguiente vemos en detalle el montaje del servo. Detalles del montaje del tablero E","title":"Resultado final"},{"location":"parte7/","text":"Parte 7: Tablero C \u00b6 Materiales \u00b6 En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 7. N. Cantidad Imagen Descripci\u00f3n 1 1 Tablero de madera con la letra C 2 1 Portapilas 6xAA con conector JST de 2 pines polarizado 3 1 Panel con tres sensores siguel\u00edneas 4 4 Ruedas 5 4 Motor DC de 4.5V y 200 rpm con cable y conector JST de 2 pines polarizado 6 4 Piezas de aluminio con rosca M3 de 23x15x5mm 7 2 Separadores de metal de 20mm con agujero roscado M3 9 2 Tornillos cabeza achaflanada M3x12mm 10 12 Tornillos cabeza redonda M3x8mm 11 8 Tornillos cabeza redonda M3x30mm 12 12 Tuercas M3 13 1 Cable 26AWG de 40cm 5 pines con conectores JST de 2 pines polarizados 14 1 Destornillador 3.0x40mm Ensamble \u00b6 Seguimos la siguiente secuencia de colocaci\u00f3n de elementos: Piezas de aluminio \u00b6 Ensamblamos las cuatro piezas de aluminio de color negro para fijar los motores y las sujetamos con dos tornillos M3x8mm cada una. Van fijadas por la cara del panel marcada con la letra C Motores \u00b6 Instalamos los motores sobre el panel pocicionandolos como vemos en las figuras siguientes y lo sujetamos a las piezas de aluminio con dos tornillos M3x30mm y dos tuercas M3 cada uno. Ruedas \u00b6 Instalamos las ruedas en los motores Portapilas \u00b6 Fijamos el portapilas en el panel C en la zona marcada con el n\u00famero 7 y utilizando 2 tornillos M3x12mm con cabeza avellanada para sujetarlo. Sensor siguel\u00edneas \u00b6 Montamos el sensor en la zona marcada con el n\u00famero 6 en el panel C y lo fijamos utilizando cuatro tornillos M3x8mm y dos separados met\u00e1licos de 20mm. Resultado final \u00b6 En la figura siguiente vemos el tablero C montado. Montaje tablero C","title":"Parte 7. Tablero C"},{"location":"parte7/#parte-7-tablero-c","text":"","title":"Parte 7: Tablero C"},{"location":"parte7/#materiales","text":"En la tabla siguiente se listan de forma numerada todos los materiales para instalar completamente el montaje de la parte 7. N. Cantidad Imagen Descripci\u00f3n 1 1 Tablero de madera con la letra C 2 1 Portapilas 6xAA con conector JST de 2 pines polarizado 3 1 Panel con tres sensores siguel\u00edneas 4 4 Ruedas 5 4 Motor DC de 4.5V y 200 rpm con cable y conector JST de 2 pines polarizado 6 4 Piezas de aluminio con rosca M3 de 23x15x5mm 7 2 Separadores de metal de 20mm con agujero roscado M3 9 2 Tornillos cabeza achaflanada M3x12mm 10 12 Tornillos cabeza redonda M3x8mm 11 8 Tornillos cabeza redonda M3x30mm 12 12 Tuercas M3 13 1 Cable 26AWG de 40cm 5 pines con conectores JST de 2 pines polarizados 14 1 Destornillador 3.0x40mm","title":"Materiales"},{"location":"parte7/#ensamble","text":"Seguimos la siguiente secuencia de colocaci\u00f3n de elementos:","title":"Ensamble"},{"location":"parte7/#piezas-de-aluminio","text":"Ensamblamos las cuatro piezas de aluminio de color negro para fijar los motores y las sujetamos con dos tornillos M3x8mm cada una. Van fijadas por la cara del panel marcada con la letra C","title":"Piezas de aluminio"},{"location":"parte7/#motores","text":"Instalamos los motores sobre el panel pocicionandolos como vemos en las figuras siguientes y lo sujetamos a las piezas de aluminio con dos tornillos M3x30mm y dos tuercas M3 cada uno.","title":"Motores"},{"location":"parte7/#ruedas","text":"Instalamos las ruedas en los motores","title":"Ruedas"},{"location":"parte7/#portapilas","text":"Fijamos el portapilas en el panel C en la zona marcada con el n\u00famero 7 y utilizando 2 tornillos M3x12mm con cabeza avellanada para sujetarlo.","title":"Portapilas"},{"location":"parte7/#sensor-siguelineas","text":"Montamos el sensor en la zona marcada con el n\u00famero 6 en el panel C y lo fijamos utilizando cuatro tornillos M3x8mm y dos separados met\u00e1licos de 20mm.","title":"Sensor siguel\u00edneas"},{"location":"parte7/#resultado-final","text":"En la figura siguiente vemos el tablero C montado. Montaje tablero C","title":"Resultado final"},{"location":"preliminar/","text":"Antes de continuar \u00b6 Secci\u00f3n en la que vamos a detallar los materiales del kit, como se montan e instalan ampliando la informaci\u00f3n de los elementos que lo requieran. Tomaremos la siguientes precauciones: La cara frontal de los paneles tiene un n\u00famero y la cara posterior est\u00e1 marcada con \"Back side\". No es necesario apretar las tuercas de la ventana al principio. Hay que tener cuida cuando ensamblamos los burlones de madera para no romperlos. Hay que inicializar cada servo a su \u00e1ngulo antes de instalarlo. Hay que retirar el pl\u00e1stico protector de los paneles acr\u00edlicos antes de montarlos. Posicionar servo \u00b6 Antes de colocar en el lugar que le corresponde cada servo es necesario llevarlo a un determinado \u00e1ngulo seg\u00fan la tabla siguiente. Servo Angulo de rotaci\u00f3n Puerto digital Puerta 80\u00ba D6 Puerta trasera abatible 0\u00ba D7 Ventana de techo 0\u00ba D8 Hay que tener mucho cuidado de posicionar el conector de los servos en los tres pines macho de la placa en el orden correcto (el conector es reversible) o seguramente romperemos algo de manera irremediable. La asociaci\u00f3n de colores y pines es la siguiente: G en la placa - pin asociado al conductor marr\u00f3n del servo V en la placa - pin asociado al conductor rojo del servo S en la placa - pin asociado al conductor naranja del servo Ahora mismo no vamos a entrar en mas detalles sobre el tema y simplemente vamos a seguir el siguiente procedimiento: Conectar el servo al pin seg\u00fan la tabla y recomendaciones anteriores. Con el fin de apreciar correctamente los movimientos podemos colocar alguna de las aspas en el servo. Conectar la placa al puerto USB del ordenador utilizando el cable suministrado. Poner en marcha Connector y entrar en ArduinoBlocks con nuestra cuenta. Buscar y llevar a nuestra cuenta (si a\u00fan no lo hemos hecho) el programa posicionar-servo . Configurar el programa de acuerdo al servo que vamos a posicionar y la ayuda gr\u00e1fica que vemos en la figura siguiente. Angulos de poscionado de servos Es muy probable que el servo no se mueva si no suministramos alimentaci\u00f3n externa. Conectamos el portapilas con las 6 pilas colocadas y accionamos el interruptor de la placa. Este interruptor est\u00e1 cerrado cuando su mando est\u00e1 en la posici\u00f3n mas baja. Una vez posicionado el servo desconectamos la alimentaci\u00f3n completamente (incluido USB) y retiramos el aspa colocada en el servo con mucho cuidado de no mover el eje para no modificar el \u00e1ngulo del mismo. Ya podemos colocar el servo en su lugar. Si quieres aprender mas en el documento Control de servos tienes mas informaci\u00f3n sobre servos y cuando trabajemos en su programaci\u00f3n incluiremos teor\u00eda sobre los mismos. La placa de control \u00b6 La placa de desarrollo inteligente KS0509 de Keyestudio basada en Mega 2560 es TMEGA2560-16AU, que es totalmente compatible con la placa de desarrollo Arduino MEGA 2650. Esta placa integra dos drivers para motor TB6612, y est\u00e1 pensada como la soluci\u00f3n para montar la autocaravana o veh\u00edculos que requieren hardware igual o similar. La placa tiene el aspecto que vemos en la figura siguiente: Aspecto de la placa de control Adem\u00e1s, la placa integra una fuente de alimentaci\u00f3n que puede entregar un m\u00e1ximo de 5V y 3A, gracias a los tres reguladores de potencia 29310 dotados de disipaci\u00f3n de calor. La mayor\u00eda de los pines se extienden a pines dotados de alimentaci\u00f3n para facilitar la conexi\u00f3n externa de sensores/m\u00f3dulos. En la figura siguiente vemos la descripci\u00f3n global de pines: Descripci\u00f3n de pines En la tabla siguiente se dan especificaciones t\u00e9cnicas de la placa referidas a la descripci\u00f3n de pines de la figura anterior. Caracter\u00edstica Valor Procesador ATMEGA2560-16AU Tensi\u00f3n de alimentaci\u00f3n 5V Tensi\u00f3n de salida 5V Corriente de salida 3A Alimentaci\u00f3n externa 7 a 12V DC Entradas / salidas digitales 54 puertos (D0 a D53) Pines PWM 15 pines (D2 a D13 y D44 a D46) Entradas anal\u00f3gicas 16 puertos (A0 a A15) Puertos serie RX1 (D19), TX1 (D18), RX2 (D17), TX2 (D16), RX3 (D15), TX3 (D14) I2C SDA (D20), SCL (D21) Conectores para motores TB6612 junto interruptor de alimentaci\u00f3n) Conector C: Velocidad = D9, Direcci\u00f3n = D28, D29 Conector D: Velocidad = D10, Direcci\u00f3n = D30, D31 Conectores para motores TB6612 junto interface USB) Conector A: Velocidad = D12, Direcci\u00f3n = D34, D35 Conector B: Velocidad = D11, Direcci\u00f3n = D32, D33 Corriente m\u00e1xima pines entrada/salida 20 a 50 mA SRAM 8 KB (ATMEGA2560-16AU) EEPROM 4 KB (ATMEGA2560-16AU) Frecuencia de reloj 16 MHz La velocidad de los motores se puede controlar con se\u00f1ales PWM y el sentido del movimiento o direcci\u00f3n con niveles alto y bajo. Control de los motores \u00b6 Esquem\u00e1ticamente las conexiones de los motores descritas en la tabla anterior est\u00e1n realizadas como vemos en la figura siguiente: Esquema de conexionado de motores Trasladado a la placa de control estas conexiones quedan como vemos en la figura siguiente: Conexiones de motores en la placa de control En la tabla siguiente se resumen todas las condiciones de funcionamiento de los motores. Motor Pines Giro en sentido antihorario Giro en sentido horario Parados A D34 D35 D12~ 0 1 PWM (0-255) 1 0 PWM (0-255) - - PWMA = 0 B D32 D33 D11~ 0 1 PWM (0-255) 1 0 PWM (0-255) - - PWMB = 0 C D28 D29 D9~ 1 0 PWM (0-255) 0 1 PWM (0-255) - - PWMC = 0 D D30 D31 D10~ 1 0 PWM (0-255) 0 1 PWM (0-255) - - PWMD = 0","title":"Preliminar"},{"location":"preliminar/#antes-de-continuar","text":"Secci\u00f3n en la que vamos a detallar los materiales del kit, como se montan e instalan ampliando la informaci\u00f3n de los elementos que lo requieran. Tomaremos la siguientes precauciones: La cara frontal de los paneles tiene un n\u00famero y la cara posterior est\u00e1 marcada con \"Back side\". No es necesario apretar las tuercas de la ventana al principio. Hay que tener cuida cuando ensamblamos los burlones de madera para no romperlos. Hay que inicializar cada servo a su \u00e1ngulo antes de instalarlo. Hay que retirar el pl\u00e1stico protector de los paneles acr\u00edlicos antes de montarlos.","title":"Antes de continuar"},{"location":"preliminar/#posicionar-servo","text":"Antes de colocar en el lugar que le corresponde cada servo es necesario llevarlo a un determinado \u00e1ngulo seg\u00fan la tabla siguiente. Servo Angulo de rotaci\u00f3n Puerto digital Puerta 80\u00ba D6 Puerta trasera abatible 0\u00ba D7 Ventana de techo 0\u00ba D8 Hay que tener mucho cuidado de posicionar el conector de los servos en los tres pines macho de la placa en el orden correcto (el conector es reversible) o seguramente romperemos algo de manera irremediable. La asociaci\u00f3n de colores y pines es la siguiente: G en la placa - pin asociado al conductor marr\u00f3n del servo V en la placa - pin asociado al conductor rojo del servo S en la placa - pin asociado al conductor naranja del servo Ahora mismo no vamos a entrar en mas detalles sobre el tema y simplemente vamos a seguir el siguiente procedimiento: Conectar el servo al pin seg\u00fan la tabla y recomendaciones anteriores. Con el fin de apreciar correctamente los movimientos podemos colocar alguna de las aspas en el servo. Conectar la placa al puerto USB del ordenador utilizando el cable suministrado. Poner en marcha Connector y entrar en ArduinoBlocks con nuestra cuenta. Buscar y llevar a nuestra cuenta (si a\u00fan no lo hemos hecho) el programa posicionar-servo . Configurar el programa de acuerdo al servo que vamos a posicionar y la ayuda gr\u00e1fica que vemos en la figura siguiente. Angulos de poscionado de servos Es muy probable que el servo no se mueva si no suministramos alimentaci\u00f3n externa. Conectamos el portapilas con las 6 pilas colocadas y accionamos el interruptor de la placa. Este interruptor est\u00e1 cerrado cuando su mando est\u00e1 en la posici\u00f3n mas baja. Una vez posicionado el servo desconectamos la alimentaci\u00f3n completamente (incluido USB) y retiramos el aspa colocada en el servo con mucho cuidado de no mover el eje para no modificar el \u00e1ngulo del mismo. Ya podemos colocar el servo en su lugar. Si quieres aprender mas en el documento Control de servos tienes mas informaci\u00f3n sobre servos y cuando trabajemos en su programaci\u00f3n incluiremos teor\u00eda sobre los mismos.","title":"Posicionar servo"},{"location":"preliminar/#la-placa-de-control","text":"La placa de desarrollo inteligente KS0509 de Keyestudio basada en Mega 2560 es TMEGA2560-16AU, que es totalmente compatible con la placa de desarrollo Arduino MEGA 2650. Esta placa integra dos drivers para motor TB6612, y est\u00e1 pensada como la soluci\u00f3n para montar la autocaravana o veh\u00edculos que requieren hardware igual o similar. La placa tiene el aspecto que vemos en la figura siguiente: Aspecto de la placa de control Adem\u00e1s, la placa integra una fuente de alimentaci\u00f3n que puede entregar un m\u00e1ximo de 5V y 3A, gracias a los tres reguladores de potencia 29310 dotados de disipaci\u00f3n de calor. La mayor\u00eda de los pines se extienden a pines dotados de alimentaci\u00f3n para facilitar la conexi\u00f3n externa de sensores/m\u00f3dulos. En la figura siguiente vemos la descripci\u00f3n global de pines: Descripci\u00f3n de pines En la tabla siguiente se dan especificaciones t\u00e9cnicas de la placa referidas a la descripci\u00f3n de pines de la figura anterior. Caracter\u00edstica Valor Procesador ATMEGA2560-16AU Tensi\u00f3n de alimentaci\u00f3n 5V Tensi\u00f3n de salida 5V Corriente de salida 3A Alimentaci\u00f3n externa 7 a 12V DC Entradas / salidas digitales 54 puertos (D0 a D53) Pines PWM 15 pines (D2 a D13 y D44 a D46) Entradas anal\u00f3gicas 16 puertos (A0 a A15) Puertos serie RX1 (D19), TX1 (D18), RX2 (D17), TX2 (D16), RX3 (D15), TX3 (D14) I2C SDA (D20), SCL (D21) Conectores para motores TB6612 junto interruptor de alimentaci\u00f3n) Conector C: Velocidad = D9, Direcci\u00f3n = D28, D29 Conector D: Velocidad = D10, Direcci\u00f3n = D30, D31 Conectores para motores TB6612 junto interface USB) Conector A: Velocidad = D12, Direcci\u00f3n = D34, D35 Conector B: Velocidad = D11, Direcci\u00f3n = D32, D33 Corriente m\u00e1xima pines entrada/salida 20 a 50 mA SRAM 8 KB (ATMEGA2560-16AU) EEPROM 4 KB (ATMEGA2560-16AU) Frecuencia de reloj 16 MHz La velocidad de los motores se puede controlar con se\u00f1ales PWM y el sentido del movimiento o direcci\u00f3n con niveles alto y bajo.","title":"La placa de control"},{"location":"preliminar/#control-de-los-motores","text":"Esquem\u00e1ticamente las conexiones de los motores descritas en la tabla anterior est\u00e1n realizadas como vemos en la figura siguiente: Esquema de conexionado de motores Trasladado a la placa de control estas conexiones quedan como vemos en la figura siguiente: Conexiones de motores en la placa de control En la tabla siguiente se resumen todas las condiciones de funcionamiento de los motores. Motor Pines Giro en sentido antihorario Giro en sentido horario Parados A D34 D35 D12~ 0 1 PWM (0-255) 1 0 PWM (0-255) - - PWMA = 0 B D32 D33 D11~ 0 1 PWM (0-255) 1 0 PWM (0-255) - - PWMB = 0 C D28 D29 D9~ 1 0 PWM (0-255) 0 1 PWM (0-255) - - PWMC = 0 D D30 D31 D10~ 1 0 PWM (0-255) 0 1 PWM (0-255) - - PWMD = 0","title":"Control de los motores"},{"location":"soft/","text":"Software \u00b6 Vamos a utilizar el lenguaje de programaci\u00f3n visual por bloques denominado ArduinoBlocks. El aspecto de la plataforma al entrar lo vemos en la imagen siguiente: Portada de la plataforma ArduinoBlocks Podemos programar nuestra placa de control tipo UNO de diversas formas de las que las mas comunes son, a partir del IDE de Arduino o mediante bloques, que ser\u00e1 el m\u00e9todo que sigamos. Programar mediante el IDE requiere teclear instrucciones de c\u00f3digo mientras que con ArduinoBlocks estas instrucciones se sustituyen por bloques tipo puzzle que evitan errores de sintaxis. Evidentemente detr\u00e1s de cada bloque en realidad lo que hay son instrucciones y ArduinoBlocks nos va a permitir verlas y exportarlas. En la imagen siguiente tenemos una comparativa entre bloques de c\u00f3digo e instrucciones en el IDE. Comparativa entre bloques y c\u00f3digo Es importante entender que la programaci\u00f3n con ArduinoBlocks simplifica la iniciaci\u00f3n en el pensamiento computacional permitiendo realizar tareas complejas de una forma sencilla. Para el caso de la TdR STEAM cabe destacar que ArduinoBlocks incluye una serie de bloques espec\u00edficos que facilitan a\u00fan mas si cabe su programaci\u00f3n. ArduinoBlocks trabaja a trav\u00e9s de una plataforma online por lo que no requiere instalaci\u00f3n en nuestro sistema. No obstante, si que tenemos que instalar un peque\u00f1o programa que ser\u00e1 el encargado de conectar nuestro programa en el navegador con la placa Keyestudio UNO. Este programa basado en Python se llama Connector . Lo primero que deberemos hacer es crear una cuenta en ArduinoBlocks utilizando una direcci\u00f3n de correo electr\u00f3nico v\u00e1lida y despu\u00e9s instalar el software Connector . En los manuales de referencia disponibles en la plataforma est\u00e1n todos los detalles sobre como llevar a cabo estas tareas. La versi\u00f3n 5.1 del programa una vez iniciado la vemos en la imagen siguiente: Connector V5.1 Si no est\u00e1s muy avezado en estos temas es necesarios al menos ver los siguientes v\u00eddeos sobre el tema: Bloque 1: Puesta en marcha con ArduinoBlocks Empezando con ArduinoBlocks y la programaci\u00f3n por bloques Crear una cuenta en ArduinoBlocks e iniciar un proyecto personal Configurar la conexi\u00f3n a ArduinoBlocks y detectar la placa Arduino Carga del primer programa","title":"Software"},{"location":"soft/#software","text":"Vamos a utilizar el lenguaje de programaci\u00f3n visual por bloques denominado ArduinoBlocks. El aspecto de la plataforma al entrar lo vemos en la imagen siguiente: Portada de la plataforma ArduinoBlocks Podemos programar nuestra placa de control tipo UNO de diversas formas de las que las mas comunes son, a partir del IDE de Arduino o mediante bloques, que ser\u00e1 el m\u00e9todo que sigamos. Programar mediante el IDE requiere teclear instrucciones de c\u00f3digo mientras que con ArduinoBlocks estas instrucciones se sustituyen por bloques tipo puzzle que evitan errores de sintaxis. Evidentemente detr\u00e1s de cada bloque en realidad lo que hay son instrucciones y ArduinoBlocks nos va a permitir verlas y exportarlas. En la imagen siguiente tenemos una comparativa entre bloques de c\u00f3digo e instrucciones en el IDE. Comparativa entre bloques y c\u00f3digo Es importante entender que la programaci\u00f3n con ArduinoBlocks simplifica la iniciaci\u00f3n en el pensamiento computacional permitiendo realizar tareas complejas de una forma sencilla. Para el caso de la TdR STEAM cabe destacar que ArduinoBlocks incluye una serie de bloques espec\u00edficos que facilitan a\u00fan mas si cabe su programaci\u00f3n. ArduinoBlocks trabaja a trav\u00e9s de una plataforma online por lo que no requiere instalaci\u00f3n en nuestro sistema. No obstante, si que tenemos que instalar un peque\u00f1o programa que ser\u00e1 el encargado de conectar nuestro programa en el navegador con la placa Keyestudio UNO. Este programa basado en Python se llama Connector . Lo primero que deberemos hacer es crear una cuenta en ArduinoBlocks utilizando una direcci\u00f3n de correo electr\u00f3nico v\u00e1lida y despu\u00e9s instalar el software Connector . En los manuales de referencia disponibles en la plataforma est\u00e1n todos los detalles sobre como llevar a cabo estas tareas. La versi\u00f3n 5.1 del programa una vez iniciado la vemos en la imagen siguiente: Connector V5.1 Si no est\u00e1s muy avezado en estos temas es necesarios al menos ver los siguientes v\u00eddeos sobre el tema: Bloque 1: Puesta en marcha con ArduinoBlocks Empezando con ArduinoBlocks y la programaci\u00f3n por bloques Crear una cuenta en ArduinoBlocks e iniciar un proyecto personal Configurar la conexi\u00f3n a ArduinoBlocks y detectar la placa Arduino Carga del primer programa","title":"Software"},{"location":"Miscelanea/about/","text":"Autor \u00b6 Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/about/#autor","text":"Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/lic/","text":"Licencias \u00b6 Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/lic/#licencias","text":"Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/soft/","text":"Software utilizado \u00b6 Sistema operativo: Ubuntu 22.04.1 LTS (Jammy Jellyfish) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/soft/#software-utilizado","text":"Sistema operativo: Ubuntu 22.04.1 LTS (Jammy Jellyfish) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP Programaci\u00f3n por bloques con ArduinoBlocks Programaci\u00f3n mediante el IDE de Arduino","title":"Software utilizado"},{"location":"Miscelanea/webgrafia/","text":"Webgraf\u00eda y bibliograf\u00eda \u00b6 Wikipedia Entrada KS0507 Keyestudio Smart RV Kit Enlace a la documentaci\u00f3n de referencia Entrada KS0509 Keyestudio Mega 2560 Smart Development Board de Keyestudio Manuales de ArduinoBlocks","title":"Webgrafia/Bibliograf\u00eda"},{"location":"Miscelanea/webgrafia/#webgrafia-y-bibliografia","text":"Wikipedia Entrada KS0507 Keyestudio Smart RV Kit Enlace a la documentaci\u00f3n de referencia Entrada KS0509 Keyestudio Mega 2560 Smart Development Board de Keyestudio Manuales de ArduinoBlocks","title":"Webgraf\u00eda y bibliograf\u00eda"},{"location":"Tactividades/T_DHTxx/","text":"Sensor de Temperatura y Humedad DHTxx \u00b6 Conceptos incluidos \u00b6 Estado de confort Textos DHTxx \u00b6 El DHT11 es un modelo de sensor que permite realizar la medici\u00f3n simult\u00e1nea de temperatura y humedad. Dispone de un procesador interno que es el encargado de realizar la medici\u00f3n entregando la informaci\u00f3n mediante una se\u00f1al digital. Se presenta en un encapsulado pl\u00e1stico t\u00edpico de color azul. Sus principales caracter\u00edsticas son: Rango de temperatura: 0 a 50\u00baC Precisi\u00f3n de la medida de temperatura: \u00b12\u00baC Rango de humedad: 20 a 80% Precisi\u00f3n en la medida de humedad: \u00b15%. Frecuencia de muestreo: 1 muestra por segundo (1 Hz) El DHT11 es un sensor bastante limitado que podemos usar con fines de formaci\u00f3n, pruebas, o en proyectos que realmente no requieran una medici\u00f3n precisa. Si necesitamos mayor precisi\u00f3n y rango podemos recurrir al DHT22 que es de la misma familia y lo \u00fanico que cambia es sus caracter\u00edsticas y el precio. Sus caracter\u00edsticas son: Rango de temperatura: -40 a 125\u00baC Precisi\u00f3n de la medida de temperatura: \u00b10.5\u00baC Rango de humedad: 0 a 100% Precisi\u00f3n en la medida de humedad: \u00b12 a 5% Frecuencia de muestreo: 2 muestras por segundo (2 Hz) En la imagen siguiente vemos el aspecto de ambos sensores: Aspecto DHT11 y DHT22 Estado de confort \u00b6 En la web ARQUITECTURA & ENERG\u00cdA podemos encontrar un art\u00edculo donde se nos explica con bastante profundad el tema del corfort t\u00e9rmico . Puede definirse confort t\u00e9rmico, o m\u00e1s propiamente comodidad higrot\u00e9rmica, como la ausencia de malestar t\u00e9rmico. En fisiolog\u00eda, se dice que hay confort higrot\u00e9rmico cuando no tienen que intervenir los mecanismos termorreguladores del cuerpo para una actividad sedentaria y con una indumentaria ligera. Esta situaci\u00f3n puede registrarse mediante \u00edndices que no deben ser sobrepasados para que no se pongan en funcionamiento los sistemas termorreguladores (metabolismo, sudoraci\u00f3n y otros). En la imagen siguiente vemos los valores de temperatura y humedad que delimitan las zonas de confortabilidad. Confort t\u00e9rmico en funci\u00f3n de temperatura y humedad Sobre el gr\u00e1fico vamos a delimitar zonas de temperatura y humedad para establecer su color. Por motivos de simplicidad lo vamos a hacer delimitando zonas rectangulares, pero comprobamos que no cometemos grandes errores y para nuestro prop\u00f3sito nos sirve. 1.- Zona Roja : en la imagen siguiente tenemos delimitadas las zonas: Humedad Relativa: superior al 85% e inferior al 20% Temperatura: superior a 27\u00baC e inferior a 16\u00baC Delimitaci\u00f3n color rojo zona de confort 2.- Zona Amarilla : en la imagen siguiente tenemos delimitadas las zonas: Humedad Relativa: entre el 20% y el 40% y entre el 65% y el 85% Temperatura: entre 16\u00baC y 18\u00baC y entre 24\u00baC y 27\u00baC Delimitaci\u00f3n color amarillo zona de confort 3.- Zona Verde, rojo y amarillo : en la imagen siguiente tenemos delimitadas todas las zonas, correspondiendo a la verde los siguientes datos: Humedad Relativa: entre el 40% y el 65% Temperatura: entre 18\u00baC y 24\u00baC Delimitaci\u00f3n colores zona de confort Con este enlace al archivo colores-A10.svg puedes descargarte el archivo vectorial, editarlo con Inkscape y ver como se han realizado estos gr\u00e1ficos. Bloques de texto \u00b6 Haremos un recorrido por los bloques del men\u00fa 'Texto' para ver las posibilidades que se nos presentan. Estos bloques ser\u00e1n los que usemos para mostrar informaci\u00f3n en dispositivos como la LCD, el monitor serie y otros dispositivos. Bloques del men\u00fa Texto En la imagen siguiente vemos una breve explicaci\u00f3n de estos bloques de texto. Bloques de texto descritos Respecto a los c\u00f3digos ASCII existen en la red multitud de p\u00e1ginas donde lo explican de forma muy clara.","title":"Sensor DHTxx"},{"location":"Tactividades/T_DHTxx/#sensor-de-temperatura-y-humedad-dhtxx","text":"","title":"Sensor de Temperatura y Humedad DHTxx"},{"location":"Tactividades/T_DHTxx/#conceptos-incluidos","text":"Estado de confort Textos","title":"Conceptos incluidos"},{"location":"Tactividades/T_DHTxx/#dhtxx","text":"El DHT11 es un modelo de sensor que permite realizar la medici\u00f3n simult\u00e1nea de temperatura y humedad. Dispone de un procesador interno que es el encargado de realizar la medici\u00f3n entregando la informaci\u00f3n mediante una se\u00f1al digital. Se presenta en un encapsulado pl\u00e1stico t\u00edpico de color azul. Sus principales caracter\u00edsticas son: Rango de temperatura: 0 a 50\u00baC Precisi\u00f3n de la medida de temperatura: \u00b12\u00baC Rango de humedad: 20 a 80% Precisi\u00f3n en la medida de humedad: \u00b15%. Frecuencia de muestreo: 1 muestra por segundo (1 Hz) El DHT11 es un sensor bastante limitado que podemos usar con fines de formaci\u00f3n, pruebas, o en proyectos que realmente no requieran una medici\u00f3n precisa. Si necesitamos mayor precisi\u00f3n y rango podemos recurrir al DHT22 que es de la misma familia y lo \u00fanico que cambia es sus caracter\u00edsticas y el precio. Sus caracter\u00edsticas son: Rango de temperatura: -40 a 125\u00baC Precisi\u00f3n de la medida de temperatura: \u00b10.5\u00baC Rango de humedad: 0 a 100% Precisi\u00f3n en la medida de humedad: \u00b12 a 5% Frecuencia de muestreo: 2 muestras por segundo (2 Hz) En la imagen siguiente vemos el aspecto de ambos sensores: Aspecto DHT11 y DHT22","title":"DHTxx"},{"location":"Tactividades/T_DHTxx/#estado-de-confort","text":"En la web ARQUITECTURA & ENERG\u00cdA podemos encontrar un art\u00edculo donde se nos explica con bastante profundad el tema del corfort t\u00e9rmico . Puede definirse confort t\u00e9rmico, o m\u00e1s propiamente comodidad higrot\u00e9rmica, como la ausencia de malestar t\u00e9rmico. En fisiolog\u00eda, se dice que hay confort higrot\u00e9rmico cuando no tienen que intervenir los mecanismos termorreguladores del cuerpo para una actividad sedentaria y con una indumentaria ligera. Esta situaci\u00f3n puede registrarse mediante \u00edndices que no deben ser sobrepasados para que no se pongan en funcionamiento los sistemas termorreguladores (metabolismo, sudoraci\u00f3n y otros). En la imagen siguiente vemos los valores de temperatura y humedad que delimitan las zonas de confortabilidad. Confort t\u00e9rmico en funci\u00f3n de temperatura y humedad Sobre el gr\u00e1fico vamos a delimitar zonas de temperatura y humedad para establecer su color. Por motivos de simplicidad lo vamos a hacer delimitando zonas rectangulares, pero comprobamos que no cometemos grandes errores y para nuestro prop\u00f3sito nos sirve. 1.- Zona Roja : en la imagen siguiente tenemos delimitadas las zonas: Humedad Relativa: superior al 85% e inferior al 20% Temperatura: superior a 27\u00baC e inferior a 16\u00baC Delimitaci\u00f3n color rojo zona de confort 2.- Zona Amarilla : en la imagen siguiente tenemos delimitadas las zonas: Humedad Relativa: entre el 20% y el 40% y entre el 65% y el 85% Temperatura: entre 16\u00baC y 18\u00baC y entre 24\u00baC y 27\u00baC Delimitaci\u00f3n color amarillo zona de confort 3.- Zona Verde, rojo y amarillo : en la imagen siguiente tenemos delimitadas todas las zonas, correspondiendo a la verde los siguientes datos: Humedad Relativa: entre el 40% y el 65% Temperatura: entre 18\u00baC y 24\u00baC Delimitaci\u00f3n colores zona de confort Con este enlace al archivo colores-A10.svg puedes descargarte el archivo vectorial, editarlo con Inkscape y ver como se han realizado estos gr\u00e1ficos.","title":"Estado de confort"},{"location":"Tactividades/T_DHTxx/#bloques-de-texto","text":"Haremos un recorrido por los bloques del men\u00fa 'Texto' para ver las posibilidades que se nos presentan. Estos bloques ser\u00e1n los que usemos para mostrar informaci\u00f3n en dispositivos como la LCD, el monitor serie y otros dispositivos. Bloques del men\u00fa Texto En la imagen siguiente vemos una breve explicaci\u00f3n de estos bloques de texto. Bloques de texto descritos Respecto a los c\u00f3digos ASCII existen en la red multitud de p\u00e1ginas donde lo explican de forma muy clara.","title":"Bloques de texto"},{"location":"Tactividades/T_LCD/","text":"Puerto de expansi\u00f3n I2C. La LCD de 2x16 \u00b6 Conceptos incluidos \u00b6 Las comunicaciones I2C El bus I2C \u00b6 Las siglas I2C corresponden en realidad a I\u00b2C que tiene su origen en las iniciales del ingl\u00e9s Inter-Integrated Circuit (IIC = I\u00b2C) y que siginifican Circuito Inter-Integrado) y vamos a explicar un poco en que consiste este sistema de conexionado. El bus conocido por las siglas I2C, IIC o I\u00b2C, es un bus serie de datos desarrollado en 1982 por Philips Semiconductors (hoy NXP Semiconductors, parte de Qualcomm). Se utiliza principalmente internamente para la comunicaci\u00f3n entre diferentes partes de un circuito, por ejemplo, entre un controlador y circuitos perif\u00e9ricos integrados. Posteriormente fue adoptado progresivamente por otros fabricantes hasta convertirse en un est\u00e1ndar del mercado con miles de circuitos integrados de diferentes fabricantes. I2C tambi\u00e9n se denomina TWI (Two Wired Interface) \u00fanicamente por motivos de licencia, denominaci\u00f3n introducida por Atmel. No obstante, la patente caduc\u00f3 en 2006, por lo que actualmente no hay restricci\u00f3n sobre el uso del t\u00e9rmino I2C. El bus I2C requiere \u00fanicamente dos cables o lineas de se\u00f1al para su funcionamiento, uno para la se\u00f1al de reloj (SCL, Serial Clock) y otro para el env\u00edo de datos (SDA, Serial Data). Ambas l\u00edneas precisan resistencias de pull-up hacia Vcc. Cualquier dispositivo conectado a estas l\u00edneas es de drenador o colector abierto (Open Collector), lo cual en combinaci\u00f3n con las resistencias pull-up, crea un circuito Wired-AND. En la imagen siguiente vemos el diagrama b\u00e1sico de conexionado del bus con algunos ejemplos de dispositivos. La se\u00f1al de reloj siempre es generada por el circuito que act\u00faa como Master. Diagrama de conexi\u00f3n del bus I2C Para ser reconocido en el bus, cada dispositivo dispone de una direcci\u00f3n f\u00edsica, que se emplea para acceder a cada uno de ellos de forma individual. Esta direcci\u00f3n puede ser fijada por hardware, en cuyo caso se pueden modificar los \u00faltimos 3 bits mediante \u201cjumpers\u201d o microinterruptores (ejemplo de la matriz de 8x8), o por software. En general, cada dispositivo conectado al bus debe tener una direcci\u00f3n \u00fanica. Si tenemos varios dispositivos similares tendremos que cambiar la direcci\u00f3n o, en caso de no ser posible, implementar un bus secundario. El bus I2C tiene una arquitectura de tipo master-slave, lo que indica que el master es el encargado de controlar al resto de dispositivos tipo slave con los que se comunica y que se comunican con el, teniendo siempre el master prioridad absoluta. El dispositivo master es el que inicia la comunicaci\u00f3n con los slaves. Los slaves no pueden iniciar la comunicaci\u00f3n (el master tiene que preguntarles), ni hablar entre si directamente. El bus I2C debe ser por lo tanto s\u00edncrono, es decir debe existir una se\u00f1al de reloj que controle las comunicaciones. Es el master el que proporciona la se\u00f1al de reloj, que mantiene sincronizados a todos los dispositivos del bus. De esta forma, se elimina la necesidad de que cada dispositivo tenga su propio reloj, de tener que acordar una velocidad de transmisi\u00f3n y mecanismos para mantener la transmisi\u00f3n sincronizada como en UART o SPI. En la imagen vemos un cronograma ejemplo del funcionamiento del sistema. Cronograma trabajo bus I2C El protocolo de comunicaci\u00f3n I2C sigue la siguiente secuencia: Primero, el master genera la se\u00f1al de reloj del bus (SCL). Se inicia la comunicaci\u00f3n por orden del master al establecer la condici\u00f3n de START, que se produce cuando SDA pasa de uno a cero y se mantiene en cero durante un tiempo. El master direcciona a los slaves. El master indica si se va a leer o escribir. El slave direccionado responde con una se\u00f1al de conformidad ACK (acknowledge). Se transmite los datos byte a byte desde SDA al receptor. Por cada pulso desde SCL se transmite un bit de informaci\u00f3n. El destinatario de la informaci\u00f3n responde con una se\u00f1al de conformidad ACK. Se acaba la comunicaci\u00f3n cuando el master establece la condici\u00f3n de STOP, que se produce cuando SDA, por orden del master pasa de cero a uno y se mantiene en uno durante un tiempo. Son muchos los dispositivos I2C que se pueden direccionar por este bus I2C, siendo lo m\u00e1s com\u00fan en los dispositivos para I2C que utilicen direcciones de 7 bits, aunque existen dispositivos de 10 bits, pero es un caso raro. Una direcci\u00f3n de 7 bits implica que se pueden poner hasta 128 (27) dispositivos sobre un bus I2C. Hemos visto que las direcciones son de 8 bits y esto es porque el bit extra de los 7 de la direcci\u00f3n lo emplea el master para informar al slave si va a leer o escribir. Si el bit de lectura/escritura es cero, el dispositivo master est\u00e1 escribiendo en el slave. Si el bit es 1 el master est\u00e1 leyendo desde el slave. La direcci\u00f3n de 7 bit se coloca en los 7 bits m\u00e1s significativos del byte y el bit de lectura/escritura es el bit menos significativo. La LCD 1602 \u00b6 Una pantalla LCD (del ing\u00e9s, Liquid Cristal Display) de 2 l\u00edneas de 16 caracteres tiene el aspecto y la distribuci\u00f3n de pines que vemos en la imagen siguiente. LCD 2x16 Es evidente que deber\u00edamos utilizar bastantes patillas de nuestra placa para su control. En la imagen siguiente se muestra el conexionado m\u00ednimo necesario en una pantalla de este tipo para una placa tipo UNO: 4 bits para datos y dos se\u00f1ales de control En (Enable) y Rs (Register select). La conexi\u00f3n RW la ponemos a GND. Adem\u00e1s se debe a\u00f1adir una resistencia ajustable o un potenci\u00f3metro para regular el contraste de la pantalla. Conexionado m\u00ednimo LCD 2x16 Es preferible utilizar alguna de las que tienen el aspecto que vemos en la imagen siguiente: LCD 2x16 con m\u00f3dulo I2C En realidad el conjunto que vemos en la imagen anterior no es mas que una LCD 2x16 a la que se ha incorporado un m\u00f3dulo adaptador de LCD a I2C. Este modulo est\u00e1 especialmente dise\u00f1ado para poder soldarlo directamente a la LCD y convertirla as\u00ed en un dispositivo I2C que adem\u00e1s ya lleva incorporado el potenci\u00f3metro de ajuste de contraste en alguno de los casos. Este tipo de pantalla requiere cuatro cables para establecer las conexiones, dos cables SDA (datos) y SCL (reloj) para el bus de comunicaciones I2C y los dos cables de alimentaci\u00f3n VCC y GND. La direcci\u00f3n I2C por defecto de este tipo de m\u00f3dulos puede ser 0x3F o en otros casos 0x27, e incluso hay modelos en los que se puede cambiar. Para un correcto control es muy importante identificar correctamente la direcci\u00f3n I2C de nuestro modulo pues de otra forma nuestro programa no funcionar\u00e1 correctamente. Una LCD 1602 I2C es muy sencilla de controlar a partir de los bloques que nos proporciona ArduinoBlocks. En la imagen siguiente ponemos como ejemplo los bloques para imprimir un texto o variable en un par fila-columna determinado. Bloques para imprimir en un par fila-columna En la siguiente figura se muestra el sistema de distribuci\u00f3n de filas y columnas. Sistema de coordenadas en una LCD 1602 Escanear dispositivos I2C \u00b6 Si no conocemos la direcci\u00f3n especifica de nuestro m\u00f3dulo podemos utilizar un peque\u00f1o programa que llamaremos Escaner-I2C y que se encargar\u00e1 de identificar la direcci\u00f3n I2C y todos los dispositivos I2C conectados a nuestra placa. El bloque \"Escanear dispositivos I2C...\" est\u00e1 disponible en el men\u00fa I2C tal y como vemos en la imagen siguiente: Menu I2C Un sencillo programa como el de la imagen siguiente nos permite ver los dispositivos I2C conectados y su direcci\u00f3n f\u00edsica asociada. El programa est\u00e1 disponible como Escaner-I2C . Programa Escaner-I2C Si conectamos la consola el resultado de tener la autocaravana con una LCD I2C conectada debe ser similar al de la imagen siguiente: Consola para el programa Escaner-I2C En la figura siguiente tenemos el resultado que se muestra con el programa anterior cargado, conectar la consola y hacer reset. En este caso vemos los cinco dispositivos conectados a trav\u00e9s de un hub. Consola para el programa Escaner-I2C con 5 dispositivos Otra opci\u00f3n para hacer un esc\u00e1ner I2C que no necesita el reset es el programa que vemos en la figura siguiente y que lleva al bucle la orden de escaneo que se va a ejecutar cada 10 segundos, aunque este tiempo puede ser otro cualquiera. Programa Escaner-I2C en el bucle con 5 dispositivos En la figura siguiente vemos el resultado en la consola y como coincide con el anterior. Consola para el programa Escaner-I2C en el bucle con 5 dispositivos Cambiar la direcci\u00f3n f\u00edsica del dispositivo I2C \u00b6 Esta tarea nos va a resultar especialmente \u00fatil si disponemos de LCDs I2C con una direcci\u00f3n fijada de f\u00e1brica y queremos conectar varias de ellas en nuestro proyecto. LCD SIN micro interruptores La parte posterior de la LCD 1602 de Keyestudio tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en los tres grupos de agujeros enmarcados en rojo. Aunque en este caso no vienen nombrados los vamos a denominar A0, A1 y A2 de izquierda a derecha. Pads configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C La direcci\u00f3n por defecto de f\u00e1brica en este caso es la 0x27, pero se puede cambiar alterando la situaci\u00f3n de conexionado de estos agujeros entre si seg\u00fan la tabla siguiente: A2 A1 A0 Direcci\u00f3n 0 0 0 0x27 0 0 1 0x26 0 1 0 0x25 0 1 1 0x24 1 0 0 0x23 1 0 1 0x22 1 1 0 0x21 1 1 1 0x20 Para establecer los unos de la tabla anterior basta con cortocircuitar los dos pads correspondientes. En la imagen siguiente se ha establecido la direcci\u00f3n f\u00edsica como 0x26. Direcci\u00f3n 0x26 LCD CON micro interruptores La parte posterior de la LCD 1602 de Keyestudio con micro interruptores para cambiar su direcci\u00f3n f\u00edsica tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en el recuadro azul donde est\u00e1n los microinterruptores que permiten cambiar el estado del bit y encima de los mismo est\u00e1 la informaci\u00f3n de la direcci\u00f3n f\u00edsica que se asigna a cada combinaci\u00f3n. La tabla es exactamente la misma que en el caso anterior. Configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C con microinterruptores Definici\u00f3n de s\u00edmbolos en la LCD \u00b6 Dentro de los bloques del men\u00fa Visualizaci\u00f3n -> Pantalla LCD est\u00e1 el de \"definir s\u00edmbolo\", que permite definir uno de los 8 s\u00edmbolos personalizables que puede almacenar el micro de la pantalla LCD. El s\u00edmbolo se define por un mapa de bits (unos y ceros indicando cada p\u00edxel del s\u00edmbolo). Los s\u00edmbolos tienen una resoluci\u00f3n de 5x8 p\u00edxeles (blanco o negro). En ArduinoBlocks disponemos de una herramienta que nos ayuda a definir nuestros propios s\u00edmbolos y podemos acceder a ella desde herramientas o haciendo clic derecho sobre el bloque, despleg\u00e1ndose en cualquier caso un editor muy sencillo de usar y que vemos con un ejemplo en la imagen en la siguiente: Ejemplo de s\u00edmbolo creado con el editor Para tener el s\u00edmbolo disponible simplemente copiamos la cadena generada en el lugar correspondiente del bloque que vemos en la imagen siguiente. Bloque para la definici\u00f3n de s\u00edmbolos","title":"Pantalla LCD I2C"},{"location":"Tactividades/T_LCD/#puerto-de-expansion-i2c-la-lcd-de-2x16","text":"","title":"Puerto de expansi\u00f3n I2C. La LCD de 2x16"},{"location":"Tactividades/T_LCD/#conceptos-incluidos","text":"Las comunicaciones I2C","title":"Conceptos incluidos"},{"location":"Tactividades/T_LCD/#el-bus-i2c","text":"Las siglas I2C corresponden en realidad a I\u00b2C que tiene su origen en las iniciales del ingl\u00e9s Inter-Integrated Circuit (IIC = I\u00b2C) y que siginifican Circuito Inter-Integrado) y vamos a explicar un poco en que consiste este sistema de conexionado. El bus conocido por las siglas I2C, IIC o I\u00b2C, es un bus serie de datos desarrollado en 1982 por Philips Semiconductors (hoy NXP Semiconductors, parte de Qualcomm). Se utiliza principalmente internamente para la comunicaci\u00f3n entre diferentes partes de un circuito, por ejemplo, entre un controlador y circuitos perif\u00e9ricos integrados. Posteriormente fue adoptado progresivamente por otros fabricantes hasta convertirse en un est\u00e1ndar del mercado con miles de circuitos integrados de diferentes fabricantes. I2C tambi\u00e9n se denomina TWI (Two Wired Interface) \u00fanicamente por motivos de licencia, denominaci\u00f3n introducida por Atmel. No obstante, la patente caduc\u00f3 en 2006, por lo que actualmente no hay restricci\u00f3n sobre el uso del t\u00e9rmino I2C. El bus I2C requiere \u00fanicamente dos cables o lineas de se\u00f1al para su funcionamiento, uno para la se\u00f1al de reloj (SCL, Serial Clock) y otro para el env\u00edo de datos (SDA, Serial Data). Ambas l\u00edneas precisan resistencias de pull-up hacia Vcc. Cualquier dispositivo conectado a estas l\u00edneas es de drenador o colector abierto (Open Collector), lo cual en combinaci\u00f3n con las resistencias pull-up, crea un circuito Wired-AND. En la imagen siguiente vemos el diagrama b\u00e1sico de conexionado del bus con algunos ejemplos de dispositivos. La se\u00f1al de reloj siempre es generada por el circuito que act\u00faa como Master. Diagrama de conexi\u00f3n del bus I2C Para ser reconocido en el bus, cada dispositivo dispone de una direcci\u00f3n f\u00edsica, que se emplea para acceder a cada uno de ellos de forma individual. Esta direcci\u00f3n puede ser fijada por hardware, en cuyo caso se pueden modificar los \u00faltimos 3 bits mediante \u201cjumpers\u201d o microinterruptores (ejemplo de la matriz de 8x8), o por software. En general, cada dispositivo conectado al bus debe tener una direcci\u00f3n \u00fanica. Si tenemos varios dispositivos similares tendremos que cambiar la direcci\u00f3n o, en caso de no ser posible, implementar un bus secundario. El bus I2C tiene una arquitectura de tipo master-slave, lo que indica que el master es el encargado de controlar al resto de dispositivos tipo slave con los que se comunica y que se comunican con el, teniendo siempre el master prioridad absoluta. El dispositivo master es el que inicia la comunicaci\u00f3n con los slaves. Los slaves no pueden iniciar la comunicaci\u00f3n (el master tiene que preguntarles), ni hablar entre si directamente. El bus I2C debe ser por lo tanto s\u00edncrono, es decir debe existir una se\u00f1al de reloj que controle las comunicaciones. Es el master el que proporciona la se\u00f1al de reloj, que mantiene sincronizados a todos los dispositivos del bus. De esta forma, se elimina la necesidad de que cada dispositivo tenga su propio reloj, de tener que acordar una velocidad de transmisi\u00f3n y mecanismos para mantener la transmisi\u00f3n sincronizada como en UART o SPI. En la imagen vemos un cronograma ejemplo del funcionamiento del sistema. Cronograma trabajo bus I2C El protocolo de comunicaci\u00f3n I2C sigue la siguiente secuencia: Primero, el master genera la se\u00f1al de reloj del bus (SCL). Se inicia la comunicaci\u00f3n por orden del master al establecer la condici\u00f3n de START, que se produce cuando SDA pasa de uno a cero y se mantiene en cero durante un tiempo. El master direcciona a los slaves. El master indica si se va a leer o escribir. El slave direccionado responde con una se\u00f1al de conformidad ACK (acknowledge). Se transmite los datos byte a byte desde SDA al receptor. Por cada pulso desde SCL se transmite un bit de informaci\u00f3n. El destinatario de la informaci\u00f3n responde con una se\u00f1al de conformidad ACK. Se acaba la comunicaci\u00f3n cuando el master establece la condici\u00f3n de STOP, que se produce cuando SDA, por orden del master pasa de cero a uno y se mantiene en uno durante un tiempo. Son muchos los dispositivos I2C que se pueden direccionar por este bus I2C, siendo lo m\u00e1s com\u00fan en los dispositivos para I2C que utilicen direcciones de 7 bits, aunque existen dispositivos de 10 bits, pero es un caso raro. Una direcci\u00f3n de 7 bits implica que se pueden poner hasta 128 (27) dispositivos sobre un bus I2C. Hemos visto que las direcciones son de 8 bits y esto es porque el bit extra de los 7 de la direcci\u00f3n lo emplea el master para informar al slave si va a leer o escribir. Si el bit de lectura/escritura es cero, el dispositivo master est\u00e1 escribiendo en el slave. Si el bit es 1 el master est\u00e1 leyendo desde el slave. La direcci\u00f3n de 7 bit se coloca en los 7 bits m\u00e1s significativos del byte y el bit de lectura/escritura es el bit menos significativo.","title":"El bus I2C"},{"location":"Tactividades/T_LCD/#la-lcd-1602","text":"Una pantalla LCD (del ing\u00e9s, Liquid Cristal Display) de 2 l\u00edneas de 16 caracteres tiene el aspecto y la distribuci\u00f3n de pines que vemos en la imagen siguiente. LCD 2x16 Es evidente que deber\u00edamos utilizar bastantes patillas de nuestra placa para su control. En la imagen siguiente se muestra el conexionado m\u00ednimo necesario en una pantalla de este tipo para una placa tipo UNO: 4 bits para datos y dos se\u00f1ales de control En (Enable) y Rs (Register select). La conexi\u00f3n RW la ponemos a GND. Adem\u00e1s se debe a\u00f1adir una resistencia ajustable o un potenci\u00f3metro para regular el contraste de la pantalla. Conexionado m\u00ednimo LCD 2x16 Es preferible utilizar alguna de las que tienen el aspecto que vemos en la imagen siguiente: LCD 2x16 con m\u00f3dulo I2C En realidad el conjunto que vemos en la imagen anterior no es mas que una LCD 2x16 a la que se ha incorporado un m\u00f3dulo adaptador de LCD a I2C. Este modulo est\u00e1 especialmente dise\u00f1ado para poder soldarlo directamente a la LCD y convertirla as\u00ed en un dispositivo I2C que adem\u00e1s ya lleva incorporado el potenci\u00f3metro de ajuste de contraste en alguno de los casos. Este tipo de pantalla requiere cuatro cables para establecer las conexiones, dos cables SDA (datos) y SCL (reloj) para el bus de comunicaciones I2C y los dos cables de alimentaci\u00f3n VCC y GND. La direcci\u00f3n I2C por defecto de este tipo de m\u00f3dulos puede ser 0x3F o en otros casos 0x27, e incluso hay modelos en los que se puede cambiar. Para un correcto control es muy importante identificar correctamente la direcci\u00f3n I2C de nuestro modulo pues de otra forma nuestro programa no funcionar\u00e1 correctamente. Una LCD 1602 I2C es muy sencilla de controlar a partir de los bloques que nos proporciona ArduinoBlocks. En la imagen siguiente ponemos como ejemplo los bloques para imprimir un texto o variable en un par fila-columna determinado. Bloques para imprimir en un par fila-columna En la siguiente figura se muestra el sistema de distribuci\u00f3n de filas y columnas. Sistema de coordenadas en una LCD 1602","title":"La LCD 1602"},{"location":"Tactividades/T_LCD/#escanear-dispositivos-i2c","text":"Si no conocemos la direcci\u00f3n especifica de nuestro m\u00f3dulo podemos utilizar un peque\u00f1o programa que llamaremos Escaner-I2C y que se encargar\u00e1 de identificar la direcci\u00f3n I2C y todos los dispositivos I2C conectados a nuestra placa. El bloque \"Escanear dispositivos I2C...\" est\u00e1 disponible en el men\u00fa I2C tal y como vemos en la imagen siguiente: Menu I2C Un sencillo programa como el de la imagen siguiente nos permite ver los dispositivos I2C conectados y su direcci\u00f3n f\u00edsica asociada. El programa est\u00e1 disponible como Escaner-I2C . Programa Escaner-I2C Si conectamos la consola el resultado de tener la autocaravana con una LCD I2C conectada debe ser similar al de la imagen siguiente: Consola para el programa Escaner-I2C En la figura siguiente tenemos el resultado que se muestra con el programa anterior cargado, conectar la consola y hacer reset. En este caso vemos los cinco dispositivos conectados a trav\u00e9s de un hub. Consola para el programa Escaner-I2C con 5 dispositivos Otra opci\u00f3n para hacer un esc\u00e1ner I2C que no necesita el reset es el programa que vemos en la figura siguiente y que lleva al bucle la orden de escaneo que se va a ejecutar cada 10 segundos, aunque este tiempo puede ser otro cualquiera. Programa Escaner-I2C en el bucle con 5 dispositivos En la figura siguiente vemos el resultado en la consola y como coincide con el anterior. Consola para el programa Escaner-I2C en el bucle con 5 dispositivos","title":"Escanear dispositivos I2C"},{"location":"Tactividades/T_LCD/#cambiar-la-direccion-fisica-del-dispositivo-i2c","text":"Esta tarea nos va a resultar especialmente \u00fatil si disponemos de LCDs I2C con una direcci\u00f3n fijada de f\u00e1brica y queremos conectar varias de ellas en nuestro proyecto. LCD SIN micro interruptores La parte posterior de la LCD 1602 de Keyestudio tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en los tres grupos de agujeros enmarcados en rojo. Aunque en este caso no vienen nombrados los vamos a denominar A0, A1 y A2 de izquierda a derecha. Pads configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C La direcci\u00f3n por defecto de f\u00e1brica en este caso es la 0x27, pero se puede cambiar alterando la situaci\u00f3n de conexionado de estos agujeros entre si seg\u00fan la tabla siguiente: A2 A1 A0 Direcci\u00f3n 0 0 0 0x27 0 0 1 0x26 0 1 0 0x25 0 1 1 0x24 1 0 0 0x23 1 0 1 0x22 1 1 0 0x21 1 1 1 0x20 Para establecer los unos de la tabla anterior basta con cortocircuitar los dos pads correspondientes. En la imagen siguiente se ha establecido la direcci\u00f3n f\u00edsica como 0x26. Direcci\u00f3n 0x26 LCD CON micro interruptores La parte posterior de la LCD 1602 de Keyestudio con micro interruptores para cambiar su direcci\u00f3n f\u00edsica tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en el recuadro azul donde est\u00e1n los microinterruptores que permiten cambiar el estado del bit y encima de los mismo est\u00e1 la informaci\u00f3n de la direcci\u00f3n f\u00edsica que se asigna a cada combinaci\u00f3n. La tabla es exactamente la misma que en el caso anterior. Configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C con microinterruptores","title":"Cambiar la direcci\u00f3n f\u00edsica del dispositivo I2C"},{"location":"Tactividades/T_LCD/#definicion-de-simbolos-en-la-lcd","text":"Dentro de los bloques del men\u00fa Visualizaci\u00f3n -> Pantalla LCD est\u00e1 el de \"definir s\u00edmbolo\", que permite definir uno de los 8 s\u00edmbolos personalizables que puede almacenar el micro de la pantalla LCD. El s\u00edmbolo se define por un mapa de bits (unos y ceros indicando cada p\u00edxel del s\u00edmbolo). Los s\u00edmbolos tienen una resoluci\u00f3n de 5x8 p\u00edxeles (blanco o negro). En ArduinoBlocks disponemos de una herramienta que nos ayuda a definir nuestros propios s\u00edmbolos y podemos acceder a ella desde herramientas o haciendo clic derecho sobre el bloque, despleg\u00e1ndose en cualquier caso un editor muy sencillo de usar y que vemos con un ejemplo en la imagen en la siguiente: Ejemplo de s\u00edmbolo creado con el editor Para tener el s\u00edmbolo disponible simplemente copiamos la cadena generada en el lugar correspondiente del bloque que vemos en la imagen siguiente. Bloque para la definici\u00f3n de s\u00edmbolos","title":"Definici\u00f3n de s\u00edmbolos en la LCD"},{"location":"Tactividades/T_LED/","text":"Diodos LED \u00b6 Conceptos incluidos \u00b6 PWM Concepto de variable y de contador Bucles y contadores El diodo LED \u00b6 El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energ\u00eda Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la imagen siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico. Aspecto y s\u00edmbolo del LED El color de la c\u00e1psula es simplemente orientativo de la longitud de onda que define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible. La forma de la capsula mas habitual es cil\u00edndrica de 3 o 5 mm de di\u00e1metro, aunque existen otras formas menos usuales como las que vemos en la imagen siguiente: Tipos de encapsulados El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto. Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida. Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada. Tensi\u00f3n y corriente para distintos colores El m\u00f3dulo KS0016 Keyestudio White LED tiene el aspecto de la imagen siguiente, donde tambi\u00e9n podemos ver el esquema del circuito que se monta en el mismo. Aspecto y esquema del circuito del LED blanco PWM \u00b6 PWM son siglas en ingl\u00e9s que significan Pulse Width Modulation y que lo podemos traducir a espa\u00f1ol como Modulaci\u00f3n de ancho de pulso. Los pines PWM permiten generar una se\u00f1al anal\u00f3gica mediante una salida digital mapeada con 8 bits, o lo que es lo mismo, valores del 0 al 255, es decir mediante una salida PWM podemos emular una se\u00f1al anal\u00f3gica. En realidad una placa tipo UNO no es capaz de generar una salida anal\u00f3gica y lo que se hace es emplear un truco que consiste en activar una salida digital durante un tiempo y el resto del tiempo del ciclo mantenerla desactivada. El valor promedio de la salida es el valor anal\u00f3gico. En el tipo de modulaci\u00f3n PWM mantendremos constante la frecuencia, o lo que es lo mismo, el tiempo entre pulsos y lo que se hace es variar la anchura del pulso. La proporci\u00f3n de tiempo que est\u00e1 encendida la se\u00f1al, respecto al total del ciclo, se denomina ciclo de trabajo o Duty cycle, y generalmente se expresa en tanto por ciento. En la imagen siguiente vemos se\u00f1ales con distintos ciclos de trabajo. Distintos Duty cicle Es importante recordar que en una salida PWM el valor de la tensi\u00f3n es 5V por lo que si alimentamos un dispositivo de 3V a partir de una salida de 5V lo da\u00f1aremos de forma irreversible. Las se\u00f1ales PWM emulan una se\u00f1al anal\u00f3gica para aplicaciones como variar la luminosidad de un LED y variar la velocidad de motores de corriente continua. La placa KS0509 Keyestudio Mega 2560 dispone de quince salidas PWM (D2 - D13 y D44 - D46). Concepto de variable y de contador \u00b6 El concepto de variable en programaci\u00f3n consiste simplemente en asignarle un nombre significativo a un espacio de memoria donde almacenar determinada informaci\u00f3n durante la ejecuci\u00f3n normal del programa. El concepto es muy amplio y complejo y en nuestro caso no vamos a entrar en detalles sobre el mismo, pero si indicar que no se debe confundir con el concepto de variable matem\u00e1tica, ya que una expresi\u00f3n como x = x + 1 que es una aberraci\u00f3n en matem\u00e1ticas tiene todo el sentido en programaci\u00f3n. L\u00f3gicamente en matem\u00e1ticas no se puede cumplir pero en programaci\u00f3n significa que a la variable x se le sume uno y el resultado se vuelva a guardar en la misma variable. En ArduinoBlocks podemos crear tres tipos de variables, num\u00e9ricas, de texto o booleanas. En la animaci\u00f3n siguiente podemos ver como se pueden crear, eliminar y renombrar variables. Crear, renombrar y eliminar variables En programaci\u00f3n, llamamos contador a una variable cuyo valor se incrementa o decrementa en un valor fijo para cada iteraci\u00f3n del bucle para el que se ha definido. El uso habitual de un contador es simplemente contar el n\u00famero de veces que itera un bucle en general o de forma mas extensa contar, solamente, aquellas iteraciones en las que se cumpla una determinada condici\u00f3n. Por ejemplo, supongamos que tenemos una variable de nombre Estado de valor inicial cero y que se incremente cada vez que accionamos un pulsador, de esta forma si en un bucle vamos incrementando la variable de uno en uno, tenemos: Estado = 0 // valor inicial Estado = 1 // Estado = Estado + 1 Estado = 2 // Estado = Estado + 1 ... Concepto de variable y de contador \u00b6 Vamos a ver como se hacen los ciclos de repetici\u00f3n o bucles en ArduinoBlocks. Repetir . En el men\u00fa de Control existe el bloque 'Repetir (valor) veces hacer\u2026', como el de la imagen siguiente: Bucle repetir Lo que pongamos en hacer se va a repetir tantas veces como indiquemos en el n\u00famero de veces, que por defecto estar\u00e1 a 10. En realidad lo que estamos haciendo es lo que en programaci\u00f3n se conoce como bucle for. Repetir seg\u00fan condici\u00f3n . En la imagen siguiente vemos dos bloques que repiten su interior mientras, o hasta, que se cumpla una condici\u00f3n. Bucle repetir seg\u00fan condici\u00f3n Contador . Realiza un bucle contando con un variable \u00edndice (normalmente i o j). Se define un valor de inicio, una valor de fin y los incrementos que se realizar\u00e1n en cada iteraci\u00f3n del bucle. Dentro del bucle podremos usar esta variable \u00edndice. Bucle contador","title":"El diodo LED"},{"location":"Tactividades/T_LED/#diodos-led","text":"","title":"Diodos LED"},{"location":"Tactividades/T_LED/#conceptos-incluidos","text":"PWM Concepto de variable y de contador Bucles y contadores","title":"Conceptos incluidos"},{"location":"Tactividades/T_LED/#el-diodo-led","text":"El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energ\u00eda Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la imagen siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico. Aspecto y s\u00edmbolo del LED El color de la c\u00e1psula es simplemente orientativo de la longitud de onda que define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible. La forma de la capsula mas habitual es cil\u00edndrica de 3 o 5 mm de di\u00e1metro, aunque existen otras formas menos usuales como las que vemos en la imagen siguiente: Tipos de encapsulados El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto. Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida. Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada. Tensi\u00f3n y corriente para distintos colores El m\u00f3dulo KS0016 Keyestudio White LED tiene el aspecto de la imagen siguiente, donde tambi\u00e9n podemos ver el esquema del circuito que se monta en el mismo. Aspecto y esquema del circuito del LED blanco","title":"El diodo LED"},{"location":"Tactividades/T_LED/#pwm","text":"PWM son siglas en ingl\u00e9s que significan Pulse Width Modulation y que lo podemos traducir a espa\u00f1ol como Modulaci\u00f3n de ancho de pulso. Los pines PWM permiten generar una se\u00f1al anal\u00f3gica mediante una salida digital mapeada con 8 bits, o lo que es lo mismo, valores del 0 al 255, es decir mediante una salida PWM podemos emular una se\u00f1al anal\u00f3gica. En realidad una placa tipo UNO no es capaz de generar una salida anal\u00f3gica y lo que se hace es emplear un truco que consiste en activar una salida digital durante un tiempo y el resto del tiempo del ciclo mantenerla desactivada. El valor promedio de la salida es el valor anal\u00f3gico. En el tipo de modulaci\u00f3n PWM mantendremos constante la frecuencia, o lo que es lo mismo, el tiempo entre pulsos y lo que se hace es variar la anchura del pulso. La proporci\u00f3n de tiempo que est\u00e1 encendida la se\u00f1al, respecto al total del ciclo, se denomina ciclo de trabajo o Duty cycle, y generalmente se expresa en tanto por ciento. En la imagen siguiente vemos se\u00f1ales con distintos ciclos de trabajo. Distintos Duty cicle Es importante recordar que en una salida PWM el valor de la tensi\u00f3n es 5V por lo que si alimentamos un dispositivo de 3V a partir de una salida de 5V lo da\u00f1aremos de forma irreversible. Las se\u00f1ales PWM emulan una se\u00f1al anal\u00f3gica para aplicaciones como variar la luminosidad de un LED y variar la velocidad de motores de corriente continua. La placa KS0509 Keyestudio Mega 2560 dispone de quince salidas PWM (D2 - D13 y D44 - D46).","title":"PWM"},{"location":"Tactividades/T_LED/#concepto-de-variable-y-de-contador","text":"El concepto de variable en programaci\u00f3n consiste simplemente en asignarle un nombre significativo a un espacio de memoria donde almacenar determinada informaci\u00f3n durante la ejecuci\u00f3n normal del programa. El concepto es muy amplio y complejo y en nuestro caso no vamos a entrar en detalles sobre el mismo, pero si indicar que no se debe confundir con el concepto de variable matem\u00e1tica, ya que una expresi\u00f3n como x = x + 1 que es una aberraci\u00f3n en matem\u00e1ticas tiene todo el sentido en programaci\u00f3n. L\u00f3gicamente en matem\u00e1ticas no se puede cumplir pero en programaci\u00f3n significa que a la variable x se le sume uno y el resultado se vuelva a guardar en la misma variable. En ArduinoBlocks podemos crear tres tipos de variables, num\u00e9ricas, de texto o booleanas. En la animaci\u00f3n siguiente podemos ver como se pueden crear, eliminar y renombrar variables. Crear, renombrar y eliminar variables En programaci\u00f3n, llamamos contador a una variable cuyo valor se incrementa o decrementa en un valor fijo para cada iteraci\u00f3n del bucle para el que se ha definido. El uso habitual de un contador es simplemente contar el n\u00famero de veces que itera un bucle en general o de forma mas extensa contar, solamente, aquellas iteraciones en las que se cumpla una determinada condici\u00f3n. Por ejemplo, supongamos que tenemos una variable de nombre Estado de valor inicial cero y que se incremente cada vez que accionamos un pulsador, de esta forma si en un bucle vamos incrementando la variable de uno en uno, tenemos: Estado = 0 // valor inicial Estado = 1 // Estado = Estado + 1 Estado = 2 // Estado = Estado + 1 ...","title":"Concepto de variable y de contador"},{"location":"Tactividades/T_LED/#concepto-de-variable-y-de-contador_1","text":"Vamos a ver como se hacen los ciclos de repetici\u00f3n o bucles en ArduinoBlocks. Repetir . En el men\u00fa de Control existe el bloque 'Repetir (valor) veces hacer\u2026', como el de la imagen siguiente: Bucle repetir Lo que pongamos en hacer se va a repetir tantas veces como indiquemos en el n\u00famero de veces, que por defecto estar\u00e1 a 10. En realidad lo que estamos haciendo es lo que en programaci\u00f3n se conoce como bucle for. Repetir seg\u00fan condici\u00f3n . En la imagen siguiente vemos dos bloques que repiten su interior mientras, o hasta, que se cumpla una condici\u00f3n. Bucle repetir seg\u00fan condici\u00f3n Contador . Realiza un bucle contando con un variable \u00edndice (normalmente i o j). Se define un valor de inicio, una valor de fin y los incrementos que se realizar\u00e1n en cada iteraci\u00f3n del bucle. Dentro del bucle podremos usar esta variable \u00edndice. Bucle contador","title":"Concepto de variable y de contador"},{"location":"Tactividades/T_PIR/","text":"Sensor de movimiento PIR \u00b6 Conceptos incluidos \u00b6 Bloques de tiempo Funciones PIR \u00b6 Los detectores PIR (del ing\u00e9s Passive Infrared), se caracterizan por su reducido tama\u00f1o, bajo costo, no ser influenciados por la luz natural, tener un bajo consumo de energ\u00eda y ser de muy f\u00e1cil manejo. Reaccionan s\u00f3lo ante determinadas fuentes de energ\u00eda tales como la generada por el calor del cuerpo humano o de los animales. Basan su funcionamiento en que todos los cuerpos (especialmente los vivos) emiten una cierta cantidad de energ\u00eda infrarroja, mayor cuanto mayor es su temperatura que la capta un sensor piro el\u00e9ctrico y la convierte en una se\u00f1al el\u00e9ctrica. Los detectores PIR son dispositivos que detectan variaciones de la radiaci\u00f3n infrarroja en su \u00e1rea de cobertura, por lo que son especialmente \u00fatiles para detectar la presencia de personas o animales a trav\u00e9s del calor que emiten sus cuerpos. Aunque en el enunciado del apartado pone \"Sensor de movimiento PIR\", el concepto PIR es solamente uno de los m\u00e9todos posibles de detecci\u00f3n de movimiento, pero es el que nos ocupa y en proyectos con placas tipo Arduino es muy com\u00fan asociar ambos conceptos. Los sensores PIR son mas complicados de explicar que la mayor\u00eda de sensores (fotoc\u00e9lulas, sensores de golpe, etc) porque hay muchas variables que afectan a la entrada y salida del sensor. Para explicar de forma sencilla como trabaja el sensor nos vamos a basar en el diagrama de la figura siguiente: Explicaci\u00f3n sensor PIR El sensor PIR en s\u00ed tiene dos ranuras, cada ranura est\u00e1 hecha de un material especial que es sensible a los infrarrojos. La lente utilizada aqu\u00ed realmente no est\u00e1 haciendo mucho, por lo que vemos que las dos ranuras pueden 'ver' m\u00e1s all\u00e1 de cierta distancia (b\u00e1sicamente, la sensibilidad del sensor). Cuando el sensor est\u00e1 inactivo, ambas ranuras detectan la misma cantidad de infrarrojos, la cantidad ambiental radiada desde la habitaci\u00f3n, las paredes o el exterior. Cuando pasa un cuerpo caliente como por ejemplo una persona o un animal, primero intercepta la mitad del sensor PIR, lo que provoca un cambio diferencial positivo entre las dos mitades. Cuando el cuerpo caliente sale del \u00e1rea de detecci\u00f3n, ocurre lo contrario, por lo que el sensor genera un cambio diferencial negativo. Estos pulsos de cambio son lo que se detectan. El sensor IR en s\u00ed est\u00e1 dentro de una caja met\u00e1lica sellada herm\u00e9ticamente para mejorar la inmunidad al ruido/temperatura/humedad. Esta caja dispone de una ventana hecha de material transmisor de infrarrojos (t\u00edpicamente silicona recubierta) que protege el elemento sensor con los dos sensores equilibrados. La mayor parte de la verdadera magia ocurre con la \u00f3ptica, una lente de Fresnel que permite cambiar la amplitud, el rango y el patr\u00f3n de detecci\u00f3n muy f\u00e1cilmente. Seg\u00fan la Wikipedia es un dise\u00f1o que permite construir lentes de gran apertura y distancia focal corta con materiales ligeros y econ\u00f3micos. En la figura siguiente vemos un corte transversal de una lente de Fresnel comparada con una plano-convexa tradicional. Lentes de Fresnel y convexa En la figura siguiente vemos gr\u00e1ficamente el funcionamiento del sistema y como la lente Fresnel condensa la radiaci\u00f3n infrarroja al sensor. Funcionamiento de una lente Fresnel Explicaci\u00f3n del funcionamiento basada en en el documento de Adafruit titulado PIR Motion Sensor - Created by lady ada En la figura siguiente vemos la ventana del sensor PIR en el m\u00f3dulo que incorpora la autocaravana al que se le ha retirado la lente. Ventana del sensor PIR en el m\u00f3dulo de Keyestudio Las caracter\u00edsticas del m\u00f3dulo de keyestudio son: Tensi\u00f3n de alimentaci\u00f3n: de 3.3 a 5V DC Consumo 15 uA Temperatura de trabajo: de -20 a 85 \u00baC Salidas: 3V = nivel alto y 0V = nivel bajo Tiempo de retardo en la salida para el nivel alto: 2.3 a 3 segundos \u00c1ngulo de detecci\u00f3n: 100\u00ba Distancia de detecci\u00f3n: 3 a 4 metros LED indicador: Si la salida est\u00e1 en nivel alto el LED se enciende. Corriente l\u00edmite por el pin de se\u00f1al: 100 mA Algunas aclaraciones que nos hace el fabricante: La distancia m\u00e1xima es de 3-4 metros. Antes de probar la primera vez quitamos la lente blanca, se puede ver la ventana de detecci\u00f3n rectangular. Cuando el lado mayor del rect\u00e1ngulo es paralelo al suelo, la distancia de detecci\u00f3n es la mejor. Para comenzar a probar el sensor debe cubrirse con la lente blanca; de lo contrario, afectar\u00e1 a la distancia. La distancia de detecci\u00f3n \u00f3ptima se da a 25 \u2103 y se acorta cuando supera los 30 \u2103. Cuando carguemos nuestro c\u00f3digo debemos esperar de 5 a 10 segundos para que el m\u00f3dulo sea sensible y luego comenzar a probar. Bloques de tiempo \u00b6 Aunque ya los hemos utilizado en este momento vamos a explicar los bloques de tiempo que se implementan en ArduinoBlocks. Las funciones de tiempo o retardo nos permiten realizar pausas y obtener informaci\u00f3n sobre el tiempo transcurrido dentro del microcontrolador. 1.- Bloques esperar . Realizan una pausa del tiempo que establezcamos hasta seguir con la ejecuci\u00f3n del siguiente bloque. Se corresponden con las instrucciones delay(1000) y delayMicroseconds(1000) . Tenemos disponibles los dos de la imagen siguiente: Bloques esperar Debemos tener siempre muy presente que estos bloques detienen la ejecuci\u00f3n del programa y dejan al microcontrolador bloqueado haci\u00e9ndole pensar que est\u00e1 haciendo algo \u00fatil, cuando en realidad no es as\u00ed porque durante el tiempo que dura el bloqueo ni se env\u00edan ni se reciben \u00f3rdenes. Por esto hay que tener cuidado al utilizarlo aunque nos resulte muy f\u00e1cil y c\u00f3modo. Ya hemos visto alternativas como la multitarea, donde si los utilizamos, el sistema multitarea querr\u00e1 asignarle tiempo de procesamiento a la tarea, aunque sea para eso, \u00a1para no hacer nada! 2.- Tiempo transcurrido . Obtiene un valor con el tiempo transcurrido desde el inicio o reset del microcontrolador de la placa. Se trata de las funciones millis() y micros(). El valor puede ser en milisegundos o microsegundos, tal y como vemos en la imagen siguiente: Bloques tiempo transcurrido En la imagen siguiente tenemos un ejemplo de uso sacado del manual del programa : Ejecutar la Tarea1 cada 3 segundos y la Tarea2 cada 7 segundos sin bloquear la ejecuci\u00f3n del programa : Ejemplo de uso del bloque tiempo transcurrido 3.- Esperar por siempre . Bloquea indefinidamente la ejecuci\u00f3n finalizando por tanto el programa. Vemos el bloque en la imagen siguiente: Bloque esperar por siempre 4.- Ejecutar cada . Es un bloque que NO bloquea la ejecuci\u00f3n del programa y que implementa autom\u00e1ticamente la funci\u00f3n millis(). En la imagen siguiente vemos su aspecto: Bloque ejecutar cada Este bloque es equivalente a establecer la variable diferencia a 1000ms en el ejemplo visto sobre tiempo transcurrido . Cuando necesitemos realizar distintas tareas peri\u00f3dicas y que parezca que se ejecuten paralelamente sin bloquearse unas a otras utilizaremos este tipo de bloque \u201cejecutar cada\u201d. El tiempo que pongamos en cada tarea 'Ejecutar cada' determina la precisi\u00f3n de la ejecuci\u00f3n de tareas, de forma que si una tarea 'tarda' mucho bloquear\u00e1 y 'retrasar\u00e1' al resto. Para un funcionamiento correcto debemos aseguarnos de que: Cada tarea se ejecuta en el menor tiempo posible No usar nunca bloques de tipo esperar dentro de las tareas. No implmentar bucles que puedan quedarse en ejecuci\u00f3n por tiempo indefinido. En la figura siguiente vemos dos ejemplos comentados de lo que no debemos hacer. Dos errores comunes en el uso del bloque ejecutar cada Hay dispositivos, y por tanto bloques, que no admiten utilizar las esperas siendo obligado evitar los bloques 'esperar'. A continuaci\u00f3n vemos cuales son estos bloques incompatibles con bloqueos de tiempo en ArduinoBlocks. Bloques GPS . Estos necesitan leer peri\u00f3dicamente los datos desde el m\u00f3dulo para obtener la informaci\u00f3n actualizada. Si utilizamos bloqueos en nuestro programa los datos GPS no ser\u00e1n v\u00e1lidos. Bloques MQTT . Estos gestionan la comunicaci\u00f3n a trav\u00e9s de la red Ethernet (TCP/IP) de forma continua en segundo plano, si bloqueamos la ejecuci\u00f3n del programa no se realizar\u00e1 correctamente la comunicaci\u00f3n. Por lo tanto en estos casos hay seguir siempre un m\u00e9todo de programaci\u00f3n por tareas utilizando bloques del tipo \u201cejecutar cada\u201d. 5.- Cron\u00f3metro . Es un bloque que permite obtener el tiempo transcurrido en milisegundos o en segundos a partir de la funci\u00f3n millis(), y es f\u00e1cilmente puesto a 0 con el bloque reiniciar cronometro. En la figura siguiente vemos los dos bloques mencionados. Bloques para utilizar el cron\u00f3metro 6.- Dormir . Este bloque nos permite poner la placa de control tipo Arduino en modo bajo consumo durante unos milisegundos. Se trata de poner en modo sleep o hibernaci\u00f3n para reducir el consumo al m\u00ednimo mientras no estamos haciendo nada. En el caso de ArduinoBlocks se utiliza la librer\u00eda snooze. Funciones \u00b6 Una funci\u00f3n permite crear un grupo de bloques de c\u00f3digo que realizan una determinada tarea y que se repite a lo largo del programa principal en varias ocasiones. Con la creaci\u00f3n de una funci\u00f3n evitamos repetir todos esos bloques y simplemente tendremos que invocar a la funci\u00f3n. Es muy conveniente que los nombre que usemos sean lo mas descriptivos posibles de lo que hace la funci\u00f3n. Existen dos tipos de funciones: las que no retornan un valor y las que si lo hacen. En la imagen siguiente vemos los bloques correspondientes a las mismas: Bloques para crear funciones en ArduinoBlocks Cuando creamos funciones autom\u00e1ticamente se crea el bloque con su nombre que permite invocarla, tal y como vemos en la imagen siguiente: Bloques para llamada a funciones Tambi\u00e9n es posible crear funciones a las que se le env\u00edan datos o par\u00e1metros haciendo uso del signo + que aparece en los bloques. En la imagen siguiente vemos como le hemos a\u00f1adido un par de par\u00e1metros a cada tipo de funci\u00f3n y como se han modificado sus respectivos bloques de invocaci\u00f3n. Bloques para llamada a funciones con par\u00e1metros Un ejemplo t\u00edpico descriptivo del funcionamiento de las funciones es el de calculo del \u00e1rea de un tri\u00e1ngulo. Para ello definimos la funci\u00f3n que realiza el c\u00e1lculo, le pasamos dos par\u00e1metros, la base y la altura, realizamos los c\u00e1lculos pitag\u00f3ricos y nos devuelve el \u00e1rea del tri\u00e1ngulo para esos datos. En la imagen siguiente tenemos la idea de resoluci\u00f3n con la funci\u00f3n creada y el bloque para llamarla. Ejemplo de calculo del \u00e1rea de un tri\u00e1ngulo En las im\u00e1genes siguiente vemos como se han creado diferentes funciones y la forma de llamarlas. En concreto se corresponden con la base del programa de Educacont para configurar y grabar en la correspondiente estaci\u00f3n. La primera funci\u00f3n es \"leer sensores\" y la vemos en la imagen siguiente: Funci\u00f3n leer sensores de Educacont En la imagen siguiente podemos ver la funci\u00f3n encargada de subir los datos le\u00eddos a la nube. Funci\u00f3n subir datos a la nube de Educacont La siguiente funci\u00f3n permite detener las mediciones durante 15 minutos. Funci\u00f3n detener medici\u00f3n nn minutos de Educacont El bucle principal tiene la configuraci\u00f3n que vemos en la imagen siguiente: Llamada a las funciones definidas","title":"Sensor de movimiento PIR"},{"location":"Tactividades/T_PIR/#sensor-de-movimiento-pir","text":"","title":"Sensor de movimiento PIR"},{"location":"Tactividades/T_PIR/#conceptos-incluidos","text":"Bloques de tiempo Funciones","title":"Conceptos incluidos"},{"location":"Tactividades/T_PIR/#pir","text":"Los detectores PIR (del ing\u00e9s Passive Infrared), se caracterizan por su reducido tama\u00f1o, bajo costo, no ser influenciados por la luz natural, tener un bajo consumo de energ\u00eda y ser de muy f\u00e1cil manejo. Reaccionan s\u00f3lo ante determinadas fuentes de energ\u00eda tales como la generada por el calor del cuerpo humano o de los animales. Basan su funcionamiento en que todos los cuerpos (especialmente los vivos) emiten una cierta cantidad de energ\u00eda infrarroja, mayor cuanto mayor es su temperatura que la capta un sensor piro el\u00e9ctrico y la convierte en una se\u00f1al el\u00e9ctrica. Los detectores PIR son dispositivos que detectan variaciones de la radiaci\u00f3n infrarroja en su \u00e1rea de cobertura, por lo que son especialmente \u00fatiles para detectar la presencia de personas o animales a trav\u00e9s del calor que emiten sus cuerpos. Aunque en el enunciado del apartado pone \"Sensor de movimiento PIR\", el concepto PIR es solamente uno de los m\u00e9todos posibles de detecci\u00f3n de movimiento, pero es el que nos ocupa y en proyectos con placas tipo Arduino es muy com\u00fan asociar ambos conceptos. Los sensores PIR son mas complicados de explicar que la mayor\u00eda de sensores (fotoc\u00e9lulas, sensores de golpe, etc) porque hay muchas variables que afectan a la entrada y salida del sensor. Para explicar de forma sencilla como trabaja el sensor nos vamos a basar en el diagrama de la figura siguiente: Explicaci\u00f3n sensor PIR El sensor PIR en s\u00ed tiene dos ranuras, cada ranura est\u00e1 hecha de un material especial que es sensible a los infrarrojos. La lente utilizada aqu\u00ed realmente no est\u00e1 haciendo mucho, por lo que vemos que las dos ranuras pueden 'ver' m\u00e1s all\u00e1 de cierta distancia (b\u00e1sicamente, la sensibilidad del sensor). Cuando el sensor est\u00e1 inactivo, ambas ranuras detectan la misma cantidad de infrarrojos, la cantidad ambiental radiada desde la habitaci\u00f3n, las paredes o el exterior. Cuando pasa un cuerpo caliente como por ejemplo una persona o un animal, primero intercepta la mitad del sensor PIR, lo que provoca un cambio diferencial positivo entre las dos mitades. Cuando el cuerpo caliente sale del \u00e1rea de detecci\u00f3n, ocurre lo contrario, por lo que el sensor genera un cambio diferencial negativo. Estos pulsos de cambio son lo que se detectan. El sensor IR en s\u00ed est\u00e1 dentro de una caja met\u00e1lica sellada herm\u00e9ticamente para mejorar la inmunidad al ruido/temperatura/humedad. Esta caja dispone de una ventana hecha de material transmisor de infrarrojos (t\u00edpicamente silicona recubierta) que protege el elemento sensor con los dos sensores equilibrados. La mayor parte de la verdadera magia ocurre con la \u00f3ptica, una lente de Fresnel que permite cambiar la amplitud, el rango y el patr\u00f3n de detecci\u00f3n muy f\u00e1cilmente. Seg\u00fan la Wikipedia es un dise\u00f1o que permite construir lentes de gran apertura y distancia focal corta con materiales ligeros y econ\u00f3micos. En la figura siguiente vemos un corte transversal de una lente de Fresnel comparada con una plano-convexa tradicional. Lentes de Fresnel y convexa En la figura siguiente vemos gr\u00e1ficamente el funcionamiento del sistema y como la lente Fresnel condensa la radiaci\u00f3n infrarroja al sensor. Funcionamiento de una lente Fresnel Explicaci\u00f3n del funcionamiento basada en en el documento de Adafruit titulado PIR Motion Sensor - Created by lady ada En la figura siguiente vemos la ventana del sensor PIR en el m\u00f3dulo que incorpora la autocaravana al que se le ha retirado la lente. Ventana del sensor PIR en el m\u00f3dulo de Keyestudio Las caracter\u00edsticas del m\u00f3dulo de keyestudio son: Tensi\u00f3n de alimentaci\u00f3n: de 3.3 a 5V DC Consumo 15 uA Temperatura de trabajo: de -20 a 85 \u00baC Salidas: 3V = nivel alto y 0V = nivel bajo Tiempo de retardo en la salida para el nivel alto: 2.3 a 3 segundos \u00c1ngulo de detecci\u00f3n: 100\u00ba Distancia de detecci\u00f3n: 3 a 4 metros LED indicador: Si la salida est\u00e1 en nivel alto el LED se enciende. Corriente l\u00edmite por el pin de se\u00f1al: 100 mA Algunas aclaraciones que nos hace el fabricante: La distancia m\u00e1xima es de 3-4 metros. Antes de probar la primera vez quitamos la lente blanca, se puede ver la ventana de detecci\u00f3n rectangular. Cuando el lado mayor del rect\u00e1ngulo es paralelo al suelo, la distancia de detecci\u00f3n es la mejor. Para comenzar a probar el sensor debe cubrirse con la lente blanca; de lo contrario, afectar\u00e1 a la distancia. La distancia de detecci\u00f3n \u00f3ptima se da a 25 \u2103 y se acorta cuando supera los 30 \u2103. Cuando carguemos nuestro c\u00f3digo debemos esperar de 5 a 10 segundos para que el m\u00f3dulo sea sensible y luego comenzar a probar.","title":"PIR"},{"location":"Tactividades/T_PIR/#bloques-de-tiempo","text":"Aunque ya los hemos utilizado en este momento vamos a explicar los bloques de tiempo que se implementan en ArduinoBlocks. Las funciones de tiempo o retardo nos permiten realizar pausas y obtener informaci\u00f3n sobre el tiempo transcurrido dentro del microcontrolador. 1.- Bloques esperar . Realizan una pausa del tiempo que establezcamos hasta seguir con la ejecuci\u00f3n del siguiente bloque. Se corresponden con las instrucciones delay(1000) y delayMicroseconds(1000) . Tenemos disponibles los dos de la imagen siguiente: Bloques esperar Debemos tener siempre muy presente que estos bloques detienen la ejecuci\u00f3n del programa y dejan al microcontrolador bloqueado haci\u00e9ndole pensar que est\u00e1 haciendo algo \u00fatil, cuando en realidad no es as\u00ed porque durante el tiempo que dura el bloqueo ni se env\u00edan ni se reciben \u00f3rdenes. Por esto hay que tener cuidado al utilizarlo aunque nos resulte muy f\u00e1cil y c\u00f3modo. Ya hemos visto alternativas como la multitarea, donde si los utilizamos, el sistema multitarea querr\u00e1 asignarle tiempo de procesamiento a la tarea, aunque sea para eso, \u00a1para no hacer nada! 2.- Tiempo transcurrido . Obtiene un valor con el tiempo transcurrido desde el inicio o reset del microcontrolador de la placa. Se trata de las funciones millis() y micros(). El valor puede ser en milisegundos o microsegundos, tal y como vemos en la imagen siguiente: Bloques tiempo transcurrido En la imagen siguiente tenemos un ejemplo de uso sacado del manual del programa : Ejecutar la Tarea1 cada 3 segundos y la Tarea2 cada 7 segundos sin bloquear la ejecuci\u00f3n del programa : Ejemplo de uso del bloque tiempo transcurrido 3.- Esperar por siempre . Bloquea indefinidamente la ejecuci\u00f3n finalizando por tanto el programa. Vemos el bloque en la imagen siguiente: Bloque esperar por siempre 4.- Ejecutar cada . Es un bloque que NO bloquea la ejecuci\u00f3n del programa y que implementa autom\u00e1ticamente la funci\u00f3n millis(). En la imagen siguiente vemos su aspecto: Bloque ejecutar cada Este bloque es equivalente a establecer la variable diferencia a 1000ms en el ejemplo visto sobre tiempo transcurrido . Cuando necesitemos realizar distintas tareas peri\u00f3dicas y que parezca que se ejecuten paralelamente sin bloquearse unas a otras utilizaremos este tipo de bloque \u201cejecutar cada\u201d. El tiempo que pongamos en cada tarea 'Ejecutar cada' determina la precisi\u00f3n de la ejecuci\u00f3n de tareas, de forma que si una tarea 'tarda' mucho bloquear\u00e1 y 'retrasar\u00e1' al resto. Para un funcionamiento correcto debemos aseguarnos de que: Cada tarea se ejecuta en el menor tiempo posible No usar nunca bloques de tipo esperar dentro de las tareas. No implmentar bucles que puedan quedarse en ejecuci\u00f3n por tiempo indefinido. En la figura siguiente vemos dos ejemplos comentados de lo que no debemos hacer. Dos errores comunes en el uso del bloque ejecutar cada Hay dispositivos, y por tanto bloques, que no admiten utilizar las esperas siendo obligado evitar los bloques 'esperar'. A continuaci\u00f3n vemos cuales son estos bloques incompatibles con bloqueos de tiempo en ArduinoBlocks. Bloques GPS . Estos necesitan leer peri\u00f3dicamente los datos desde el m\u00f3dulo para obtener la informaci\u00f3n actualizada. Si utilizamos bloqueos en nuestro programa los datos GPS no ser\u00e1n v\u00e1lidos. Bloques MQTT . Estos gestionan la comunicaci\u00f3n a trav\u00e9s de la red Ethernet (TCP/IP) de forma continua en segundo plano, si bloqueamos la ejecuci\u00f3n del programa no se realizar\u00e1 correctamente la comunicaci\u00f3n. Por lo tanto en estos casos hay seguir siempre un m\u00e9todo de programaci\u00f3n por tareas utilizando bloques del tipo \u201cejecutar cada\u201d. 5.- Cron\u00f3metro . Es un bloque que permite obtener el tiempo transcurrido en milisegundos o en segundos a partir de la funci\u00f3n millis(), y es f\u00e1cilmente puesto a 0 con el bloque reiniciar cronometro. En la figura siguiente vemos los dos bloques mencionados. Bloques para utilizar el cron\u00f3metro 6.- Dormir . Este bloque nos permite poner la placa de control tipo Arduino en modo bajo consumo durante unos milisegundos. Se trata de poner en modo sleep o hibernaci\u00f3n para reducir el consumo al m\u00ednimo mientras no estamos haciendo nada. En el caso de ArduinoBlocks se utiliza la librer\u00eda snooze.","title":"Bloques de tiempo"},{"location":"Tactividades/T_PIR/#funciones","text":"Una funci\u00f3n permite crear un grupo de bloques de c\u00f3digo que realizan una determinada tarea y que se repite a lo largo del programa principal en varias ocasiones. Con la creaci\u00f3n de una funci\u00f3n evitamos repetir todos esos bloques y simplemente tendremos que invocar a la funci\u00f3n. Es muy conveniente que los nombre que usemos sean lo mas descriptivos posibles de lo que hace la funci\u00f3n. Existen dos tipos de funciones: las que no retornan un valor y las que si lo hacen. En la imagen siguiente vemos los bloques correspondientes a las mismas: Bloques para crear funciones en ArduinoBlocks Cuando creamos funciones autom\u00e1ticamente se crea el bloque con su nombre que permite invocarla, tal y como vemos en la imagen siguiente: Bloques para llamada a funciones Tambi\u00e9n es posible crear funciones a las que se le env\u00edan datos o par\u00e1metros haciendo uso del signo + que aparece en los bloques. En la imagen siguiente vemos como le hemos a\u00f1adido un par de par\u00e1metros a cada tipo de funci\u00f3n y como se han modificado sus respectivos bloques de invocaci\u00f3n. Bloques para llamada a funciones con par\u00e1metros Un ejemplo t\u00edpico descriptivo del funcionamiento de las funciones es el de calculo del \u00e1rea de un tri\u00e1ngulo. Para ello definimos la funci\u00f3n que realiza el c\u00e1lculo, le pasamos dos par\u00e1metros, la base y la altura, realizamos los c\u00e1lculos pitag\u00f3ricos y nos devuelve el \u00e1rea del tri\u00e1ngulo para esos datos. En la imagen siguiente tenemos la idea de resoluci\u00f3n con la funci\u00f3n creada y el bloque para llamarla. Ejemplo de calculo del \u00e1rea de un tri\u00e1ngulo En las im\u00e1genes siguiente vemos como se han creado diferentes funciones y la forma de llamarlas. En concreto se corresponden con la base del programa de Educacont para configurar y grabar en la correspondiente estaci\u00f3n. La primera funci\u00f3n es \"leer sensores\" y la vemos en la imagen siguiente: Funci\u00f3n leer sensores de Educacont En la imagen siguiente podemos ver la funci\u00f3n encargada de subir los datos le\u00eddos a la nube. Funci\u00f3n subir datos a la nube de Educacont La siguiente funci\u00f3n permite detener las mediciones durante 15 minutos. Funci\u00f3n detener medici\u00f3n nn minutos de Educacont El bucle principal tiene la configuraci\u00f3n que vemos en la imagen siguiente: Llamada a las funciones definidas","title":"Funciones"},{"location":"Tactividades/T_RGB/","text":"El diodo LED RGB \u00b6 Conceptos incluidos \u00b6 Multitarea N\u00fameros aleatorio LED RGB \u00b6 Un LED RGB es en realidad un encapsulado que incorpora tres diodos LED, uno por cada color fundamental. Los colores primarios en \u00f3ptica son el rojo, el verde y el azul y la correcta combinaci\u00f3n, en t\u00e9rminos de intensidad, de ellos originar\u00e1 cualquiera de los colores secundarios. Las siglas RGB son el acr\u00f3nimo de Red, Green y Blue. En el caso de la autocaravana, a modo de faros, se utilizan dos LEDs RGB de 10mm de di\u00e1metro con los tres LEDs unidos por su c\u00e1todo o terminal negativo, es decir son de c\u00e1todo com\u00fan. En la imagen siguiente vemos el modelo aditivo de los colores rojo, verde y azul. RGB Existen dos tipos de LEDs RGB seg\u00fan como se conectan internamente y pueden ser de c\u00e1todo com\u00fan o de \u00e1nodo com\u00fan. El s\u00edmbolo y la representaci\u00f3n de este componente lo vemos en la imagen siguiente, correspondiendo la pareja de la izquierda a los de c\u00e1todo com\u00fan y la pareja de la derecha a los de \u00e1nodo com\u00fan: S\u00edmbolo y representaci\u00f3n Los que se utilizan en la autocaravana son de \u00e1nodo com\u00fan. Te\u00f3ricamente en Arduino, cada uno de esos LEDs podr\u00eda adoptar 256 (valores entre 0 y 255) colores diferentes, es decir, un total de 16.777.216 posibles colores diferentes con un LED RGB. Multitarea \u00b6 Este apartado se extrae de ArduinoBlocks - FreeBook disponible en Free Book (online & updated) . ArduinoBlocks nos permite utilizar una capa para implementar un sistema multitarea avanzado basado en FreeRTOS (del ingl\u00e9s Real Time Operating System), que es un sistema operativo de tiempo real kernel para dispositivos embebidos para plataformas de microcontrolador que se distribuye bajo licencia MIT. Este sistema permite crear tareas que se ejecutar\u00e1n de forma paralela (virtualmente). En microcontroladores modestos como el Arduino UNO, Nano o incluso MEGA la multitarea con FreeRTOS es bastante limitada y consume gran parte de los recursos de nuestro Arduino, en caso de necesitar de un sistema multitarea m\u00e1s potente podemos optar por usarlo en placas basadas en ESP8266 o ESP32 con mucha m\u00e1s potencia y recursos (especialmente el ESP32 con doble n\u00facleo y gran potencia de procesamiento y memoria interna) Los sistemas software de multitarea utilizan un planificador o scheduler que se encarga de repartir el tiempo de procesamiento entre las distintas tareas, de forma que a cada una le toca un tiempo de microcontrolador para ejecutar un poquito de su parte de programa. En las web de freeRTOS , en su entrada de men\u00fa Kernel podemos encontrar los conceptos b\u00e1sicos de multitarea y de programaci\u00f3n que vamos a extractar seguidamente. Conceptos b\u00e1sicos de multitarea \u00b6 Un procesador convencional como el de Arduino UNO solo puede ejecutar una tarea a la vez, pero al cambiar r\u00e1pidamente entre tareas, un sistema operativo multitarea puede hacer que parezca que cada tarea se ejecuta simult\u00e1neamente. Esto es lo que se representa en el diagrama de la Figura siguiente que muestra el patr\u00f3n de ejecuci\u00f3n de tres tareas con respecto al tiempo. Los nombres de las tareas est\u00e1n codificados por colores y escritos a la izquierda. El tiempo se mueve de izquierda a derecha y las l\u00edneas de colores muestran qu\u00e9 tarea se est\u00e1 ejecutando en un momento determinado. El diagrama superior demuestra el patr\u00f3n de ejecuci\u00f3n concurrente percibido, y el inferior el patr\u00f3n de ejecuci\u00f3n multitarea real. Patr\u00f3n de ejecuci\u00f3n de tres tareas con respecto al tiempo Programaci\u00f3n \u00b6 El programador es quien debe decidir qu\u00e9 tarea debe ejecutarse en un momento determinado. El kernel o n\u00facleo puede suspender y luego reanudar una tarea muchas veces durante el tiempo de vida de la tarea. Adem\u00e1s de ser suspendida involuntariamente por el n\u00facleo o kernel, una tarea puede optar por suspenderse a s\u00ed misma. Har\u00e1 esto si desea retrasar ( dormir ) por un per\u00edodo fijo o esperar ( bloquear ) a que un recurso (por ejemplo, un puerto serie) est\u00e9 disponible, o que ocurra un evento (por ejemplo, presionar una pulsador). Una tarea bloqueada o inactiva no se puede ejecutar y no se le asignar\u00e1 ning\u00fan tiempo de procesamiento. En la Figura siguiente vemos un posible diagrama de ejecuci\u00f3n de tres tareas analizado punto por punto en distintos instantes de tiempo. En los c\u00edrculos se representan los instantes de tiempo t1 a t10. Diagrama de ejecuci\u00f3n de tres tareas en el tiempo t1: la tarea 1 se est\u00e1 ejecutando. t2: en el kernel se suspende, o mejor dicho se intercambia, la tarea 1 . t3: se reanuda la tarea 2 . t4: mientras se ejecuta la tarea 2 el procesador bloquea el puerto serie para su acceso exclusivo. t5: el kernel suspende la tarea 2 . t6: el kernel reanuda la tarea 3 . t1: la tarea 3 intenta acceder al puerto serie y lo encuentra bloqueado por lo que no puede continuar y se suspende. t8: el kernel reanuda la tarea 1 . t9: al ejecutarse de nuevo la tarea 2 se desbloquea el puerto serie. t10: la tarea 3 ahora si puede acceder al puerto serie y se ejecuta al completo Planificadores \u00b6 Los planificadores de multitarea permiten asignar a cada tarea una prioridad, para as\u00ed darle preferencia a las tareas m\u00e1s cr\u00edticas o que necesitan m\u00e1s tiempo de procesamiento. Si creamos muchas tareas con \u201calta\u201d prioridad puede que afectemos a las dem\u00e1s dejando poco tiempo de procesamiento para ellas. En la Figura siguiente vemos un esquema de varias tareas con distintas prioridades, variando as\u00ed su tiempo de microprocesador asignado. Distintas prioridades en tres tareas Cada tarea tiene su propio espacio de memoria, por lo que crear demasiadas tareas tambi\u00e9n puede dejarnos el procesador sin memoria. Si la memoria asignada a las tareas tampoco es suficiente para almacenar los datos se podr\u00eda reiniciar de forma inesperada el Arduino, o funcionar incorrectamente, es decir que como siempre, hay que ser consciente de los limitados recursos de los que disponemos. Sem\u00e1foros \u00b6 Con la introducci\u00f3n te\u00f3rica a la multitarea vista, debemos hacernos otra pregunta: \u00bfQu\u00e9 pasa si una tarea accede a un recurso o variable, y el sistema multitarea le da el control a otra tarea y por tanto ese proceso falla o quiz\u00e1s otra tarea acceda al mismo recurso y se solapen? Para ese problema de convivencia entre tareas se inventaron los \u201csem\u00e1foros\u201d, en concreto el que m\u00e1s nos interesa es el sem\u00e1foro \u201cmutex\u201d o de exclusi\u00f3n mutua, que permite que bloqueemos el sistema multitarea, hagamos lo que tengamos que hacer cr\u00edtico, y luego liberemos el control. Por supuesto estas tareas cr\u00edticas deben ser lo m\u00e1s cortas y at\u00f3micas posibles: una escritura cr\u00edtica en una variable, un env\u00edo de un dato, una actualizaci\u00f3n de una pantalla LCD,... siempre cosas simples. Los sem\u00e1foros debemos usarlos en casos que tengamos claro que se pueden crear conflictos, pues su abuso puede hacer que el sistema multitarea empiece a fallar. En la Figura siguiente vemos el esquema de acceso a un recurso desde dos tareas diferentes. Esquema de acceso a un mismo recurso por parte de 2 tareas diferentes Bloques esperar \u00b6 \u00bfQu\u00e9 pasa con los bloques tipo \u201cesperar\u201d que estaban tan prohibidos en la programaci\u00f3n de Arduino cuando quer\u00edamos simular una multitarea antes de tener estos bloques? Pues seguimos teni\u00e9ndoles bastante tirria. Aunque en teor\u00eda podr\u00edamos usarlos, un bloque esperar hace pensar al microcontrolador que est\u00e1 haciendo algo \u00fatil, cuando en realidad no es as\u00ed, por lo que el sistema multitarea querr\u00e1 asignarle tiempo de procesamiento a la tarea, aunque sea para eso, \u00a1para no hacer nada! Tenemos una soluci\u00f3n, tenemos un nuevo bloque de esperar \u201ctask friendly\u201d que en lugar de esperar sin hacer nada le dice al sistema: \u00a1voy a estar un rato sin hacer nada, permite ejecutar otras tareas mientras y luego vuelves! \u2026.Mucho m\u00e1s \u201cfriendly\u201d, claro que s\u00ed. Bloques \u00b6 Con toda esta informaci\u00f3n pasamos a ver los bloques disponibles para poner todo \u00e9sto en marcha. Bloque Descripci\u00f3n Permite crear una nueva tarea con su bloque de \u201cinicializar\u201d y su \u201cbucle\u201d al igual que la tarea original de Arduino. Debemos asignar una prioridad a cada tarea, por defecto dejar\u00eda todas a \u201cbaja\u201d y luego ir\u00eda ajustando si hace falta. Para gestionar mejor las prioridades, es recomendable en algunos casos no utilizar el \u201cinicializar\u201d y \u201cbucle\u201d propio de Arduino que suele tener preferencia sobre todas estas tareas y es m\u00e1s dif\u00edcil de equilibrar las prioridades. El bloque esperar \u00f3ptimo para tareas, pues deja funcionar al resto de tareas de forma m\u00e1s \u00f3ptima mientras se espera en \u00e9sta. Este bloque tiene menos precisi\u00f3n que el bloque \u201cesperar\u201d original, si necesitamos hacer esperas muy precisas (o de menos de 20 ms) debemos usar el \u201cesperar\u201d tradicional. Pero nos servir\u00e1 en la mayor\u00eda de casos. Si tenemos que hacer alguna acci\u00f3n cr\u00edtica que no queremos que sea interrumpida internamente por el planificador del sistema multitarea podemos poner este bloque y dentro los bloques cr\u00edticos. (no utilizar si no es estrictamente necesario) Cada tarea tiene su propio espacio de memoria reservado, esta es la cantidad por defecto para las tareas (192 bytes), si necesitamos ajustarla podemos utilizar este bloque en el \u201cinicializar\u201d principal y se ajustar\u00e1 para todas las tareas. Un mal ajuste puede provocar reinicios del microcontrolador o mal funcionamiento. Las tareas en principio, igual que el bucle de Arduino, est\u00e1n pensadas para ejecutarse de forma indefinida, si en un caso una tarea deja de ser necesaria la forma de terminarla es con este bloque que parar\u00e1 la ejecuci\u00f3n y liberar\u00e1 la memoria de la tarea en la que se ejecuta. N\u00fameros aleatorios \u00b6 En ArduinoBlocks existe un bloque en el men\u00fa 'Matem\u00e1ticas' que es capaz de generar n\u00fameros enteros aleatorios entre los valores que establezcamos en sus par\u00e1metros. Este bloque es el que vemos en la figura siguiente: Bloque n\u00famero aleatorio Este bloque se basa en la funci\u00f3n random(m, M) que devuelve un numero seudoaleatorio entre el m\u00ednimo 'm' y el m\u00e1ximo 'M'. Esta funci\u00f3n por si sola genera siempre la misma secuencia de n\u00fameros si los par\u00e1metros no se cambian. Para solucionar esto se implementa la funci\u00f3n \"semilla\" como randomSeed(semilla) que lo que hace es iniciar la funci\u00f3n 'random' con el par\u00e1metro 'semilla' que debe estar incluida en la funci\u00f3n inicializar o 'Setup'. Pero si el valor de 'semilla' no cambia ocurre exactamente lo mismo que con 'random'. La soluci\u00f3n que se adopta es asignarle a 'semilla' el valor de una entrada anal\u00f3gica no utilizada, dado que un pin anal\u00f3gico no utilizado no tiene ninguna tensi\u00f3n de referencia y devolver\u00e1 un valor de ruido que ser\u00e1 diferente cada vez que se lea. Aunque no es prop\u00f3sito de estas notas explicar c\u00f3digo C++ si se entiende necesario al menos hacer referencia a la forma en que se generan n\u00fameros aleatorio en Arduino y por extensi\u00f3n n ArduinoBlocks. En la figura siguiente vemos el c\u00f3digo asociado al programa de generaci\u00f3n de un n\u00famero aleatorio que guardamos en la variable 'a'. C\u00f3digo para generar un n\u00famero aleatorio","title":"El diodo LED RGB"},{"location":"Tactividades/T_RGB/#el-diodo-led-rgb","text":"","title":"El diodo LED RGB"},{"location":"Tactividades/T_RGB/#conceptos-incluidos","text":"Multitarea N\u00fameros aleatorio","title":"Conceptos incluidos"},{"location":"Tactividades/T_RGB/#led-rgb","text":"Un LED RGB es en realidad un encapsulado que incorpora tres diodos LED, uno por cada color fundamental. Los colores primarios en \u00f3ptica son el rojo, el verde y el azul y la correcta combinaci\u00f3n, en t\u00e9rminos de intensidad, de ellos originar\u00e1 cualquiera de los colores secundarios. Las siglas RGB son el acr\u00f3nimo de Red, Green y Blue. En el caso de la autocaravana, a modo de faros, se utilizan dos LEDs RGB de 10mm de di\u00e1metro con los tres LEDs unidos por su c\u00e1todo o terminal negativo, es decir son de c\u00e1todo com\u00fan. En la imagen siguiente vemos el modelo aditivo de los colores rojo, verde y azul. RGB Existen dos tipos de LEDs RGB seg\u00fan como se conectan internamente y pueden ser de c\u00e1todo com\u00fan o de \u00e1nodo com\u00fan. El s\u00edmbolo y la representaci\u00f3n de este componente lo vemos en la imagen siguiente, correspondiendo la pareja de la izquierda a los de c\u00e1todo com\u00fan y la pareja de la derecha a los de \u00e1nodo com\u00fan: S\u00edmbolo y representaci\u00f3n Los que se utilizan en la autocaravana son de \u00e1nodo com\u00fan. Te\u00f3ricamente en Arduino, cada uno de esos LEDs podr\u00eda adoptar 256 (valores entre 0 y 255) colores diferentes, es decir, un total de 16.777.216 posibles colores diferentes con un LED RGB.","title":"LED RGB"},{"location":"Tactividades/T_RGB/#multitarea","text":"Este apartado se extrae de ArduinoBlocks - FreeBook disponible en Free Book (online & updated) . ArduinoBlocks nos permite utilizar una capa para implementar un sistema multitarea avanzado basado en FreeRTOS (del ingl\u00e9s Real Time Operating System), que es un sistema operativo de tiempo real kernel para dispositivos embebidos para plataformas de microcontrolador que se distribuye bajo licencia MIT. Este sistema permite crear tareas que se ejecutar\u00e1n de forma paralela (virtualmente). En microcontroladores modestos como el Arduino UNO, Nano o incluso MEGA la multitarea con FreeRTOS es bastante limitada y consume gran parte de los recursos de nuestro Arduino, en caso de necesitar de un sistema multitarea m\u00e1s potente podemos optar por usarlo en placas basadas en ESP8266 o ESP32 con mucha m\u00e1s potencia y recursos (especialmente el ESP32 con doble n\u00facleo y gran potencia de procesamiento y memoria interna) Los sistemas software de multitarea utilizan un planificador o scheduler que se encarga de repartir el tiempo de procesamiento entre las distintas tareas, de forma que a cada una le toca un tiempo de microcontrolador para ejecutar un poquito de su parte de programa. En las web de freeRTOS , en su entrada de men\u00fa Kernel podemos encontrar los conceptos b\u00e1sicos de multitarea y de programaci\u00f3n que vamos a extractar seguidamente.","title":"Multitarea"},{"location":"Tactividades/T_RGB/#conceptos-basicos-de-multitarea","text":"Un procesador convencional como el de Arduino UNO solo puede ejecutar una tarea a la vez, pero al cambiar r\u00e1pidamente entre tareas, un sistema operativo multitarea puede hacer que parezca que cada tarea se ejecuta simult\u00e1neamente. Esto es lo que se representa en el diagrama de la Figura siguiente que muestra el patr\u00f3n de ejecuci\u00f3n de tres tareas con respecto al tiempo. Los nombres de las tareas est\u00e1n codificados por colores y escritos a la izquierda. El tiempo se mueve de izquierda a derecha y las l\u00edneas de colores muestran qu\u00e9 tarea se est\u00e1 ejecutando en un momento determinado. El diagrama superior demuestra el patr\u00f3n de ejecuci\u00f3n concurrente percibido, y el inferior el patr\u00f3n de ejecuci\u00f3n multitarea real. Patr\u00f3n de ejecuci\u00f3n de tres tareas con respecto al tiempo","title":"Conceptos b\u00e1sicos de multitarea"},{"location":"Tactividades/T_RGB/#programacion","text":"El programador es quien debe decidir qu\u00e9 tarea debe ejecutarse en un momento determinado. El kernel o n\u00facleo puede suspender y luego reanudar una tarea muchas veces durante el tiempo de vida de la tarea. Adem\u00e1s de ser suspendida involuntariamente por el n\u00facleo o kernel, una tarea puede optar por suspenderse a s\u00ed misma. Har\u00e1 esto si desea retrasar ( dormir ) por un per\u00edodo fijo o esperar ( bloquear ) a que un recurso (por ejemplo, un puerto serie) est\u00e9 disponible, o que ocurra un evento (por ejemplo, presionar una pulsador). Una tarea bloqueada o inactiva no se puede ejecutar y no se le asignar\u00e1 ning\u00fan tiempo de procesamiento. En la Figura siguiente vemos un posible diagrama de ejecuci\u00f3n de tres tareas analizado punto por punto en distintos instantes de tiempo. En los c\u00edrculos se representan los instantes de tiempo t1 a t10. Diagrama de ejecuci\u00f3n de tres tareas en el tiempo t1: la tarea 1 se est\u00e1 ejecutando. t2: en el kernel se suspende, o mejor dicho se intercambia, la tarea 1 . t3: se reanuda la tarea 2 . t4: mientras se ejecuta la tarea 2 el procesador bloquea el puerto serie para su acceso exclusivo. t5: el kernel suspende la tarea 2 . t6: el kernel reanuda la tarea 3 . t1: la tarea 3 intenta acceder al puerto serie y lo encuentra bloqueado por lo que no puede continuar y se suspende. t8: el kernel reanuda la tarea 1 . t9: al ejecutarse de nuevo la tarea 2 se desbloquea el puerto serie. t10: la tarea 3 ahora si puede acceder al puerto serie y se ejecuta al completo","title":"Programaci\u00f3n"},{"location":"Tactividades/T_RGB/#planificadores","text":"Los planificadores de multitarea permiten asignar a cada tarea una prioridad, para as\u00ed darle preferencia a las tareas m\u00e1s cr\u00edticas o que necesitan m\u00e1s tiempo de procesamiento. Si creamos muchas tareas con \u201calta\u201d prioridad puede que afectemos a las dem\u00e1s dejando poco tiempo de procesamiento para ellas. En la Figura siguiente vemos un esquema de varias tareas con distintas prioridades, variando as\u00ed su tiempo de microprocesador asignado. Distintas prioridades en tres tareas Cada tarea tiene su propio espacio de memoria, por lo que crear demasiadas tareas tambi\u00e9n puede dejarnos el procesador sin memoria. Si la memoria asignada a las tareas tampoco es suficiente para almacenar los datos se podr\u00eda reiniciar de forma inesperada el Arduino, o funcionar incorrectamente, es decir que como siempre, hay que ser consciente de los limitados recursos de los que disponemos.","title":"Planificadores"},{"location":"Tactividades/T_RGB/#semaforos","text":"Con la introducci\u00f3n te\u00f3rica a la multitarea vista, debemos hacernos otra pregunta: \u00bfQu\u00e9 pasa si una tarea accede a un recurso o variable, y el sistema multitarea le da el control a otra tarea y por tanto ese proceso falla o quiz\u00e1s otra tarea acceda al mismo recurso y se solapen? Para ese problema de convivencia entre tareas se inventaron los \u201csem\u00e1foros\u201d, en concreto el que m\u00e1s nos interesa es el sem\u00e1foro \u201cmutex\u201d o de exclusi\u00f3n mutua, que permite que bloqueemos el sistema multitarea, hagamos lo que tengamos que hacer cr\u00edtico, y luego liberemos el control. Por supuesto estas tareas cr\u00edticas deben ser lo m\u00e1s cortas y at\u00f3micas posibles: una escritura cr\u00edtica en una variable, un env\u00edo de un dato, una actualizaci\u00f3n de una pantalla LCD,... siempre cosas simples. Los sem\u00e1foros debemos usarlos en casos que tengamos claro que se pueden crear conflictos, pues su abuso puede hacer que el sistema multitarea empiece a fallar. En la Figura siguiente vemos el esquema de acceso a un recurso desde dos tareas diferentes. Esquema de acceso a un mismo recurso por parte de 2 tareas diferentes","title":"Sem\u00e1foros"},{"location":"Tactividades/T_RGB/#bloques-esperar","text":"\u00bfQu\u00e9 pasa con los bloques tipo \u201cesperar\u201d que estaban tan prohibidos en la programaci\u00f3n de Arduino cuando quer\u00edamos simular una multitarea antes de tener estos bloques? Pues seguimos teni\u00e9ndoles bastante tirria. Aunque en teor\u00eda podr\u00edamos usarlos, un bloque esperar hace pensar al microcontrolador que est\u00e1 haciendo algo \u00fatil, cuando en realidad no es as\u00ed, por lo que el sistema multitarea querr\u00e1 asignarle tiempo de procesamiento a la tarea, aunque sea para eso, \u00a1para no hacer nada! Tenemos una soluci\u00f3n, tenemos un nuevo bloque de esperar \u201ctask friendly\u201d que en lugar de esperar sin hacer nada le dice al sistema: \u00a1voy a estar un rato sin hacer nada, permite ejecutar otras tareas mientras y luego vuelves! \u2026.Mucho m\u00e1s \u201cfriendly\u201d, claro que s\u00ed.","title":"Bloques esperar"},{"location":"Tactividades/T_RGB/#bloques","text":"Con toda esta informaci\u00f3n pasamos a ver los bloques disponibles para poner todo \u00e9sto en marcha. Bloque Descripci\u00f3n Permite crear una nueva tarea con su bloque de \u201cinicializar\u201d y su \u201cbucle\u201d al igual que la tarea original de Arduino. Debemos asignar una prioridad a cada tarea, por defecto dejar\u00eda todas a \u201cbaja\u201d y luego ir\u00eda ajustando si hace falta. Para gestionar mejor las prioridades, es recomendable en algunos casos no utilizar el \u201cinicializar\u201d y \u201cbucle\u201d propio de Arduino que suele tener preferencia sobre todas estas tareas y es m\u00e1s dif\u00edcil de equilibrar las prioridades. El bloque esperar \u00f3ptimo para tareas, pues deja funcionar al resto de tareas de forma m\u00e1s \u00f3ptima mientras se espera en \u00e9sta. Este bloque tiene menos precisi\u00f3n que el bloque \u201cesperar\u201d original, si necesitamos hacer esperas muy precisas (o de menos de 20 ms) debemos usar el \u201cesperar\u201d tradicional. Pero nos servir\u00e1 en la mayor\u00eda de casos. Si tenemos que hacer alguna acci\u00f3n cr\u00edtica que no queremos que sea interrumpida internamente por el planificador del sistema multitarea podemos poner este bloque y dentro los bloques cr\u00edticos. (no utilizar si no es estrictamente necesario) Cada tarea tiene su propio espacio de memoria reservado, esta es la cantidad por defecto para las tareas (192 bytes), si necesitamos ajustarla podemos utilizar este bloque en el \u201cinicializar\u201d principal y se ajustar\u00e1 para todas las tareas. Un mal ajuste puede provocar reinicios del microcontrolador o mal funcionamiento. Las tareas en principio, igual que el bucle de Arduino, est\u00e1n pensadas para ejecutarse de forma indefinida, si en un caso una tarea deja de ser necesaria la forma de terminarla es con este bloque que parar\u00e1 la ejecuci\u00f3n y liberar\u00e1 la memoria de la tarea en la que se ejecuta.","title":"Bloques"},{"location":"Tactividades/T_RGB/#numeros-aleatorios","text":"En ArduinoBlocks existe un bloque en el men\u00fa 'Matem\u00e1ticas' que es capaz de generar n\u00fameros enteros aleatorios entre los valores que establezcamos en sus par\u00e1metros. Este bloque es el que vemos en la figura siguiente: Bloque n\u00famero aleatorio Este bloque se basa en la funci\u00f3n random(m, M) que devuelve un numero seudoaleatorio entre el m\u00ednimo 'm' y el m\u00e1ximo 'M'. Esta funci\u00f3n por si sola genera siempre la misma secuencia de n\u00fameros si los par\u00e1metros no se cambian. Para solucionar esto se implementa la funci\u00f3n \"semilla\" como randomSeed(semilla) que lo que hace es iniciar la funci\u00f3n 'random' con el par\u00e1metro 'semilla' que debe estar incluida en la funci\u00f3n inicializar o 'Setup'. Pero si el valor de 'semilla' no cambia ocurre exactamente lo mismo que con 'random'. La soluci\u00f3n que se adopta es asignarle a 'semilla' el valor de una entrada anal\u00f3gica no utilizada, dado que un pin anal\u00f3gico no utilizado no tiene ninguna tensi\u00f3n de referencia y devolver\u00e1 un valor de ruido que ser\u00e1 diferente cada vez que se lea. Aunque no es prop\u00f3sito de estas notas explicar c\u00f3digo C++ si se entiende necesario al menos hacer referencia a la forma en que se generan n\u00fameros aleatorio en Arduino y por extensi\u00f3n n ArduinoBlocks. En la figura siguiente vemos el c\u00f3digo asociado al programa de generaci\u00f3n de un n\u00famero aleatorio que guardamos en la variable 'a'. C\u00f3digo para generar un n\u00famero aleatorio","title":"N\u00fameros aleatorios"},{"location":"Tactividades/T_TEMT6000/","text":"El sensor de luz ambiental TEMT6000 \u00b6 Conceptos incluidos \u00b6 Detecci\u00f3n de luz con fototransistor Detecci\u00f3n de luz con fototransistor \u00b6 El TEMT6000 es un fototransistor de tipo NPN que presenta sensibilidad al espectro visible (390 a 700 nm). Un fototransistor no es mas que un transistor cuya base se expone a la luz a trav\u00e9s de una lente cambiando su corriente de base en funci\u00f3n de esta luz. En la figura siguiente vemos el aspecto de un fototransistor est\u00e1ndar y el esquema de conexi\u00f3n que se utiliza en el sensor TEMT6000. Encapsulados t\u00edpicos y circuito de aplicaci\u00f3n El fototransistor act\u00faa como una de las dos resistencias en el divisor de tensi\u00f3n. A medida que la luz incide sobre la superficie del fototransistor, el valor de su resistencia cambia, lo que hace cambiar la tensi\u00f3n en el pin 'S'. A partir de esto se puede utilizar un Arduino o cualquier otro microcontrolador para leer el valor y as\u00ed medir la iluminancia y la intensidad de la luz. Sensor TEMT6000 \u00b6 Se trata de un sensor anal\u00f3gico uya salida puede conectarse a cualquier entrada anal\u00f3gica de una placa de control. El sensor luz ambiental TEMT6000 es sensible al espectro visible y se supone que est\u00e1 adaptado a la sensibilidad del ojo humano. El m\u00f3dulo puede ser utilizado cuando se requiere mas precisi\u00f3n que la que ofrece la LDR sin a\u00f1adir complejidad. No reacciona bien a la luz infrarroja ni ultravioleta.En la figura siguiente vemos su aspecto. Aspecto del sensor Ya sabemos que muchos dispositivos utilizan sensores de luz para ajustar autom\u00e1ticamente el brillo seg\u00fan la intensidad de la luz. Entre estos dispositivos se incluyen pantallas de tel\u00e9fonos m\u00f3viles y c\u00e1maras digitales para ajustar la exposici\u00f3n. Tambi\u00e9n estamos acostumbrados a que las luces de nuestras ciudades se enciendan y apaguen autom\u00e1ticamente en funci\u00f3n del nivel de luz y ello gracias a este tipo de sensores. El sensor de luz ambiental TEMT6000 mide la iluminancia, que es una medida de la cantidad total de luz visible emitida por una fuente. \u00bfPor qu\u00e9 el TEMT6000 solo mide la iluminancia? La respuesta es que medir la intensidad de la luz sin tener en cuenta la distancia es muy dif\u00edcil. Por ejemplo, si tiene una fuente brillante lejos y una fuente tenue muy cerca, puede parecer que tienen el mismo brillo. Esto se debe a que la luz de la fuente m\u00e1s brillante tendr\u00e1 que disiparse en un volumen mayor en comparaci\u00f3n con la luz menos brillante. Esta es la raz\u00f3n por la cual el sensor leer\u00e1 un valor m\u00e1s peque\u00f1o si aleja la misma fuente de luz, lo que esencialmente aumenta la cantidad de espacio que la misma cantidad de luz tiene que llenar entre la fuente y el sensor. En la figura siguiente tenemos una relaci\u00f3n gr\u00e1fica entre la corriente (en \u00b5A) y la iluminancia percibida por el sensor del entorno cercano: Corriente de base en funci\u00f3n de la iluminancia La curva se ha sacado del datasheet del sensor .","title":"Sensor de luz ambiental"},{"location":"Tactividades/T_TEMT6000/#el-sensor-de-luz-ambiental-temt6000","text":"","title":"El sensor de luz ambiental TEMT6000"},{"location":"Tactividades/T_TEMT6000/#conceptos-incluidos","text":"Detecci\u00f3n de luz con fototransistor","title":"Conceptos incluidos"},{"location":"Tactividades/T_TEMT6000/#deteccion-de-luz-con-fototransistor","text":"El TEMT6000 es un fototransistor de tipo NPN que presenta sensibilidad al espectro visible (390 a 700 nm). Un fototransistor no es mas que un transistor cuya base se expone a la luz a trav\u00e9s de una lente cambiando su corriente de base en funci\u00f3n de esta luz. En la figura siguiente vemos el aspecto de un fototransistor est\u00e1ndar y el esquema de conexi\u00f3n que se utiliza en el sensor TEMT6000. Encapsulados t\u00edpicos y circuito de aplicaci\u00f3n El fototransistor act\u00faa como una de las dos resistencias en el divisor de tensi\u00f3n. A medida que la luz incide sobre la superficie del fototransistor, el valor de su resistencia cambia, lo que hace cambiar la tensi\u00f3n en el pin 'S'. A partir de esto se puede utilizar un Arduino o cualquier otro microcontrolador para leer el valor y as\u00ed medir la iluminancia y la intensidad de la luz.","title":"Detecci\u00f3n de luz con fototransistor"},{"location":"Tactividades/T_TEMT6000/#sensor-temt6000","text":"Se trata de un sensor anal\u00f3gico uya salida puede conectarse a cualquier entrada anal\u00f3gica de una placa de control. El sensor luz ambiental TEMT6000 es sensible al espectro visible y se supone que est\u00e1 adaptado a la sensibilidad del ojo humano. El m\u00f3dulo puede ser utilizado cuando se requiere mas precisi\u00f3n que la que ofrece la LDR sin a\u00f1adir complejidad. No reacciona bien a la luz infrarroja ni ultravioleta.En la figura siguiente vemos su aspecto. Aspecto del sensor Ya sabemos que muchos dispositivos utilizan sensores de luz para ajustar autom\u00e1ticamente el brillo seg\u00fan la intensidad de la luz. Entre estos dispositivos se incluyen pantallas de tel\u00e9fonos m\u00f3viles y c\u00e1maras digitales para ajustar la exposici\u00f3n. Tambi\u00e9n estamos acostumbrados a que las luces de nuestras ciudades se enciendan y apaguen autom\u00e1ticamente en funci\u00f3n del nivel de luz y ello gracias a este tipo de sensores. El sensor de luz ambiental TEMT6000 mide la iluminancia, que es una medida de la cantidad total de luz visible emitida por una fuente. \u00bfPor qu\u00e9 el TEMT6000 solo mide la iluminancia? La respuesta es que medir la intensidad de la luz sin tener en cuenta la distancia es muy dif\u00edcil. Por ejemplo, si tiene una fuente brillante lejos y una fuente tenue muy cerca, puede parecer que tienen el mismo brillo. Esto se debe a que la luz de la fuente m\u00e1s brillante tendr\u00e1 que disiparse en un volumen mayor en comparaci\u00f3n con la luz menos brillante. Esta es la raz\u00f3n por la cual el sensor leer\u00e1 un valor m\u00e1s peque\u00f1o si aleja la misma fuente de luz, lo que esencialmente aumenta la cantidad de espacio que la misma cantidad de luz tiene que llenar entre la fuente y el sensor. En la figura siguiente tenemos una relaci\u00f3n gr\u00e1fica entre la corriente (en \u00b5A) y la iluminancia percibida por el sensor del entorno cercano: Corriente de base en funci\u00f3n de la iluminancia La curva se ha sacado del datasheet del sensor .","title":"Sensor TEMT6000"},{"location":"Tactividades/T_neo/","text":"LEDs RGB direccionables \u00b6 Conceptos incluidos \u00b6 ?????????? LED RGB \u00b6","title":"LEDs RGB direccionables"},{"location":"Tactividades/T_neo/#leds-rgb-direccionables","text":"","title":"LEDs RGB direccionables"},{"location":"Tactividades/T_neo/#conceptos-incluidos","text":"??????????","title":"Conceptos incluidos"},{"location":"Tactividades/T_neo/#led-rgb","text":"","title":"LED RGB"},{"location":"Tactividades/T_poten/","text":"El potenci\u00f3metro \u00b6 Conceptos incluidos \u00b6 Circuitos digitales y anal\u00f3gicos Serial Plotter - Datalogger Mapeo Circuitos digitales y anal\u00f3gicos \u00b6 Una clasificaci\u00f3n de los circuitos electr\u00f3nicos es dividirlos en dos grandes categor\u00edas: digitales y anal\u00f3gicos. La electr\u00f3nica digital utiliza magnitudes con dos valores discretos conocidos como 0 - 1, alto - bajo, on - off, etc, y que se corresponden con la presencia o no de tensi\u00f3n en un determinado punto. Estos valores discretos pueden sufrir peque\u00f1as variaciones en alguna variable del circuito pero, si no cambia el valor discreto no se produce ning\u00fan cambio en el comportamiento del circuito por lo que podemos decir que este no depende del valor exacto de la se\u00f1al. En la figura siguiente vemos una se\u00f1al digital t\u00edpica. Se\u00f1al digital La electr\u00f3nica anal\u00f3gica emplea magnitudes con valores continuos o variables continuas. Una peque\u00f1a variaci\u00f3n en una variable puede producir un gran cambio en el comportamiento del circuito. En las placas tipo Arduino, ESP, etc esta terminolog\u00eda se utiliza para referirse a entradas y las placas suelen disponer de un n\u00famero variable de entradas anal\u00f3gicas. Por ejemplo Arduino UNO y Mini disponen de 6 y Arduino mega de 16. En el mundo real se puede afirmar que cualquier se\u00f1al es anal\u00f3gica y un valor digital es una abstracci\u00f3n conceptual. En placas tipo Arduino la medici\u00f3n que realiza una entrada anal\u00f3gica en realidad se realiza a partir de un conversor anal\u00f3gico a digital de un determinado n\u00famero de bits que definen la precisi\u00f3n de dicha conversi\u00f3n. Es decir, con una placa de este tipo no medimos valores anal\u00f3gicos con todos sus decimales, sino que obtenemos su conversi\u00f3n en 2^{n} 2^{n} niveles. Cuanto mayor sea el n\u00famero de bits mayor ser\u00e1 la precisi\u00f3n de la medici\u00f3n. En concreto a continuaci\u00f3n expresamos esta precisi\u00f3n para algunas placas: Tipo Arduino Uno, Mini y Mega. La resoluci\u00f3n es de 10 bits por lo que el n\u00famero de valores digitales posibles es: 2^{10} = 1024 2^{10} = 1024 . Para una tensi\u00f3n de 5V esto se traduce en que la precisi\u00f3n de la medida es de 5/1024 = 4.88mV = \\pm2.44mV 5/1024 = 4.88mV = \\pm2.44mV Tipo Arduino Due y ESP32 Plus STEAMakers. La resoluci\u00f3n es de 12 bits por lo que el n\u00famero de valores digitales posibles es: 2^{12} = 4096 2^{12} = 4096 . Para una tensi\u00f3n de 5V esto se traduce en que la precisi\u00f3n de la medida es de 5/4096 = 1.22mV = \\pm0.61mV 5/4096 = 1.22mV = \\pm0.61mV . En la imagen siguiente vemos el aspecto de una se\u00f1al anal\u00f3gica: Se\u00f1al anal\u00f3gica El potenci\u00f3metro \u00b6 En la imagen siguiente vemos el aspecto de un modelo concreto de potenci\u00f3metro as\u00ed como los s\u00edmbolos habituales del mismo. La numeraci\u00f3n indica lo siguiente: Terminales 1 y 3 son los contactos unidos a los extremos de la resistencia fija o resistencia total del potenci\u00f3metro. Terminal 2 es el contacto que va unido al cursor o parte m\u00f3vil que se desliza sobre la resistencia fija haciendo que la resistencia entre un terminal y el cursor var\u00ede en funci\u00f3n de la posici\u00f3n de este. Aspecto y s\u00edmbolo del potenci\u00f3metro La posici\u00f3n del cursor se determina de forma mec\u00e1nica y son adecuados para usarlos como elementos de control de tensi\u00f3n (conexi\u00f3n en serie) o de corriente (conexi\u00f3n en paralelo). Los potenci\u00f3metros del tipo que estamos viendo (existen de otros muchos tipos) tienen un funcionamiento en forma de rotaci\u00f3n con un \u00e1ngulo de unos 270 grados entre los puntos mas extremos. Serial Plotter - Datalogger \u00b6 Es otra funcionalidad relacionada con la comunicaci\u00f3n serie que nos permite visualizar informaci\u00f3n en forma de gr\u00e1fica en tiempo real. Adem\u00e1s el \u201cSerial Plotter\u201d implementa un sencillo datalogger con el que podemos ir grabando los datos para exportarlos posteriormente. En ArduinoBlocks existen bloques que nos permiten trabajar con el serial plotter. El serial plotter + datalogger se activa haciendo clic en la flecha a la derecha de Consola y tiene el aspecto que vemos en la imagen siguiente: Serial Plotter + Datalogger La funci\u00f3n de datalogger (registro de datos) la podemos activar desde el panel superior derecho y veremos un icono de tipo comecocos que va \u201ccomiendo\u201d datos mientras estamos recopilando los datos para su posterior exportaci\u00f3n. En la figura siguiente vemos su aspecto. Aspecto del Datalogger Cuando detenemos la grabaci\u00f3n o recopilaci\u00f3n de datos podremos descargar los archivo de datos en formato CSV (Comma Separated Values), generandose un archivo por cada serie de datos recogida, es decir, un archivo por cada variable que representemos en la gr\u00e1fica. Si superamos el n\u00famero de datos m\u00e1ximo seleccionado para registrar, se sobreescribir\u00e1n los datos m\u00e1s antiguos. Mapeo \u00b6 Hemos indicado que las entradas anal\u00f3gicas trabajan con 10 o 12 bits, o sea valores comprendidos entre 0 y 1023 ( 2^{10} 2^{10} ) 0 y 4095 ( 2^{12} 2^{12} ) y tambi\u00e9n sabemos que las salidas digitales trabajan con 8 bits, o sea valores entre 0 y 255, por lo que si queremos combinar en nuestro programa entradas anal\u00f3gicas con salidas digitales debemos realizar un ajuste de escala en los datos. A este ajuste se le conoce como \"mapear\" y es un bloque disponible en el men\u00fa 'Matem\u00e1ticas' con el aspecto de la imagen siguiente: Bloque mapear","title":"El potenci\u00f3metro"},{"location":"Tactividades/T_poten/#el-potenciometro","text":"","title":"El potenci\u00f3metro"},{"location":"Tactividades/T_poten/#conceptos-incluidos","text":"Circuitos digitales y anal\u00f3gicos Serial Plotter - Datalogger Mapeo","title":"Conceptos incluidos"},{"location":"Tactividades/T_poten/#circuitos-digitales-y-analogicos","text":"Una clasificaci\u00f3n de los circuitos electr\u00f3nicos es dividirlos en dos grandes categor\u00edas: digitales y anal\u00f3gicos. La electr\u00f3nica digital utiliza magnitudes con dos valores discretos conocidos como 0 - 1, alto - bajo, on - off, etc, y que se corresponden con la presencia o no de tensi\u00f3n en un determinado punto. Estos valores discretos pueden sufrir peque\u00f1as variaciones en alguna variable del circuito pero, si no cambia el valor discreto no se produce ning\u00fan cambio en el comportamiento del circuito por lo que podemos decir que este no depende del valor exacto de la se\u00f1al. En la figura siguiente vemos una se\u00f1al digital t\u00edpica. Se\u00f1al digital La electr\u00f3nica anal\u00f3gica emplea magnitudes con valores continuos o variables continuas. Una peque\u00f1a variaci\u00f3n en una variable puede producir un gran cambio en el comportamiento del circuito. En las placas tipo Arduino, ESP, etc esta terminolog\u00eda se utiliza para referirse a entradas y las placas suelen disponer de un n\u00famero variable de entradas anal\u00f3gicas. Por ejemplo Arduino UNO y Mini disponen de 6 y Arduino mega de 16. En el mundo real se puede afirmar que cualquier se\u00f1al es anal\u00f3gica y un valor digital es una abstracci\u00f3n conceptual. En placas tipo Arduino la medici\u00f3n que realiza una entrada anal\u00f3gica en realidad se realiza a partir de un conversor anal\u00f3gico a digital de un determinado n\u00famero de bits que definen la precisi\u00f3n de dicha conversi\u00f3n. Es decir, con una placa de este tipo no medimos valores anal\u00f3gicos con todos sus decimales, sino que obtenemos su conversi\u00f3n en 2^{n} 2^{n} niveles. Cuanto mayor sea el n\u00famero de bits mayor ser\u00e1 la precisi\u00f3n de la medici\u00f3n. En concreto a continuaci\u00f3n expresamos esta precisi\u00f3n para algunas placas: Tipo Arduino Uno, Mini y Mega. La resoluci\u00f3n es de 10 bits por lo que el n\u00famero de valores digitales posibles es: 2^{10} = 1024 2^{10} = 1024 . Para una tensi\u00f3n de 5V esto se traduce en que la precisi\u00f3n de la medida es de 5/1024 = 4.88mV = \\pm2.44mV 5/1024 = 4.88mV = \\pm2.44mV Tipo Arduino Due y ESP32 Plus STEAMakers. La resoluci\u00f3n es de 12 bits por lo que el n\u00famero de valores digitales posibles es: 2^{12} = 4096 2^{12} = 4096 . Para una tensi\u00f3n de 5V esto se traduce en que la precisi\u00f3n de la medida es de 5/4096 = 1.22mV = \\pm0.61mV 5/4096 = 1.22mV = \\pm0.61mV . En la imagen siguiente vemos el aspecto de una se\u00f1al anal\u00f3gica: Se\u00f1al anal\u00f3gica","title":"Circuitos digitales y anal\u00f3gicos"},{"location":"Tactividades/T_poten/#el-potenciometro_1","text":"En la imagen siguiente vemos el aspecto de un modelo concreto de potenci\u00f3metro as\u00ed como los s\u00edmbolos habituales del mismo. La numeraci\u00f3n indica lo siguiente: Terminales 1 y 3 son los contactos unidos a los extremos de la resistencia fija o resistencia total del potenci\u00f3metro. Terminal 2 es el contacto que va unido al cursor o parte m\u00f3vil que se desliza sobre la resistencia fija haciendo que la resistencia entre un terminal y el cursor var\u00ede en funci\u00f3n de la posici\u00f3n de este. Aspecto y s\u00edmbolo del potenci\u00f3metro La posici\u00f3n del cursor se determina de forma mec\u00e1nica y son adecuados para usarlos como elementos de control de tensi\u00f3n (conexi\u00f3n en serie) o de corriente (conexi\u00f3n en paralelo). Los potenci\u00f3metros del tipo que estamos viendo (existen de otros muchos tipos) tienen un funcionamiento en forma de rotaci\u00f3n con un \u00e1ngulo de unos 270 grados entre los puntos mas extremos.","title":"El potenci\u00f3metro"},{"location":"Tactividades/T_poten/#serial-plotter-datalogger","text":"Es otra funcionalidad relacionada con la comunicaci\u00f3n serie que nos permite visualizar informaci\u00f3n en forma de gr\u00e1fica en tiempo real. Adem\u00e1s el \u201cSerial Plotter\u201d implementa un sencillo datalogger con el que podemos ir grabando los datos para exportarlos posteriormente. En ArduinoBlocks existen bloques que nos permiten trabajar con el serial plotter. El serial plotter + datalogger se activa haciendo clic en la flecha a la derecha de Consola y tiene el aspecto que vemos en la imagen siguiente: Serial Plotter + Datalogger La funci\u00f3n de datalogger (registro de datos) la podemos activar desde el panel superior derecho y veremos un icono de tipo comecocos que va \u201ccomiendo\u201d datos mientras estamos recopilando los datos para su posterior exportaci\u00f3n. En la figura siguiente vemos su aspecto. Aspecto del Datalogger Cuando detenemos la grabaci\u00f3n o recopilaci\u00f3n de datos podremos descargar los archivo de datos en formato CSV (Comma Separated Values), generandose un archivo por cada serie de datos recogida, es decir, un archivo por cada variable que representemos en la gr\u00e1fica. Si superamos el n\u00famero de datos m\u00e1ximo seleccionado para registrar, se sobreescribir\u00e1n los datos m\u00e1s antiguos.","title":"Serial Plotter - Datalogger"},{"location":"Tactividades/T_poten/#mapeo","text":"Hemos indicado que las entradas anal\u00f3gicas trabajan con 10 o 12 bits, o sea valores comprendidos entre 0 y 1023 ( 2^{10} 2^{10} ) 0 y 4095 ( 2^{12} 2^{12} ) y tambi\u00e9n sabemos que las salidas digitales trabajan con 8 bits, o sea valores entre 0 y 255, por lo que si queremos combinar en nuestro programa entradas anal\u00f3gicas con salidas digitales debemos realizar un ajuste de escala en los datos. A este ajuste se le conoce como \"mapear\" y es un bloque disponible en el men\u00fa 'Matem\u00e1ticas' con el aspecto de la imagen siguiente: Bloque mapear","title":"Mapeo"},{"location":"Tactividades/T_pulsador/","text":"Bot\u00f3n pulsador \u00b6 Conceptos incluidos \u00b6 Sentencias condicionales El pulsador \u00b6 En la tabla siguiente vemos la simbolog\u00eda y algunos ejemplos del aspecto f\u00edsico de estos elementos. S\u00edmbolos y aspecto real de un pulsador Se trata de un dispositivo que es capaz de abrir o cerrar el paso de la corriente el\u00e9ctrica mientras permanece accionado, es decir, su funci\u00f3n no queda anclada como por ejemplo en los interruptores de la luz de casa, en donde el accionamiento permanece hasta que no se vuelve a accionar. En un pulsador, por contra, su activaci\u00f3n dura mientras lo mantenemos pulsado y vuelve a su estado de reposo en cuanto dejemos de pulsarlo. Mediante la configuraci\u00f3n adecuada podemos convertir un pulsador en un elemento de entrada a alg\u00fan pin de nuestra placa de control. Las configuraciones m\u00e1s b\u00e1sicas posibles con pulsadores las podemos ver en la imagen siguiente. Configuraci\u00f3n circuito elemental con pulsador La aplicaci\u00f3n de un pulsador para hacer algo requiere saber si este esta pulsado o no lo est\u00e1 y para ello vamos a necesitar de las sentencias condicionales. Sentencias condicionales \u00b6 Las sentencias condicionales son aquellas que nos permiten tomar decisiones en funci\u00f3n de si ocurre o no ocurre determinada cosa. En el caso de ArduinoBlocks estas las podemos encontrar en el bloque l\u00f3gica. Este bloque contiene los elementos que vemos en la imagen siguiente: Bloques de l\u00f3gica El funcionamiento es el siguiente: se eval\u00faa la condici\u00f3n que ponemos en \"si\" y si el resultado es verdadero, o sea condici\u00f3n cierta, se realizan las acciones que pongamos en \"hacer\" y si no es cierta dichas acciones no se realizan. En el apartado condici\u00f3n se pueden poner infinidad de factores como pueden ser el estado de sensores, realizar comparaciones, hacer operaciones matem\u00e1ticas, etc. L\u00f3gicamente el resultado de evaluar la condici\u00f3n debe ser verdadero o falso lo que se resuelve en el caso de la programaci\u00f3n en Arduino diciendo que si el resultado es 0, el resultado de la evaluaci\u00f3n es falso y si es 1 o cualquier otro valor es verdadero. Si hemos sido observadores hemos visto en los bloques \"si\" de \"L\u00f3gica\" un signo mas (+) en la parte superior izquierda tanto del condicional \"if\" como la del \"if ... else\" tal y como se destaca en la imagen siguiente. A\u00f1adir opciones else if Cada vez que pulsemos sobre el signo mas se a\u00f1adir\u00e1 una cl\u00e1usula \"else if\" a la principal y podemos a\u00f1adir tantas como necesitemos. Esta cl\u00e1usula nos va a permitir establecer una nueva condici\u00f3n.En la imagen siguiente vemos a\u00f1adidas dos para el caso de \"if ... else\". En la imagen observamos el c\u00f3digo equivalente y las distintas condiciones que se pueden establecer. Clausula if...else con dos else if El signo menos (-) que aparece en la imagen sirve para eliminar la correspondiente cl\u00e1usula \"else if\".","title":"Bot\u00f3n pulsador"},{"location":"Tactividades/T_pulsador/#boton-pulsador","text":"","title":"Bot\u00f3n pulsador"},{"location":"Tactividades/T_pulsador/#conceptos-incluidos","text":"Sentencias condicionales","title":"Conceptos incluidos"},{"location":"Tactividades/T_pulsador/#el-pulsador","text":"En la tabla siguiente vemos la simbolog\u00eda y algunos ejemplos del aspecto f\u00edsico de estos elementos. S\u00edmbolos y aspecto real de un pulsador Se trata de un dispositivo que es capaz de abrir o cerrar el paso de la corriente el\u00e9ctrica mientras permanece accionado, es decir, su funci\u00f3n no queda anclada como por ejemplo en los interruptores de la luz de casa, en donde el accionamiento permanece hasta que no se vuelve a accionar. En un pulsador, por contra, su activaci\u00f3n dura mientras lo mantenemos pulsado y vuelve a su estado de reposo en cuanto dejemos de pulsarlo. Mediante la configuraci\u00f3n adecuada podemos convertir un pulsador en un elemento de entrada a alg\u00fan pin de nuestra placa de control. Las configuraciones m\u00e1s b\u00e1sicas posibles con pulsadores las podemos ver en la imagen siguiente. Configuraci\u00f3n circuito elemental con pulsador La aplicaci\u00f3n de un pulsador para hacer algo requiere saber si este esta pulsado o no lo est\u00e1 y para ello vamos a necesitar de las sentencias condicionales.","title":"El pulsador"},{"location":"Tactividades/T_pulsador/#sentencias-condicionales","text":"Las sentencias condicionales son aquellas que nos permiten tomar decisiones en funci\u00f3n de si ocurre o no ocurre determinada cosa. En el caso de ArduinoBlocks estas las podemos encontrar en el bloque l\u00f3gica. Este bloque contiene los elementos que vemos en la imagen siguiente: Bloques de l\u00f3gica El funcionamiento es el siguiente: se eval\u00faa la condici\u00f3n que ponemos en \"si\" y si el resultado es verdadero, o sea condici\u00f3n cierta, se realizan las acciones que pongamos en \"hacer\" y si no es cierta dichas acciones no se realizan. En el apartado condici\u00f3n se pueden poner infinidad de factores como pueden ser el estado de sensores, realizar comparaciones, hacer operaciones matem\u00e1ticas, etc. L\u00f3gicamente el resultado de evaluar la condici\u00f3n debe ser verdadero o falso lo que se resuelve en el caso de la programaci\u00f3n en Arduino diciendo que si el resultado es 0, el resultado de la evaluaci\u00f3n es falso y si es 1 o cualquier otro valor es verdadero. Si hemos sido observadores hemos visto en los bloques \"si\" de \"L\u00f3gica\" un signo mas (+) en la parte superior izquierda tanto del condicional \"if\" como la del \"if ... else\" tal y como se destaca en la imagen siguiente. A\u00f1adir opciones else if Cada vez que pulsemos sobre el signo mas se a\u00f1adir\u00e1 una cl\u00e1usula \"else if\" a la principal y podemos a\u00f1adir tantas como necesitemos. Esta cl\u00e1usula nos va a permitir establecer una nueva condici\u00f3n.En la imagen siguiente vemos a\u00f1adidas dos para el caso de \"if ... else\". En la imagen observamos el c\u00f3digo equivalente y las distintas condiciones que se pueden establecer. Clausula if...else con dos else if El signo menos (-) que aparece en la imagen sirve para eliminar la correspondiente cl\u00e1usula \"else if\".","title":"Sentencias condicionales"},{"location":"Tactividades/T_sonido/","text":"El amplificador de potencia. Sonidos \u00b6 Conceptos incluidos \u00b6 Sonidos en Arduino El amplificador de potencia. Sonidos \u00b6 Antes de ver el amplificador propiamente dicho vamos a ver los tipos de zumbadores ya que arduino produce los sonidos en base a generar ondas cuadradas de diferentes frecuencia y el m\u00f3dulo trabaja de la misma forma pero incluyendo un amplificador y un altavoz, y al fin y al cabo un zumbador es un altavoz. El buzzer, zumbador o altavoz es un transductor electroac\u00fastico (convierte una se\u00f1al el\u00e9ctrica en una onda de sonido) que produce un determinado zumbido o sonido. Existen de tres tipos: Pasivos : no disponen de electr\u00f3nica interna, por lo que tenemos que proporcionar una se\u00f1al el\u00e9ctrica para conseguir el sonido deseado. Activos : disponen de un oscilador interno, por lo que \u00fanicamente tenemos que alimentar el dispositivo para que se produzca el sonido. M\u00f3dulos amplificados : disponen de un peque\u00f1o amplificador que entrega su salida a un altavoz. Uno de los par\u00e1metros que caracterizan a un sonido es su frecuencia de emisi\u00f3n, siendo la frecuencia el n\u00famero de veces que se repite por unidad de tiempo (segundo). La transmisi\u00f3n del sonido se realiza por ondas a trav\u00e9s en cualquier medio (s\u00f3lido, l\u00edquido o gaseoso) excepto en el vac\u00edo. La frecuencia de un sonido nos indica cuantos ciclos por segundo tiene una onda. En la imagen y la tabla siguientes vemos un dibujo con un fragmento de las teclas de un piano estando todo referido a una nota est\u00e1ndar, la nota \"La\" central que tiene una frecuencia de 440 Hz. Podemos ver la nota musical que reproduce, en las dos notaciones m\u00e1s comunes de los sonidos (Ingl\u00e9s: C D E F G A B, Alem\u00e1n: C D E F G A H, Espa\u00f1ol, italiano y franc\u00e9s: Do Re Mi Fa Sol La Si) y adem\u00e1s se encuentra la frecuencia que produce esa nota musical. Secci\u00f3n de piano y notas Zumbador pasivo \u00b6 Un zumbador o buzzer pasivo no es mas que un peque\u00f1o altavoz que nos sirve para convertir una se\u00f1al el\u00e9ctrica en una onda de sonido. Son dispositivos que no disponen de ning\u00fan tipo de electr\u00f3nica interna, por lo que tenemos que proporcionar una se\u00f1al el\u00e9ctrica para conseguir el sonido deseado. Normalmente estos dispositivos se incluyen en un m\u00f3dulo que incorpora un transistor y una resistencia de polarizaci\u00f3n del mismo para hacer funcionar al altavoz que act\u00faa como carga. Un buzzer se basa en un transductor piezoel\u00e9ctrico que es capaz de variar su volumen con el paso de la corriente el\u00e9ctrica, fen\u00f3meno que se aprovecha para hacer vibrar la membrana del altavoz. Esquem\u00e1ticamente vemos esto en la figura siguiente: Funcionamiento de un buzzer Zumbador activo \u00b6 Existe otro tipo de zumbador que incluye un oscilador que genera una frecuencia audible fija y que se conoce como zumbador pasivo y en realidad es el que de forma correcta se puede denominar como zumbador. Este es mucho mas sencillo de usar ya que basta con conectarlo a un pin digital y cuando pongamos a nivel alto este pin el zumbador generar\u00e1 su zumbido caracter\u00edstico durante el tiempo que establezcamos. Con este tipo de zumbador no se pueden generar melod\u00edas. Cuando est\u00e1 nuevo se distingue del zumbador pasivo o altavoz por la pegatina de protecci\u00f3n que lo acompa\u00f1a, pero esta hay que quitarla para oir el zumbido y sin ella es dif\u00edcil distinguir un tipo del otro, as\u00ed que en este caso deberemos crear un programa con alguna melod\u00eda y si no se reproduce correctamente es que tenemos conectado el zumbador activo en lugar del pasivo. Lo mejor es marcar alguno de los dos cuando podemos distinguirlos. Una buena idea puede ser utilizar la propia pegatina en el lateral del mismo. El zumbador activo tiene el aspecto que vemos en la figura siguiente: Aspecto del zumbador activo M\u00f3dulo amplificador \u00b6 El m\u00f3dulo amplificador de potencia KS0374 de keyestudio integra un potenci\u00f3metro para ajuste del volumen, un altavoz y el amplificador de audio 8002B. El chip es un amplificador de 2W clase AB capaz de entregar los 2W de potencia a una carga de tres ohmios con una distorsi\u00f3n menor al 10% a partir de una alimentaci\u00f3n de 5V. T\u00edpicamente el amplificador entrega en torno a los 2W para una carga de ocho ohmios. Lo mas apropiado es ajustar el volumen del sonido al m\u00ednimo antes de usarlo, para luego aumentarlo a voluntad, evitando as\u00ed sobresalto y que se estropee el altavoz. Sus par\u00e1metros principales son: Chip amplificador: SC8002B Tensi\u00f3n de alimentaci\u00f3n: 5V DC Consumo: \u2265500MA Potencia m\u00e1xima: 2W Temperatura de funcionamiento: de 0 a 40\u00b0 Volumen de sonido del altavoz: 80db En la figura siguiente vemos el aspecto que presenta el m\u00f3dulo. Aspecto del m\u00f3dulo Se puede observar que el altavoz es de membrana y bobina m\u00f3vil por lo que es algo similar a lo que vemos en la figura siguiente: Altavoz de bobina m\u00f3vil Bloques de programaci\u00f3n \u00b6 En la figura siguiente podemos ver los bloques disponibles para generar sonidos. Bloques para generar sonidos Los dos primeros bloques son sencillos de usar y nos centraremos un poco mas en los otros dos que nos permiten reproducir cualquier melod\u00eda RTTTL (del ingl\u00e9s, Ring Tone Text Transfer Language) y es el que vemos en la imagen siguiente: El bloque 'Reproducir RTTTL' bloque permite reproducir una melod\u00eda a partir de un texto con formato RTTTL, formato desarrollado por Nokia para ser usado para transferir tonos de llamada a tel\u00e9fonos m\u00f3viles. El formato RTTTL es una cadena dividida en tres secciones: nombre, valor predeterminado y datos. Por ejemplo, la siguiente cadena de texto se corresponde con la Intro de Donkey Kong: d=4,o=5,b=140:8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6 Lo \u00fanico que tenemos que hacer para reproducir la melod\u00eda es pegar esta cadena en la zona de texto del bloque. ArduinoBlocks nos suministra informaci\u00f3n y enlaces referentes al tema accediendo desde nuestro proyecto a herramientas y escogiendo RTTTL Info, tal y como vemos en la imagen siguiente: Acceso a RTTTL Info En la imagen siguiente tenemos desplegada la informaci\u00f3n que nos ofrece esta herramienta. Informaci\u00f3n RTTTL Tambi\u00e9n podemos acceder a esta informaci\u00f3n haciendo clic derecho sobre el bloque y escogiendo la opci\u00f3n \"Ayuda\" de entre las mostradas en la ventana emergente.","title":"M\u00f3dulo amplificador"},{"location":"Tactividades/T_sonido/#el-amplificador-de-potencia-sonidos","text":"","title":"El amplificador de potencia. Sonidos"},{"location":"Tactividades/T_sonido/#conceptos-incluidos","text":"Sonidos en Arduino","title":"Conceptos incluidos"},{"location":"Tactividades/T_sonido/#el-amplificador-de-potencia-sonidos_1","text":"Antes de ver el amplificador propiamente dicho vamos a ver los tipos de zumbadores ya que arduino produce los sonidos en base a generar ondas cuadradas de diferentes frecuencia y el m\u00f3dulo trabaja de la misma forma pero incluyendo un amplificador y un altavoz, y al fin y al cabo un zumbador es un altavoz. El buzzer, zumbador o altavoz es un transductor electroac\u00fastico (convierte una se\u00f1al el\u00e9ctrica en una onda de sonido) que produce un determinado zumbido o sonido. Existen de tres tipos: Pasivos : no disponen de electr\u00f3nica interna, por lo que tenemos que proporcionar una se\u00f1al el\u00e9ctrica para conseguir el sonido deseado. Activos : disponen de un oscilador interno, por lo que \u00fanicamente tenemos que alimentar el dispositivo para que se produzca el sonido. M\u00f3dulos amplificados : disponen de un peque\u00f1o amplificador que entrega su salida a un altavoz. Uno de los par\u00e1metros que caracterizan a un sonido es su frecuencia de emisi\u00f3n, siendo la frecuencia el n\u00famero de veces que se repite por unidad de tiempo (segundo). La transmisi\u00f3n del sonido se realiza por ondas a trav\u00e9s en cualquier medio (s\u00f3lido, l\u00edquido o gaseoso) excepto en el vac\u00edo. La frecuencia de un sonido nos indica cuantos ciclos por segundo tiene una onda. En la imagen y la tabla siguientes vemos un dibujo con un fragmento de las teclas de un piano estando todo referido a una nota est\u00e1ndar, la nota \"La\" central que tiene una frecuencia de 440 Hz. Podemos ver la nota musical que reproduce, en las dos notaciones m\u00e1s comunes de los sonidos (Ingl\u00e9s: C D E F G A B, Alem\u00e1n: C D E F G A H, Espa\u00f1ol, italiano y franc\u00e9s: Do Re Mi Fa Sol La Si) y adem\u00e1s se encuentra la frecuencia que produce esa nota musical. Secci\u00f3n de piano y notas","title":"El amplificador de potencia. Sonidos"},{"location":"Tactividades/T_sonido/#zumbador-pasivo","text":"Un zumbador o buzzer pasivo no es mas que un peque\u00f1o altavoz que nos sirve para convertir una se\u00f1al el\u00e9ctrica en una onda de sonido. Son dispositivos que no disponen de ning\u00fan tipo de electr\u00f3nica interna, por lo que tenemos que proporcionar una se\u00f1al el\u00e9ctrica para conseguir el sonido deseado. Normalmente estos dispositivos se incluyen en un m\u00f3dulo que incorpora un transistor y una resistencia de polarizaci\u00f3n del mismo para hacer funcionar al altavoz que act\u00faa como carga. Un buzzer se basa en un transductor piezoel\u00e9ctrico que es capaz de variar su volumen con el paso de la corriente el\u00e9ctrica, fen\u00f3meno que se aprovecha para hacer vibrar la membrana del altavoz. Esquem\u00e1ticamente vemos esto en la figura siguiente: Funcionamiento de un buzzer","title":"Zumbador pasivo"},{"location":"Tactividades/T_sonido/#zumbador-activo","text":"Existe otro tipo de zumbador que incluye un oscilador que genera una frecuencia audible fija y que se conoce como zumbador pasivo y en realidad es el que de forma correcta se puede denominar como zumbador. Este es mucho mas sencillo de usar ya que basta con conectarlo a un pin digital y cuando pongamos a nivel alto este pin el zumbador generar\u00e1 su zumbido caracter\u00edstico durante el tiempo que establezcamos. Con este tipo de zumbador no se pueden generar melod\u00edas. Cuando est\u00e1 nuevo se distingue del zumbador pasivo o altavoz por la pegatina de protecci\u00f3n que lo acompa\u00f1a, pero esta hay que quitarla para oir el zumbido y sin ella es dif\u00edcil distinguir un tipo del otro, as\u00ed que en este caso deberemos crear un programa con alguna melod\u00eda y si no se reproduce correctamente es que tenemos conectado el zumbador activo en lugar del pasivo. Lo mejor es marcar alguno de los dos cuando podemos distinguirlos. Una buena idea puede ser utilizar la propia pegatina en el lateral del mismo. El zumbador activo tiene el aspecto que vemos en la figura siguiente: Aspecto del zumbador activo","title":"Zumbador activo"},{"location":"Tactividades/T_sonido/#modulo-amplificador","text":"El m\u00f3dulo amplificador de potencia KS0374 de keyestudio integra un potenci\u00f3metro para ajuste del volumen, un altavoz y el amplificador de audio 8002B. El chip es un amplificador de 2W clase AB capaz de entregar los 2W de potencia a una carga de tres ohmios con una distorsi\u00f3n menor al 10% a partir de una alimentaci\u00f3n de 5V. T\u00edpicamente el amplificador entrega en torno a los 2W para una carga de ocho ohmios. Lo mas apropiado es ajustar el volumen del sonido al m\u00ednimo antes de usarlo, para luego aumentarlo a voluntad, evitando as\u00ed sobresalto y que se estropee el altavoz. Sus par\u00e1metros principales son: Chip amplificador: SC8002B Tensi\u00f3n de alimentaci\u00f3n: 5V DC Consumo: \u2265500MA Potencia m\u00e1xima: 2W Temperatura de funcionamiento: de 0 a 40\u00b0 Volumen de sonido del altavoz: 80db En la figura siguiente vemos el aspecto que presenta el m\u00f3dulo. Aspecto del m\u00f3dulo Se puede observar que el altavoz es de membrana y bobina m\u00f3vil por lo que es algo similar a lo que vemos en la figura siguiente: Altavoz de bobina m\u00f3vil","title":"M\u00f3dulo amplificador"},{"location":"Tactividades/T_sonido/#bloques-de-programacion","text":"En la figura siguiente podemos ver los bloques disponibles para generar sonidos. Bloques para generar sonidos Los dos primeros bloques son sencillos de usar y nos centraremos un poco mas en los otros dos que nos permiten reproducir cualquier melod\u00eda RTTTL (del ingl\u00e9s, Ring Tone Text Transfer Language) y es el que vemos en la imagen siguiente: El bloque 'Reproducir RTTTL' bloque permite reproducir una melod\u00eda a partir de un texto con formato RTTTL, formato desarrollado por Nokia para ser usado para transferir tonos de llamada a tel\u00e9fonos m\u00f3viles. El formato RTTTL es una cadena dividida en tres secciones: nombre, valor predeterminado y datos. Por ejemplo, la siguiente cadena de texto se corresponde con la Intro de Donkey Kong: d=4,o=5,b=140:8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6 Lo \u00fanico que tenemos que hacer para reproducir la melod\u00eda es pegar esta cadena en la zona de texto del bloque. ArduinoBlocks nos suministra informaci\u00f3n y enlaces referentes al tema accediendo desde nuestro proyecto a herramientas y escogiendo RTTTL Info, tal y como vemos en la imagen siguiente: Acceso a RTTTL Info En la imagen siguiente tenemos desplegada la informaci\u00f3n que nos ofrece esta herramienta. Informaci\u00f3n RTTTL Tambi\u00e9n podemos acceder a esta informaci\u00f3n haciendo clic derecho sobre el bloque y escogiendo la opci\u00f3n \"Ayuda\" de entre las mostradas en la ventana emergente.","title":"Bloques de programaci\u00f3n"},{"location":"Tactividades/T_teclado/","text":"El teclado matricial de 4x4 \u00b6 Conceptos incluidos \u00b6 Consola o monitor serie Teclado de 4x4 \u00b6 Tambi\u00e9n conocidos como keypad, generalmente nos vamos a encontrar con dos tipos de teclados de 4x4 matriciales, unos basados en botones cl\u00e1sicos y otros de tipo membrana. En la figura siguiente vemos ejemplos de los mismos. Teclados de 4x4 matriciales En el caso de la autocaravana se utiliza el de membrana, pero cualquiera de ellos se corresponde con un esquema de conexionado como el de la figura siguiente: Esquema conexiones teclados de 4x4 matriciales Detectar la pulsaci\u00f3n de una tecla concreta es totalmente similar a la lectura simple de un pulsador. En nuestro caso las filas van determinadas por los pines 5, 6, 7 y 8 del conector del teclado y las columnas por los pines 1, 2, 3 y 4. Por otro lado en el conector del teclado los pines son de izquierda a derecha, F1-F2-F3-F4-C1-C2-C3-C4. La correspondencia de pines de conexi\u00f3n con el esquema de conexionado y la tecla que corresponde lo vemos en la tabla siguiente: Tecla Pines en teclado Fila Columna Pines placa de control 1 8 / 4 1 1 A15 / A11 2 8 / 3 1 2 A15 / A10 3 8 / 2 1 3 A15 / A9 4 7 / 4 2 1 A14 / A11 5 7 / 3 2 2 A14 / A10 6 7 / 2 2 3 A14 / A9 7 6 / 4 3 1 A13 / A11 8 6 / 3 3 2 A13 / A10 9 6 / 2 3 3 A13 / A9 0 5 / 3 4 2 A12 / A10 A 8 / 1 1 4 A15 / A8 B 7 / 1 2 4 A14 / A8 C 6 / 2 3 4 A13 / A8 D 5 / 1 4 4 A12 / A8 * 5 / 4 4 1 A12 / A11 # 5 / 2 4 3 A12 / A9 Vemos la correspondencia de pines en la figura siguiente: Distribuci\u00f3n de pines en teclados de 4x4 matriciales En el men\u00fa 'Perif\u00e9ricos' tenemos los bloques necesarios para trabajar con este y otros teclados. En la figura siguiente vemos los bloques y una breve explicaci\u00f3n de los mismos. Bloques para keypad En 'Inicializar' es obligatorio poner el bloque de configuraci\u00f3n del teclado que estemos utilizando y poner correctamente los pines a los que lo conectamos. El terminal o consola serie \u00b6 Sirve para visualizar en un ordenador los datos recibidos a trav\u00e9s del puerto serie y en realidad es una aplicaci\u00f3n que controla las comunicaciones bidireccionales a trav\u00e9s de la UART integrada en el microcontrolador. Es muy importante tener siempre presente que el puerto serie es el que se utiliza para \"subir\" el firmware o programa a la placa, tarea que se realiza a trav\u00e9s de una aplicaci\u00f3n pregrabada en el microntrolador y que se denomina \"bootloader\". En ArduinoBlocks es posible usar la consola serie solamente si tenemos instalada y en funcionamiento la aplicaci\u00f3n ArduinoBlocks-Connector que es la encargada de establecer las comunicaciones locales de nuestra placa con las remotas de la aplicaci\u00f3n. En la imagen siguiente vemos el aspecto de la consola. Aspecto de la Consola en ArduinoBlocks IMPORTANTE A la hora de establecer una conexi\u00f3n serie los dos extremos que intervienen en la conexi\u00f3n (placa de control y ordenador) deben establecer el mismo valor en la velocidad de la conexi\u00f3n. Por defecto esta velocidad normalmente es de 9600 baudios o bits por segundo en el bloque inicializar y otras velocidades comunmente utilizadas son: 4800, 9600, 19200, 38400, 57600 y 115200. Es por lo tanto imprescindible incluir en el bloque \"Inicializar\" el bloque \"Iniciar\" y establecer la velocidad de comunicaci\u00f3n. El \u201cbootloader\u201d de Arduino normalmente tiene configurada la opci\u00f3n de resetear el microcontrolador cuando se inicia una conexi\u00f3n serie, por tanto si conectamos con la consola serie del PC hay que tener en cuenta que se reiniciar\u00e1 el programa y se ejecutar\u00e1 el bloque \u201cinicializar\". En las placas tipo ESP32 esta funci\u00f3n no est\u00e1 habilitada en el bootloader por lo que si es necesario el reset de la placa hay que hacerlo manualmente. Memoria EEPROM \u00b6 EEPROM son las siglas de \"Electrically Erasable Programmable Read-Only Memory\" que significan que es una memoria de solo lectura programable y borrable el\u00e9ctricamente. Es decir, una memoria EEPROM almacena bits de informaci\u00f3n mediante semiconductores y es capaz de mantener su estado entre ciclos de desconexi\u00f3n y conexi\u00f3n de la energ\u00eda. La EEPROM soporta hasta cien mil ciclos de escritura. Las placas tipo Arduino disponen de memoria EEPROM como memoria interna del microcontrolador que nos permite guardar informaci\u00f3n de configuraci\u00f3n de la aplicaci\u00f3n o valores de estado que se necesiten recuperar despu\u00e9s de un corte de la alimentaci\u00f3n el\u00e9ctrica. El microcontrolador de la placa de control de la autocaravana es un Arduino mega y tiene 4096 bytes (4 KB) de memoria EEPROM, sin embargo en ArduinoBlocks cada variable usada internamente es de tipo double y utiliza 4 bytes por lo que a la hora de almacenar o recuperar una variable de la memoria EEPROM s\u00f3lo podemos almacenar en 1024 posiciones (1024 x 4 = 4096 bytes). Vamos a pensar en esas posiciones de memoria como celdas de una tabla que pueden contener un valor de 8 bits, o sea entre 0 y 255. El aspecto lo podemos poner como en la gr\u00e1fica de la figura siguiente: Celdas de memoria La forma de guardar informaci\u00f3n en las celdas es indicar su direcci\u00f3n y el contenido tal y como contempla el bloque que vemos en la imagen siguiente: Bloque guardar datos en EEPROM Trabajando en ArduinoBlocks esto es mejor contemplarlo como vemos en la figura siguiente: Celdas de memoria en ArduinoBlocks Quedando cada direcci\u00f3n de memoria que gestiona ArduinoBlocks como un grupo de 4 bytes. Cuando guardamos informaci\u00f3n en memoria EEPROM tenemos que tener especial cuidado con gestionar correctamente las direcciones de memoria y evitar solapar informaci\u00f3n en las mismas.","title":"Teclado matricial de 4x4"},{"location":"Tactividades/T_teclado/#el-teclado-matricial-de-4x4","text":"","title":"El teclado matricial de 4x4"},{"location":"Tactividades/T_teclado/#conceptos-incluidos","text":"Consola o monitor serie","title":"Conceptos incluidos"},{"location":"Tactividades/T_teclado/#teclado-de-4x4","text":"Tambi\u00e9n conocidos como keypad, generalmente nos vamos a encontrar con dos tipos de teclados de 4x4 matriciales, unos basados en botones cl\u00e1sicos y otros de tipo membrana. En la figura siguiente vemos ejemplos de los mismos. Teclados de 4x4 matriciales En el caso de la autocaravana se utiliza el de membrana, pero cualquiera de ellos se corresponde con un esquema de conexionado como el de la figura siguiente: Esquema conexiones teclados de 4x4 matriciales Detectar la pulsaci\u00f3n de una tecla concreta es totalmente similar a la lectura simple de un pulsador. En nuestro caso las filas van determinadas por los pines 5, 6, 7 y 8 del conector del teclado y las columnas por los pines 1, 2, 3 y 4. Por otro lado en el conector del teclado los pines son de izquierda a derecha, F1-F2-F3-F4-C1-C2-C3-C4. La correspondencia de pines de conexi\u00f3n con el esquema de conexionado y la tecla que corresponde lo vemos en la tabla siguiente: Tecla Pines en teclado Fila Columna Pines placa de control 1 8 / 4 1 1 A15 / A11 2 8 / 3 1 2 A15 / A10 3 8 / 2 1 3 A15 / A9 4 7 / 4 2 1 A14 / A11 5 7 / 3 2 2 A14 / A10 6 7 / 2 2 3 A14 / A9 7 6 / 4 3 1 A13 / A11 8 6 / 3 3 2 A13 / A10 9 6 / 2 3 3 A13 / A9 0 5 / 3 4 2 A12 / A10 A 8 / 1 1 4 A15 / A8 B 7 / 1 2 4 A14 / A8 C 6 / 2 3 4 A13 / A8 D 5 / 1 4 4 A12 / A8 * 5 / 4 4 1 A12 / A11 # 5 / 2 4 3 A12 / A9 Vemos la correspondencia de pines en la figura siguiente: Distribuci\u00f3n de pines en teclados de 4x4 matriciales En el men\u00fa 'Perif\u00e9ricos' tenemos los bloques necesarios para trabajar con este y otros teclados. En la figura siguiente vemos los bloques y una breve explicaci\u00f3n de los mismos. Bloques para keypad En 'Inicializar' es obligatorio poner el bloque de configuraci\u00f3n del teclado que estemos utilizando y poner correctamente los pines a los que lo conectamos.","title":"Teclado de 4x4"},{"location":"Tactividades/T_teclado/#el-terminal-o-consola-serie","text":"Sirve para visualizar en un ordenador los datos recibidos a trav\u00e9s del puerto serie y en realidad es una aplicaci\u00f3n que controla las comunicaciones bidireccionales a trav\u00e9s de la UART integrada en el microcontrolador. Es muy importante tener siempre presente que el puerto serie es el que se utiliza para \"subir\" el firmware o programa a la placa, tarea que se realiza a trav\u00e9s de una aplicaci\u00f3n pregrabada en el microntrolador y que se denomina \"bootloader\". En ArduinoBlocks es posible usar la consola serie solamente si tenemos instalada y en funcionamiento la aplicaci\u00f3n ArduinoBlocks-Connector que es la encargada de establecer las comunicaciones locales de nuestra placa con las remotas de la aplicaci\u00f3n. En la imagen siguiente vemos el aspecto de la consola. Aspecto de la Consola en ArduinoBlocks IMPORTANTE A la hora de establecer una conexi\u00f3n serie los dos extremos que intervienen en la conexi\u00f3n (placa de control y ordenador) deben establecer el mismo valor en la velocidad de la conexi\u00f3n. Por defecto esta velocidad normalmente es de 9600 baudios o bits por segundo en el bloque inicializar y otras velocidades comunmente utilizadas son: 4800, 9600, 19200, 38400, 57600 y 115200. Es por lo tanto imprescindible incluir en el bloque \"Inicializar\" el bloque \"Iniciar\" y establecer la velocidad de comunicaci\u00f3n. El \u201cbootloader\u201d de Arduino normalmente tiene configurada la opci\u00f3n de resetear el microcontrolador cuando se inicia una conexi\u00f3n serie, por tanto si conectamos con la consola serie del PC hay que tener en cuenta que se reiniciar\u00e1 el programa y se ejecutar\u00e1 el bloque \u201cinicializar\". En las placas tipo ESP32 esta funci\u00f3n no est\u00e1 habilitada en el bootloader por lo que si es necesario el reset de la placa hay que hacerlo manualmente.","title":"El terminal o consola serie"},{"location":"Tactividades/T_teclado/#memoria-eeprom","text":"EEPROM son las siglas de \"Electrically Erasable Programmable Read-Only Memory\" que significan que es una memoria de solo lectura programable y borrable el\u00e9ctricamente. Es decir, una memoria EEPROM almacena bits de informaci\u00f3n mediante semiconductores y es capaz de mantener su estado entre ciclos de desconexi\u00f3n y conexi\u00f3n de la energ\u00eda. La EEPROM soporta hasta cien mil ciclos de escritura. Las placas tipo Arduino disponen de memoria EEPROM como memoria interna del microcontrolador que nos permite guardar informaci\u00f3n de configuraci\u00f3n de la aplicaci\u00f3n o valores de estado que se necesiten recuperar despu\u00e9s de un corte de la alimentaci\u00f3n el\u00e9ctrica. El microcontrolador de la placa de control de la autocaravana es un Arduino mega y tiene 4096 bytes (4 KB) de memoria EEPROM, sin embargo en ArduinoBlocks cada variable usada internamente es de tipo double y utiliza 4 bytes por lo que a la hora de almacenar o recuperar una variable de la memoria EEPROM s\u00f3lo podemos almacenar en 1024 posiciones (1024 x 4 = 4096 bytes). Vamos a pensar en esas posiciones de memoria como celdas de una tabla que pueden contener un valor de 8 bits, o sea entre 0 y 255. El aspecto lo podemos poner como en la gr\u00e1fica de la figura siguiente: Celdas de memoria La forma de guardar informaci\u00f3n en las celdas es indicar su direcci\u00f3n y el contenido tal y como contempla el bloque que vemos en la imagen siguiente: Bloque guardar datos en EEPROM Trabajando en ArduinoBlocks esto es mejor contemplarlo como vemos en la figura siguiente: Celdas de memoria en ArduinoBlocks Quedando cada direcci\u00f3n de memoria que gestiona ArduinoBlocks como un grupo de 4 bytes. Cuando guardamos informaci\u00f3n en memoria EEPROM tenemos que tener especial cuidado con gestionar correctamente las direcciones de memoria y evitar solapar informaci\u00f3n en las mismas.","title":"Memoria EEPROM"},{"location":"Tactividades/T_vapor/","text":"El sensor de Sensor de vapor (steam) \u00b6 Conceptos incluidos \u00b6 Anal\u00f3gico en placas tipo Arduino Sensor steam \u00b6 El sensor de vapor (steam en ingl\u00e9s) es un sensor anal\u00f3gico y puede utilizarse como un simple detector de agua de lluvia, interruptor de nivel de l\u00edquido e incluso como sensor t\u00e1ctil. Cuando aumenta la humedad en la superficie del sensor, aumenta el voltaje en su salida. En la figura siguiente vemos el aspecto que tiene este dispositivo. Aspecto del sensor de vapor (steam) Precauci\u00f3n: las piezas de conexi\u00f3n no son impermeables, luego no debemos sumergirlo en agua Su principio de funcionamiento se base en detectar la cantidad de agua mediante pistas paralelas de la PCB que est\u00e1n esta\u00f1adas pero expuestas. Cuanta m\u00e1s agua haya, m\u00e1s pistas (cables) se conectar\u00e1n entre si. El sensor es capaz de detectar vapor de agua y se puede utilizar como sensor de lluvia. Sus principales especificaciones son: Voltaje de funcionamiento: 3,3 V o 5 V. Consumo: <20mA Rango de temperatura de trabajo: \uff0d10 \u2103 a \uff0b 70 \u2103 Tipo de salida: se\u00f1al anal\u00f3gica S: se\u00f1al de salida anal\u00f3gica +: Alimentaci\u00f3n positiva (VCC) -\uff1a Alimentaci\u00f3n negativa o masa (GND) Anal\u00f3gico en placas tipo Arduino \u00b6 Las placas que basan su funcionamiento en microcontroladores trabajan solamente con valores digitales por lo que para trabajar con valores anal\u00f3gicos se deben utilizar t\u00e9cnicas que ya hemos ido introduciendo en apartados anteriores. Salidas anal\u00f3gicas \u00b6 Las placas tipo Arduino no tienen salidas anal\u00f3gicas, aunque si podemos en una salida digital imitar a una salida anal\u00f3gica mediante la t\u00e9cnica PWM (Pulse Width Modulation = Modulaci\u00f3n en Anchura de Pulso). Para el control PWM por hardware estas placas utilizan los Timers del microcontrolador junto con un registro comparador de forma que cuando el timer alcance el valor del registro se cambie el estado (valor de salida) para detener los Duty Cycles (ciclos de trabajo). Un timer puede atender a dos o tres salidas que pueden tener distintos Duty Cycles pero deben ser de la misma frecuencia. A continuaci\u00f3n hacemos un resumen de placas y cuales son sus pines PWM. Placas tipo UNO, Mini y Nano: disponen de 6 salidas PWM de 8 bits en los pines 3, 5, 6, 9, 10 y 11, que tendr\u00e1n un car\u00e1cter ~ delante del n\u00famero. Estas placas tienen 3 Timers de forma que el Timer0 atiendo a los pines 5 y 6, el Timer1 al 9 y 10 y el Timer2 al 3 y al 11. Placas tipo Mega: tiene 15 salidas PWM que est\u00e1n en los pines 2 al 13 y 46 al 44. La placa dispone 6 Timers de forma que el Timer0 atiende a los pines 4 y 13, el Timer1 al 11 y 12, el Timer2 al 9 y 10, el Timer3 al 2, 3 y 5, el Timer4 al 6, 7 y 8 y el Timer5 al 44, 45 y 46. En el caso de las placas UNO estos pines se caracterizan con el car\u00e1cter virgulilla (~) y en la Mega se indican expl\u00edcitamente del 2 al 13 pero no los 44, 45 y 46, como vemos en la figura siguiente: Pines con salida PWM Ya hemos indicado que PWM tiene una base digital, aunque la forma de su se\u00f1al se asemeja a una se\u00f1al anal\u00f3gica \"cuadrada\". PWM Permite mediante pulsos digitales ir variando la se\u00f1al para emular un sistema anal\u00f3gico, tal y como indica su nombre. Es decir, que PWM es el sistema por el que estas placas pueden trabajar con se\u00f1ales que no son totalmente anal\u00f3gicas, pero tampoco digitales de manera convencional. Para hacerlo posible mantienen una salida digital activa durante un tiempo espec\u00edfico o apagada, seg\u00fan interese en cada momento, lo que no se corresponde con un c\u00f3digo binario cuyos pulsos duran el mismo tiempo. En este tipo de se\u00f1ales PWM se mantiene una frecuencia constante de disparos de pulsos en el tiempo, pero se var\u00eda la anchura de estos pulsos. De hecho, se denomina Duty Cycle o ciclo de trabajo al tiempo que se mantiene en estado alto una se\u00f1al con respecto al total del ciclo. Es por ello que el par\u00e1metro Duty Cycle se proporciona en %. En la figura siguientes vemos esto expresado claramente. Duty Cycle o ciclo de trabajo Pines de entrada anal\u00f3gica \u00b6 Estos pines s\u00f3lo se pueden utilizar como entradas. Las entradas anal\u00f3gicas leen un voltaje entre 0 y 5V y a trav\u00e9s de un convertidor anal\u00f3gico a digital o ADC (Analog to Digital Converter) obtienen un valor proporcional a la se\u00f1al de entrada con una resoluci\u00f3n de 10 o 12 bits seg\u00fan la placa de que hablemos. Como ya vimos en otro apartado esta precisi\u00f3n para algunas placas es: Tipo Arduino Uno, Mini y Mega. La resoluci\u00f3n es de 10 bits por lo que el n\u00famero de valores digitales posibles es: 2^{10} = 1024 2^{10} = 1024 . Para una tensi\u00f3n de 5V esto se traduce en que la precisi\u00f3n de la medida es de 5/1024 = 4.88 mV = \u00b12.44 mV 5/1024 = 4.88 mV = \u00b12.44 mV . Tipo Arduino Due, familia de placas MKR y ESP32 Plus STEAMakers. La resoluci\u00f3n es de 12 bits por lo que el n\u00famero de valores digitales posibles es: 2^{12} = 4096 2^{12} = 4096 . Para una tensi\u00f3n de 5V esto se traduce en que la precisi\u00f3n de la medida es de 5/4096 = 1.22 mV = \u00b1 0.61 mV 5/4096 = 1.22 mV = \u00b1 0.61 mV . De forma gen\u00e9rica podemos expresar que: Resolucion = V_{ref}/(2^{N}-1) Resolucion = V_{ref}/(2^{N}-1) siendo V_{ref} V_{ref} la tensi\u00f3n de referencia para el convertidor ADC de la placa, que por defecto es el valor de la alimentaci\u00f3n y N el n\u00famero de bits o precisi\u00f3n del convertidor. Si necesitamos que el valor de V_{ref} V_{ref} sea diferente al de la alimentaci\u00f3n debemos recurrir al uso del pin AREF disponible en las placas. Vamos a expresar de forma gr\u00e1fica la conversi\u00f3n ADC y la relaci\u00f3n con el n\u00famero de bits. En la figura siguiente tenemos una se\u00f1ala anal\u00f3gica en forma de onda senoidal sobre la que se superpone un patr\u00f3n digital. Muestreo de poca precisi\u00f3n En la figura anterior observamos como en realidad lo que el microcontrolador junto con el convertidor hacen es aproximar la se\u00f1al digital a la anal\u00f3gica por medio de rect\u00e1ngulos o muestras. Cuanto mayor sea el n\u00famero de bits de resoluci\u00f3n del convertidor mas peque\u00f1os ser\u00e1n los rect\u00e1ngulos que se forman y mas se aproximar\u00e1 la se\u00f1al digital a la anal\u00f3gica. Es decir, cuanto mayor sea el n\u00famero de muestras mayor ser\u00e1 la aproximaci\u00f3n. En la figura siguiente vemos diferentes resoluciones aplicadas a una misma se\u00f1al anal\u00f3gica con indicaci\u00f3n de la resoluci\u00f3n. Muestreos de diferentes precisiones Resulta evidente que a mayor precisi\u00f3n o n\u00famero de bits mejor se\u00f1al convertida vamos a tener.","title":"Sensor de vapor (steam)"},{"location":"Tactividades/T_vapor/#el-sensor-de-sensor-de-vapor-steam","text":"","title":"El sensor de Sensor de vapor (steam)"},{"location":"Tactividades/T_vapor/#conceptos-incluidos","text":"Anal\u00f3gico en placas tipo Arduino","title":"Conceptos incluidos"},{"location":"Tactividades/T_vapor/#sensor-steam","text":"El sensor de vapor (steam en ingl\u00e9s) es un sensor anal\u00f3gico y puede utilizarse como un simple detector de agua de lluvia, interruptor de nivel de l\u00edquido e incluso como sensor t\u00e1ctil. Cuando aumenta la humedad en la superficie del sensor, aumenta el voltaje en su salida. En la figura siguiente vemos el aspecto que tiene este dispositivo. Aspecto del sensor de vapor (steam) Precauci\u00f3n: las piezas de conexi\u00f3n no son impermeables, luego no debemos sumergirlo en agua Su principio de funcionamiento se base en detectar la cantidad de agua mediante pistas paralelas de la PCB que est\u00e1n esta\u00f1adas pero expuestas. Cuanta m\u00e1s agua haya, m\u00e1s pistas (cables) se conectar\u00e1n entre si. El sensor es capaz de detectar vapor de agua y se puede utilizar como sensor de lluvia. Sus principales especificaciones son: Voltaje de funcionamiento: 3,3 V o 5 V. Consumo: <20mA Rango de temperatura de trabajo: \uff0d10 \u2103 a \uff0b 70 \u2103 Tipo de salida: se\u00f1al anal\u00f3gica S: se\u00f1al de salida anal\u00f3gica +: Alimentaci\u00f3n positiva (VCC) -\uff1a Alimentaci\u00f3n negativa o masa (GND)","title":"Sensor steam"},{"location":"Tactividades/T_vapor/#analogico-en-placas-tipo-arduino","text":"Las placas que basan su funcionamiento en microcontroladores trabajan solamente con valores digitales por lo que para trabajar con valores anal\u00f3gicos se deben utilizar t\u00e9cnicas que ya hemos ido introduciendo en apartados anteriores.","title":"Anal\u00f3gico en placas tipo Arduino"},{"location":"Tactividades/T_vapor/#salidas-analogicas","text":"Las placas tipo Arduino no tienen salidas anal\u00f3gicas, aunque si podemos en una salida digital imitar a una salida anal\u00f3gica mediante la t\u00e9cnica PWM (Pulse Width Modulation = Modulaci\u00f3n en Anchura de Pulso). Para el control PWM por hardware estas placas utilizan los Timers del microcontrolador junto con un registro comparador de forma que cuando el timer alcance el valor del registro se cambie el estado (valor de salida) para detener los Duty Cycles (ciclos de trabajo). Un timer puede atender a dos o tres salidas que pueden tener distintos Duty Cycles pero deben ser de la misma frecuencia. A continuaci\u00f3n hacemos un resumen de placas y cuales son sus pines PWM. Placas tipo UNO, Mini y Nano: disponen de 6 salidas PWM de 8 bits en los pines 3, 5, 6, 9, 10 y 11, que tendr\u00e1n un car\u00e1cter ~ delante del n\u00famero. Estas placas tienen 3 Timers de forma que el Timer0 atiendo a los pines 5 y 6, el Timer1 al 9 y 10 y el Timer2 al 3 y al 11. Placas tipo Mega: tiene 15 salidas PWM que est\u00e1n en los pines 2 al 13 y 46 al 44. La placa dispone 6 Timers de forma que el Timer0 atiende a los pines 4 y 13, el Timer1 al 11 y 12, el Timer2 al 9 y 10, el Timer3 al 2, 3 y 5, el Timer4 al 6, 7 y 8 y el Timer5 al 44, 45 y 46. En el caso de las placas UNO estos pines se caracterizan con el car\u00e1cter virgulilla (~) y en la Mega se indican expl\u00edcitamente del 2 al 13 pero no los 44, 45 y 46, como vemos en la figura siguiente: Pines con salida PWM Ya hemos indicado que PWM tiene una base digital, aunque la forma de su se\u00f1al se asemeja a una se\u00f1al anal\u00f3gica \"cuadrada\". PWM Permite mediante pulsos digitales ir variando la se\u00f1al para emular un sistema anal\u00f3gico, tal y como indica su nombre. Es decir, que PWM es el sistema por el que estas placas pueden trabajar con se\u00f1ales que no son totalmente anal\u00f3gicas, pero tampoco digitales de manera convencional. Para hacerlo posible mantienen una salida digital activa durante un tiempo espec\u00edfico o apagada, seg\u00fan interese en cada momento, lo que no se corresponde con un c\u00f3digo binario cuyos pulsos duran el mismo tiempo. En este tipo de se\u00f1ales PWM se mantiene una frecuencia constante de disparos de pulsos en el tiempo, pero se var\u00eda la anchura de estos pulsos. De hecho, se denomina Duty Cycle o ciclo de trabajo al tiempo que se mantiene en estado alto una se\u00f1al con respecto al total del ciclo. Es por ello que el par\u00e1metro Duty Cycle se proporciona en %. En la figura siguientes vemos esto expresado claramente. Duty Cycle o ciclo de trabajo","title":"Salidas anal\u00f3gicas"},{"location":"Tactividades/T_vapor/#pines-de-entrada-analogica","text":"Estos pines s\u00f3lo se pueden utilizar como entradas. Las entradas anal\u00f3gicas leen un voltaje entre 0 y 5V y a trav\u00e9s de un convertidor anal\u00f3gico a digital o ADC (Analog to Digital Converter) obtienen un valor proporcional a la se\u00f1al de entrada con una resoluci\u00f3n de 10 o 12 bits seg\u00fan la placa de que hablemos. Como ya vimos en otro apartado esta precisi\u00f3n para algunas placas es: Tipo Arduino Uno, Mini y Mega. La resoluci\u00f3n es de 10 bits por lo que el n\u00famero de valores digitales posibles es: 2^{10} = 1024 2^{10} = 1024 . Para una tensi\u00f3n de 5V esto se traduce en que la precisi\u00f3n de la medida es de 5/1024 = 4.88 mV = \u00b12.44 mV 5/1024 = 4.88 mV = \u00b12.44 mV . Tipo Arduino Due, familia de placas MKR y ESP32 Plus STEAMakers. La resoluci\u00f3n es de 12 bits por lo que el n\u00famero de valores digitales posibles es: 2^{12} = 4096 2^{12} = 4096 . Para una tensi\u00f3n de 5V esto se traduce en que la precisi\u00f3n de la medida es de 5/4096 = 1.22 mV = \u00b1 0.61 mV 5/4096 = 1.22 mV = \u00b1 0.61 mV . De forma gen\u00e9rica podemos expresar que: Resolucion = V_{ref}/(2^{N}-1) Resolucion = V_{ref}/(2^{N}-1) siendo V_{ref} V_{ref} la tensi\u00f3n de referencia para el convertidor ADC de la placa, que por defecto es el valor de la alimentaci\u00f3n y N el n\u00famero de bits o precisi\u00f3n del convertidor. Si necesitamos que el valor de V_{ref} V_{ref} sea diferente al de la alimentaci\u00f3n debemos recurrir al uso del pin AREF disponible en las placas. Vamos a expresar de forma gr\u00e1fica la conversi\u00f3n ADC y la relaci\u00f3n con el n\u00famero de bits. En la figura siguiente tenemos una se\u00f1ala anal\u00f3gica en forma de onda senoidal sobre la que se superpone un patr\u00f3n digital. Muestreo de poca precisi\u00f3n En la figura anterior observamos como en realidad lo que el microcontrolador junto con el convertidor hacen es aproximar la se\u00f1al digital a la anal\u00f3gica por medio de rect\u00e1ngulos o muestras. Cuanto mayor sea el n\u00famero de bits de resoluci\u00f3n del convertidor mas peque\u00f1os ser\u00e1n los rect\u00e1ngulos que se forman y mas se aproximar\u00e1 la se\u00f1al digital a la anal\u00f3gica. Es decir, cuanto mayor sea el n\u00famero de muestras mayor ser\u00e1 la aproximaci\u00f3n. En la figura siguiente vemos diferentes resoluciones aplicadas a una misma se\u00f1al anal\u00f3gica con indicaci\u00f3n de la resoluci\u00f3n. Muestreos de diferentes precisiones Resulta evidente que a mayor precisi\u00f3n o n\u00famero de bits mejor se\u00f1al convertida vamos a tener.","title":"Pines de entrada anal\u00f3gica"},{"location":"Tactividades/intro/","text":"Introducci\u00f3n \u00b6 Aunque hemos realizado el montaje completo del kit no lo vamos a programar de una sola vez, sino que vamos a plantear una serie de actividades que comenzar\u00e1n desde lo m\u00e1s b\u00e1sico hasta la programaci\u00f3n de todos los elementos, incluido el control remoto desde un smartphone. Nuestro lenguaje de programaci\u00f3n va a ser ArduinoBlocks, un lenguaje visual por bloques muy potente y f\u00e1cil de usar. Tambi\u00e9n se puede trabajar con el kit utilizando el IDE de Arduino o el lenguaje visual Mixly que podemos descargar de Keyestudio. En los enlaces siguientes podemos encontrar mas informaci\u00f3n respecto al uso del programa. Descripci\u00f3n r\u00e1pida del uso del Software ArduinoBlocks . Conceptos sobre el uso de Operadores en C++ . Manuales de ArduinoBlocks Teor\u00eda b\u00e1sica de IoT . \u00bfC\u00f3mo se trabaja con ArduinoBlocks? \u00b6 Para empezar a trabajar con ArduinoBlocks, es necesario registrarse y crear un nuevo usuario. Debemos acceder haciendo clic en el bot\u00f3n \"Iniciar sesi\u00f3n\" para despu\u00e9s, seleccionar la opci\u00f3n de nuevo usuario. En la figura vemos como acceder a la ventana de inicio de sesi\u00f3n. Acceso al inicio de sesi\u00f3n en ArduinoBlocks En la figura siguiente vemos la ventana de inicio de sesi\u00f3n. Inicio de sesi\u00f3n en ArduinoBlocks Seguidamente, se debe seleccionar \"Empezar un proyecto nuevo\". Como vemos en la Figura 3.1.3 nos aparecen tres opciones: proyecto personal, profesor o alumno. Empezar un proyecto nuevo Si escogemos el proyecto personal s\u00f3lo podremos acceder nosotros, pero despu\u00e9s lo podemos compartir si decidimos hacerlo p\u00fablico. En cambio, si seleccionamos el proyecto profesor, no se comienza un proyecto sino que se crea un c\u00f3digo para que los alumnos puedan inscribirse en el proyecto. De esta forma, el profesor puede supervisar las programaciones de sus estudiantes. Por \u00faltimo, la opci\u00f3n de alumno es para unirnos al proyecto planteado por el profesor. Para aprender mas sobre Usuarios Gestionados basta con acceder a la presentaci\u00f3n del enlace anterior. \u00bfC\u00f3mo es la interfaz de programaci\u00f3n de ArduinoBlocks? \u00b6 Una vez hemos escogido la opci\u00f3n de proyecto personal, nos pregunta qu\u00e9 placa estamos utilizando y qu\u00e9 nombre queremos dar a nuestro proyecto. A su vez, podemos a\u00f1adir informaci\u00f3n, como: descripci\u00f3n del proyecto, componentes que necesitamos y otras especificaciones en el apartado de comentarios. En nuestro caso escogeremos: Arduino Uno, tal y como vemos en la figura siguiente, donde se aconseja la forma de nombrar los proyectos relacionados con este tema. Tipo de placa y nombre del proyecto Una vez ponemos nombre, y aunque es opcional se recomienda cumplimentar los distintos apartados, y hacemos clic en el bot\u00f3n \u201cNuevo proyecto\u201d entramos en el nuevo proyecto, nos encontramos con la pantalla que vemos en la siguiente figura. Pantalla inicial de un proyecto Ya es posible guardar nuestros bloques favoritos de ArduinoBlocks en la mochila y llevarlos siempre con nosotros o usarla para compartir bloques entre nuestros proyectos. En este enlace tienes un video que lo explica de forma gr\u00e1fica. ArduinoBlocks Connector \u00b6 ArduinobBloks genera el c\u00f3digo de Arduino a partir de los bloques. El programa copia y sube nuestra programaci\u00f3n a la placa gracias a la aplicaci\u00f3n ArduinoBlocks Connector. Si no ejecutamos ArduinoBlocks Connector, podremos programar y acceder a la plataforma ArduionBlocks, pero no podremos subir nuestro programa a la placa. As\u00ed pues, es necesario instalarlo en nuestro ordenador, y ejecutarlo cuando hagamos uso de la plataforma. Actualmente (octubre de 2022), est\u00e1 disponible la versi\u00f3n 5 para estos sistemas operativos: Windows, Ubuntu, MacOS, Chromebook y Raspberry Pi, tal y como se indica en la figura que sigue. Disponibilidad de ArduinoBlocks para distintos sistemas operativos","title":"Introducci\u00f3n"},{"location":"Tactividades/intro/#introduccion","text":"Aunque hemos realizado el montaje completo del kit no lo vamos a programar de una sola vez, sino que vamos a plantear una serie de actividades que comenzar\u00e1n desde lo m\u00e1s b\u00e1sico hasta la programaci\u00f3n de todos los elementos, incluido el control remoto desde un smartphone. Nuestro lenguaje de programaci\u00f3n va a ser ArduinoBlocks, un lenguaje visual por bloques muy potente y f\u00e1cil de usar. Tambi\u00e9n se puede trabajar con el kit utilizando el IDE de Arduino o el lenguaje visual Mixly que podemos descargar de Keyestudio. En los enlaces siguientes podemos encontrar mas informaci\u00f3n respecto al uso del programa. Descripci\u00f3n r\u00e1pida del uso del Software ArduinoBlocks . Conceptos sobre el uso de Operadores en C++ . Manuales de ArduinoBlocks Teor\u00eda b\u00e1sica de IoT .","title":"Introducci\u00f3n"},{"location":"Tactividades/intro/#como-se-trabaja-con-arduinoblocks","text":"Para empezar a trabajar con ArduinoBlocks, es necesario registrarse y crear un nuevo usuario. Debemos acceder haciendo clic en el bot\u00f3n \"Iniciar sesi\u00f3n\" para despu\u00e9s, seleccionar la opci\u00f3n de nuevo usuario. En la figura vemos como acceder a la ventana de inicio de sesi\u00f3n. Acceso al inicio de sesi\u00f3n en ArduinoBlocks En la figura siguiente vemos la ventana de inicio de sesi\u00f3n. Inicio de sesi\u00f3n en ArduinoBlocks Seguidamente, se debe seleccionar \"Empezar un proyecto nuevo\". Como vemos en la Figura 3.1.3 nos aparecen tres opciones: proyecto personal, profesor o alumno. Empezar un proyecto nuevo Si escogemos el proyecto personal s\u00f3lo podremos acceder nosotros, pero despu\u00e9s lo podemos compartir si decidimos hacerlo p\u00fablico. En cambio, si seleccionamos el proyecto profesor, no se comienza un proyecto sino que se crea un c\u00f3digo para que los alumnos puedan inscribirse en el proyecto. De esta forma, el profesor puede supervisar las programaciones de sus estudiantes. Por \u00faltimo, la opci\u00f3n de alumno es para unirnos al proyecto planteado por el profesor. Para aprender mas sobre Usuarios Gestionados basta con acceder a la presentaci\u00f3n del enlace anterior.","title":"\u00bfC\u00f3mo se trabaja con ArduinoBlocks?"},{"location":"Tactividades/intro/#como-es-la-interfaz-de-programacion-de-arduinoblocks","text":"Una vez hemos escogido la opci\u00f3n de proyecto personal, nos pregunta qu\u00e9 placa estamos utilizando y qu\u00e9 nombre queremos dar a nuestro proyecto. A su vez, podemos a\u00f1adir informaci\u00f3n, como: descripci\u00f3n del proyecto, componentes que necesitamos y otras especificaciones en el apartado de comentarios. En nuestro caso escogeremos: Arduino Uno, tal y como vemos en la figura siguiente, donde se aconseja la forma de nombrar los proyectos relacionados con este tema. Tipo de placa y nombre del proyecto Una vez ponemos nombre, y aunque es opcional se recomienda cumplimentar los distintos apartados, y hacemos clic en el bot\u00f3n \u201cNuevo proyecto\u201d entramos en el nuevo proyecto, nos encontramos con la pantalla que vemos en la siguiente figura. Pantalla inicial de un proyecto Ya es posible guardar nuestros bloques favoritos de ArduinoBlocks en la mochila y llevarlos siempre con nosotros o usarla para compartir bloques entre nuestros proyectos. En este enlace tienes un video que lo explica de forma gr\u00e1fica.","title":"\u00bfC\u00f3mo es la interfaz de programaci\u00f3n de ArduinoBlocks?"},{"location":"Tactividades/intro/#arduinoblocks-connector","text":"ArduinobBloks genera el c\u00f3digo de Arduino a partir de los bloques. El programa copia y sube nuestra programaci\u00f3n a la placa gracias a la aplicaci\u00f3n ArduinoBlocks Connector. Si no ejecutamos ArduinoBlocks Connector, podremos programar y acceder a la plataforma ArduionBlocks, pero no podremos subir nuestro programa a la placa. As\u00ed pues, es necesario instalarlo en nuestro ordenador, y ejecutarlo cuando hagamos uso de la plataforma. Actualmente (octubre de 2022), est\u00e1 disponible la versi\u00f3n 5 para estos sistemas operativos: Windows, Ubuntu, MacOS, Chromebook y Raspberry Pi, tal y como se indica en la figura que sigue. Disponibilidad de ArduinoBlocks para distintos sistemas operativos","title":"ArduinoBlocks Connector"},{"location":"actividades/A_DHTxx/","text":"Actividades con el sensor DHT11 \u00b6 Actividad A022 \u00b6 Realizar un programa que muestre la temperatura y la humedad en el monitor serie. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A022 . Soluci\u00f3n A022 Actividad A023 \u00b6 Realizar un programa que trabaje con el sensor DHT11 y algunos de los bloques de texto. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A023 . Soluci\u00f3n A023 Esto nos generar\u00e1 algo como lo de la imagen siguiente en la consola: Consola que produce la actividad A023 Actividad A024 \u00b6 Realizar un programa que nos muestre el estado de confort seg\u00fan las explicaciones vista y la idea de un sem\u00e1foro que utilice los LEDs RGB para componer esos colores rojo, verde y amarillo. Para resolver la actividad vamos a necesitar varios bloques del men\u00fa \"L\u00f3gica\" y especialmente combinando funciones AND y OR m\u00faltiples. Si necesitamos, por ejemplo, aumentar el n\u00famero de operadores AND dentro de un bloque simplemente tenemos que combinarlo como vemos en la imagen siguiente, donde se han combinado cuatro bloques AND. Combinacion de 4 bloques AND El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A024 . Soluci\u00f3n A024 Propuestas \u00b6 Idear un m\u00e9todo para probar de forma completa la funcionalidad del programa de la actividad A024, aunque se requiera modificarlo. Tambi\u00e9n se pide explicar la misi\u00f3n de la funci\u00f3n \"limite-confort\" creada.","title":"Sensor DHTxx"},{"location":"actividades/A_DHTxx/#actividades-con-el-sensor-dht11","text":"","title":"Actividades con el sensor DHT11"},{"location":"actividades/A_DHTxx/#actividad-a022","text":"Realizar un programa que muestre la temperatura y la humedad en el monitor serie. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A022 . Soluci\u00f3n A022","title":"Actividad A022"},{"location":"actividades/A_DHTxx/#actividad-a023","text":"Realizar un programa que trabaje con el sensor DHT11 y algunos de los bloques de texto. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A023 . Soluci\u00f3n A023 Esto nos generar\u00e1 algo como lo de la imagen siguiente en la consola: Consola que produce la actividad A023","title":"Actividad A023"},{"location":"actividades/A_DHTxx/#actividad-a024","text":"Realizar un programa que nos muestre el estado de confort seg\u00fan las explicaciones vista y la idea de un sem\u00e1foro que utilice los LEDs RGB para componer esos colores rojo, verde y amarillo. Para resolver la actividad vamos a necesitar varios bloques del men\u00fa \"L\u00f3gica\" y especialmente combinando funciones AND y OR m\u00faltiples. Si necesitamos, por ejemplo, aumentar el n\u00famero de operadores AND dentro de un bloque simplemente tenemos que combinarlo como vemos en la imagen siguiente, donde se han combinado cuatro bloques AND. Combinacion de 4 bloques AND El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A024 . Soluci\u00f3n A024","title":"Actividad A024"},{"location":"actividades/A_DHTxx/#propuestas","text":"Idear un m\u00e9todo para probar de forma completa la funcionalidad del programa de la actividad A024, aunque se requiera modificarlo. Tambi\u00e9n se pide explicar la misi\u00f3n de la funci\u00f3n \"limite-confort\" creada.","title":"Propuestas"},{"location":"actividades/A_LCD/","text":"Actividades con la LCD1602 \u00b6 Actividad A020 \u00b6 En esta actividad vamos a mostrar una serie de texto en la LCD a modo de introducci\u00f3n a este elemento. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A020 . Soluci\u00f3n A020 Actividad A021 \u00b6 Realizar un control de iluminaci\u00f3n de los LEDs RGB de los faros mediante PWM y mostrar por pantalla el valor de la iluminaci\u00f3n en cada instante. Se realizar\u00e1 el control desde el m\u00ednimo de iluminaci\u00f3n al m\u00e1ximo y cuando se alcance el m\u00e1ximo bajamos otra vez a m\u00ednimo. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A021 . Soluci\u00f3n A021 Propuestas \u00b6 Mostrar en la LCD los textos Rob\u00f3tica + dom\u00f3tica creando para ello el s\u00edmbolo necesario para acentuar la letra o (\u00f3). Repetir la actividad A021 cambian el color a otro cualquiera como rojo, verde o azul. Realizar la actividad anterior pero con colores que mezclan los b\u00e1sicos. Hacer un programa que la subida de brillo la haga en un color y la bajada en otro diferente.","title":"Pantalla LCD I2C"},{"location":"actividades/A_LCD/#actividades-con-la-lcd1602","text":"","title":"Actividades con la LCD1602"},{"location":"actividades/A_LCD/#actividad-a020","text":"En esta actividad vamos a mostrar una serie de texto en la LCD a modo de introducci\u00f3n a este elemento. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A020 . Soluci\u00f3n A020","title":"Actividad A020"},{"location":"actividades/A_LCD/#actividad-a021","text":"Realizar un control de iluminaci\u00f3n de los LEDs RGB de los faros mediante PWM y mostrar por pantalla el valor de la iluminaci\u00f3n en cada instante. Se realizar\u00e1 el control desde el m\u00ednimo de iluminaci\u00f3n al m\u00e1ximo y cuando se alcance el m\u00e1ximo bajamos otra vez a m\u00ednimo. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A021 . Soluci\u00f3n A021","title":"Actividad A021"},{"location":"actividades/A_LCD/#propuestas","text":"Mostrar en la LCD los textos Rob\u00f3tica + dom\u00f3tica creando para ello el s\u00edmbolo necesario para acentuar la letra o (\u00f3). Repetir la actividad A021 cambian el color a otro cualquiera como rojo, verde o azul. Realizar la actividad anterior pero con colores que mezclan los b\u00e1sicos. Hacer un programa que la subida de brillo la haga en un color y la bajada en otro diferente.","title":"Propuestas"},{"location":"actividades/A_LED/","text":"Actividades con el diodos LED \u00b6 Actividad A001 \u00b6 En esta actividad encenderemos y apagaremos cada dos segundos el led blanco que tenemos conectado al pin D13. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A001 . Soluci\u00f3n A001 Actividad A002 \u00b6 En esta actividad apagaremos y encenderemos de forma progresiva el LED blanco que tenemos conectado en D13. Utilizaremos la t\u00e9cnica del PWM que ya viene implementada para ese pin y que haremos con un contador y un decontador. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A002 . Soluci\u00f3n A002 Actividad A003 \u00b6 Realizar 4 intermitencias con el LED con esperas de 500ms y 8 intermitencias con esperas de 150ms y tras esto apagar el LED durante 3 segundos para volver a iniciar el proceso. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A003 . Soluci\u00f3n A003 Propuestas \u00b6 Cambiar los tiempos de la actividad A001 para que el parpadeo sea m\u00e1s r\u00e1pido, mas lento y que los tiempos de encendido y apagado no coincidan. Cambiar el incremento en los bucles del la actividad A002 de forma que sea el mismo en ambos y diferente en cada caso.","title":"El diodo LED"},{"location":"actividades/A_LED/#actividades-con-el-diodos-led","text":"","title":"Actividades con el diodos LED"},{"location":"actividades/A_LED/#actividad-a001","text":"En esta actividad encenderemos y apagaremos cada dos segundos el led blanco que tenemos conectado al pin D13. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A001 . Soluci\u00f3n A001","title":"Actividad A001"},{"location":"actividades/A_LED/#actividad-a002","text":"En esta actividad apagaremos y encenderemos de forma progresiva el LED blanco que tenemos conectado en D13. Utilizaremos la t\u00e9cnica del PWM que ya viene implementada para ese pin y que haremos con un contador y un decontador. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A002 . Soluci\u00f3n A002","title":"Actividad A002"},{"location":"actividades/A_LED/#actividad-a003","text":"Realizar 4 intermitencias con el LED con esperas de 500ms y 8 intermitencias con esperas de 150ms y tras esto apagar el LED durante 3 segundos para volver a iniciar el proceso. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A003 . Soluci\u00f3n A003","title":"Actividad A003"},{"location":"actividades/A_LED/#propuestas","text":"Cambiar los tiempos de la actividad A001 para que el parpadeo sea m\u00e1s r\u00e1pido, mas lento y que los tiempos de encendido y apagado no coincidan. Cambiar el incremento en los bucles del la actividad A002 de forma que sea el mismo en ambos y diferente en cada caso.","title":"Propuestas"},{"location":"actividades/A_PIR/","text":"Actividades con el sensor de movimiento PIR \u00b6 Actividad A017 \u00b6 Vamos a crear un sencillo programa en el que guardamos el estado del sensor PIR en una variable y lo mostramos en el monitor serie o consola. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A017 . Soluci\u00f3n A017 El resultado en consola lo vemos en la imagen siguiente, donde el 1 representa el estado True o verdadero e indica que el sensor ha detectado una presencia. El 0 representa el estado False o falso. Resultado en consola de A018 Actividad A018 \u00b6 Crear un programa que encienda la luz interior de la autocaravana cuando se detecta una presencia con el PIR. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A018 . Soluci\u00f3n A018 Actividad A019 \u00b6 En esta actividad vamos a hacer que cuando el sensor PIR detecte una presencia suene una alarma ac\u00fastica en el amplificador de sonido y que alternativamente parpadee el diodo LED interior. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A019 . Soluci\u00f3n A019 Propuestas \u00b6 Hacer el programa del punto 2.- Tiempo transcurrido del apartado bloques de tiempo y comprobar su funcionamiento. Repetir el ejercicio anterior esta vez con bloques 'Ejecutar cada'. Repetir la actividad A019 haciendo parpadear los faros de la autocaravana. Crear un programa que active y desactive la alarma a partir de una contrase\u00f1a memorizada y que introducimos por teclado.","title":"Sensor de movimiento PIR"},{"location":"actividades/A_PIR/#actividades-con-el-sensor-de-movimiento-pir","text":"","title":"Actividades con el sensor de movimiento PIR"},{"location":"actividades/A_PIR/#actividad-a017","text":"Vamos a crear un sencillo programa en el que guardamos el estado del sensor PIR en una variable y lo mostramos en el monitor serie o consola. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A017 . Soluci\u00f3n A017 El resultado en consola lo vemos en la imagen siguiente, donde el 1 representa el estado True o verdadero e indica que el sensor ha detectado una presencia. El 0 representa el estado False o falso. Resultado en consola de A018","title":"Actividad A017"},{"location":"actividades/A_PIR/#actividad-a018","text":"Crear un programa que encienda la luz interior de la autocaravana cuando se detecta una presencia con el PIR. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A018 . Soluci\u00f3n A018","title":"Actividad A018"},{"location":"actividades/A_PIR/#actividad-a019","text":"En esta actividad vamos a hacer que cuando el sensor PIR detecte una presencia suene una alarma ac\u00fastica en el amplificador de sonido y que alternativamente parpadee el diodo LED interior. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A019 . Soluci\u00f3n A019","title":"Actividad A019"},{"location":"actividades/A_PIR/#propuestas","text":"Hacer el programa del punto 2.- Tiempo transcurrido del apartado bloques de tiempo y comprobar su funcionamiento. Repetir el ejercicio anterior esta vez con bloques 'Ejecutar cada'. Repetir la actividad A019 haciendo parpadear los faros de la autocaravana. Crear un programa que active y desactive la alarma a partir de una contrase\u00f1a memorizada y que introducimos por teclado.","title":"Propuestas"},{"location":"actividades/A_RGB/","text":"Actividades con los LEDs RGB \u00b6 Actividad A004 \u00b6 En esta actividad encenderemos y apagaremos cada dos segundos cada uno de los LEDs conectados a los pines D3, D4 y D5 correspondientes a los colores rojo, azul y verde respectivamente. Recordemos que los LEDs RGB son en nuestro caso de \u00e1nodo com\u00fan. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A004 . Soluci\u00f3n A004 Actividad A005 \u00b6 Realizar un programa que nos muestre los tres colores primarios, rojo, verde y azul, a partir del bloque con el valor num\u00e9rico de cada color y tras mostrar el azul que permanezcan un segundo apagados. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A005 . Soluci\u00f3n A005 Actividad A006 \u00b6 Hacer un programa que haga parpadear el LED interior y los de los faros cada uno en una multitarea con tiempos de espera diferentes de un segundo y 600ms. El color de los faros lo establecemos com mas nos guste, en blanco en el ejemplo. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A006 . Soluci\u00f3n A006 Actividad A007 \u00b6 Repetir la actividad A006 pero en esta ocasi\u00f3n el color de los faros ser\u00e1 aleatorio. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A007 . Soluci\u00f3n A007 Propuestas \u00b6 A partir de la idea de la actividad A004 hacer un programa que muestre sucesivamente los siguientes colores: magenta o violeta, c\u00edan o azul claro, amarillo y blanco. Ay\u00fadate del gr\u00e1fico que muestra el modelo aditivo de colores que hay al principio de la teor\u00eda. Repetir la actividad A004 utilizando los bloques espec\u00edficos LED RGB que utiliza la paleta de colores. Realizar un programa que muestre de manera secuencial los colores del arco\u00edris en el orden que vemos en la imagen siguiente a intervalos de un segundo. Colores del arcoiris Realizar un programa que en una secuencia infinita haga que cambien los faros de color de forma aleatoria estableciendo una pausa entre cambios lo mas peque\u00f1a posible pero que nos permita apreciar la psicodelia que se crea (100ms puede ser un valor aceptable).","title":"El diodo LED RGB"},{"location":"actividades/A_RGB/#actividades-con-los-leds-rgb","text":"","title":"Actividades con los LEDs RGB"},{"location":"actividades/A_RGB/#actividad-a004","text":"En esta actividad encenderemos y apagaremos cada dos segundos cada uno de los LEDs conectados a los pines D3, D4 y D5 correspondientes a los colores rojo, azul y verde respectivamente. Recordemos que los LEDs RGB son en nuestro caso de \u00e1nodo com\u00fan. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A004 . Soluci\u00f3n A004","title":"Actividad A004"},{"location":"actividades/A_RGB/#actividad-a005","text":"Realizar un programa que nos muestre los tres colores primarios, rojo, verde y azul, a partir del bloque con el valor num\u00e9rico de cada color y tras mostrar el azul que permanezcan un segundo apagados. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A005 . Soluci\u00f3n A005","title":"Actividad A005"},{"location":"actividades/A_RGB/#actividad-a006","text":"Hacer un programa que haga parpadear el LED interior y los de los faros cada uno en una multitarea con tiempos de espera diferentes de un segundo y 600ms. El color de los faros lo establecemos com mas nos guste, en blanco en el ejemplo. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A006 . Soluci\u00f3n A006","title":"Actividad A006"},{"location":"actividades/A_RGB/#actividad-a007","text":"Repetir la actividad A006 pero en esta ocasi\u00f3n el color de los faros ser\u00e1 aleatorio. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A007 . Soluci\u00f3n A007","title":"Actividad A007"},{"location":"actividades/A_RGB/#propuestas","text":"A partir de la idea de la actividad A004 hacer un programa que muestre sucesivamente los siguientes colores: magenta o violeta, c\u00edan o azul claro, amarillo y blanco. Ay\u00fadate del gr\u00e1fico que muestra el modelo aditivo de colores que hay al principio de la teor\u00eda. Repetir la actividad A004 utilizando los bloques espec\u00edficos LED RGB que utiliza la paleta de colores. Realizar un programa que muestre de manera secuencial los colores del arco\u00edris en el orden que vemos en la imagen siguiente a intervalos de un segundo. Colores del arcoiris Realizar un programa que en una secuencia infinita haga que cambien los faros de color de forma aleatoria estableciendo una pausa entre cambios lo mas peque\u00f1a posible pero que nos permita apreciar la psicodelia que se crea (100ms puede ser un valor aceptable).","title":"Propuestas"},{"location":"actividades/A_TEMT6000/","text":"Actividades con el sensor de luz ambiental \u00b6 Actividad A026 \u00b6 Vamos a leer los datos del sensor y mostrarlos a trav\u00e9s de la consola serie. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A026 . Soluci\u00f3n A026 El programa genera una salida por consola como la de la figura siguiente: Consola A026 Actividad A027 \u00b6 Implementar el encendido autom\u00e1tico del LED interior cuando el nivel de iluminaci\u00f3n est\u00e1 por debajo del valor 300. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A027 . Soluci\u00f3n A027 Propuestas \u00b6 Repetir la actividad A026 mostrando los valores en la LCD. Repetir la actividad A027 trabajando con porcentajes.","title":"Sensor de luz ambiental"},{"location":"actividades/A_TEMT6000/#actividades-con-el-sensor-de-luz-ambiental","text":"","title":"Actividades con el sensor de luz ambiental"},{"location":"actividades/A_TEMT6000/#actividad-a026","text":"Vamos a leer los datos del sensor y mostrarlos a trav\u00e9s de la consola serie. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A026 . Soluci\u00f3n A026 El programa genera una salida por consola como la de la figura siguiente: Consola A026","title":"Actividad A026"},{"location":"actividades/A_TEMT6000/#actividad-a027","text":"Implementar el encendido autom\u00e1tico del LED interior cuando el nivel de iluminaci\u00f3n est\u00e1 por debajo del valor 300. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A027 . Soluci\u00f3n A027","title":"Actividad A027"},{"location":"actividades/A_TEMT6000/#propuestas","text":"Repetir la actividad A026 mostrando los valores en la LCD. Repetir la actividad A027 trabajando con porcentajes.","title":"Propuestas"},{"location":"actividades/A_neo/","text":"","title":"LEDs RGB direccionables"},{"location":"actividades/A_poten/","text":"Actividades con el potenci\u00f3metro \u00b6 Actividad A025 \u00b6 1. consola \u00b6 Vamos a guardar los datos le\u00eddos del potenci\u00f3metro en una variable y mostrarlos a trav\u00e9s de la consola serie. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A025. Consola . Soluci\u00f3n A025. Consola Si cargamos el programa en nuestra placa y posteriormente activamos la consola y conectamos ArduinoBlocks con nuestro ordenador podemos ver un resultado similar al de la imagen siguiente que se corresponde con variaciones de extremo a extremo del potenci\u00f3metro. Aspecto de la consola 2. Mapeo de datos \u00b6 Vamos a modificar el programa de la parte 1 del reto para mapear los datos antes de enviarlos a la consola serie. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A025. Mapeo de datos . Soluci\u00f3n A025. Mapeo de datos La consola mostrar\u00e1 un resultado similar al de la imagen siguiente que se corresponde con variaciones de extremo a extremo del potenci\u00f3metro. Aspecto de la consola 3. Serial plotter \u00b6 Vamos ahora a mapear y mostrar los datos le\u00eddos del potenci\u00f3metro en el Serial Plotter. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A025. Serial plotter . Soluci\u00f3n A025. Mapeo de datos Si activamos el Serial Plotter y vamos variando el potenciometro veremos el resultado en el mismo, obteniendo algo similar a la imagen siguiente: Aspecto del serial plotter 4. Datalogger \u00b6 Vamos ahora a activar el \"comecocos\" o datalogger, dejarlo unos instantes que registre datos, pararlo, guardar el archivo y abrirlo desde la hoja de c\u00e1lculo LibreOffice Calc para ver los resultados. El programa final es el mismo que el de la actividad anterior. En la animaci\u00f3n siguiente vemos el proceso de puesta en marcha y parada del datalogger. En el enlace tenemos el archivo CSV generado Archivo CSV . Soluci\u00f3n A025. Datalogger En la figura siguiente vemos el resultado de cargar ese archivo en Calc. Se ha a\u00f1adido una gr\u00e1fica para observar como es totalmente similar a la que vemos en el datalogger. Los datos y la gr\u00e1fica se han dejado tal cual son de inicio y no se ha entrado en mas detalles de edici\u00f3n de los mismos. Archivo CSV en Calc Propuestas \u00b6 Repetir la actividad A025 configurando el bloque potenci\u00f3metro en porcentaje. Realizar un control de los faros de la autocaravana mediante el potenci\u00f3metro dividiendo el rango total en 8 partes tal y como vemos en la tabla siguiente: Color Rango R G B Rojo 0 a 127 255 0 0 Verde 128 a 255 0 255 0 Azul 256 a 384 0 0 255 Amarillo 385 a 512 255 255 0 Cian 513 a 640 0 255 255 Magenta 641 a 768 255 0 255 Blanco 769 a 896 255 255 255 Naranja 897 a 1023 255 127 0 Repetir la actividad anterior mostrando el resultado por la consola. Realizar un programa con el sensor DHT11 que muestre los datos de temperatura y humedad en el serial plotter. Hacer un registro de datos con el datalogger y exportar los registros realizados.","title":"El potenci\u00f3metro"},{"location":"actividades/A_poten/#actividades-con-el-potenciometro","text":"","title":"Actividades con el potenci\u00f3metro"},{"location":"actividades/A_poten/#actividad-a025","text":"","title":"Actividad A025"},{"location":"actividades/A_poten/#1-consola","text":"Vamos a guardar los datos le\u00eddos del potenci\u00f3metro en una variable y mostrarlos a trav\u00e9s de la consola serie. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A025. Consola . Soluci\u00f3n A025. Consola Si cargamos el programa en nuestra placa y posteriormente activamos la consola y conectamos ArduinoBlocks con nuestro ordenador podemos ver un resultado similar al de la imagen siguiente que se corresponde con variaciones de extremo a extremo del potenci\u00f3metro. Aspecto de la consola","title":"1. consola"},{"location":"actividades/A_poten/#2-mapeo-de-datos","text":"Vamos a modificar el programa de la parte 1 del reto para mapear los datos antes de enviarlos a la consola serie. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A025. Mapeo de datos . Soluci\u00f3n A025. Mapeo de datos La consola mostrar\u00e1 un resultado similar al de la imagen siguiente que se corresponde con variaciones de extremo a extremo del potenci\u00f3metro. Aspecto de la consola","title":"2. Mapeo de datos"},{"location":"actividades/A_poten/#3-serial-plotter","text":"Vamos ahora a mapear y mostrar los datos le\u00eddos del potenci\u00f3metro en el Serial Plotter. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A025. Serial plotter . Soluci\u00f3n A025. Mapeo de datos Si activamos el Serial Plotter y vamos variando el potenciometro veremos el resultado en el mismo, obteniendo algo similar a la imagen siguiente: Aspecto del serial plotter","title":"3. Serial plotter"},{"location":"actividades/A_poten/#4-datalogger","text":"Vamos ahora a activar el \"comecocos\" o datalogger, dejarlo unos instantes que registre datos, pararlo, guardar el archivo y abrirlo desde la hoja de c\u00e1lculo LibreOffice Calc para ver los resultados. El programa final es el mismo que el de la actividad anterior. En la animaci\u00f3n siguiente vemos el proceso de puesta en marcha y parada del datalogger. En el enlace tenemos el archivo CSV generado Archivo CSV . Soluci\u00f3n A025. Datalogger En la figura siguiente vemos el resultado de cargar ese archivo en Calc. Se ha a\u00f1adido una gr\u00e1fica para observar como es totalmente similar a la que vemos en el datalogger. Los datos y la gr\u00e1fica se han dejado tal cual son de inicio y no se ha entrado en mas detalles de edici\u00f3n de los mismos. Archivo CSV en Calc","title":"4. Datalogger"},{"location":"actividades/A_poten/#propuestas","text":"Repetir la actividad A025 configurando el bloque potenci\u00f3metro en porcentaje. Realizar un control de los faros de la autocaravana mediante el potenci\u00f3metro dividiendo el rango total en 8 partes tal y como vemos en la tabla siguiente: Color Rango R G B Rojo 0 a 127 255 0 0 Verde 128 a 255 0 255 0 Azul 256 a 384 0 0 255 Amarillo 385 a 512 255 255 0 Cian 513 a 640 0 255 255 Magenta 641 a 768 255 0 255 Blanco 769 a 896 255 255 255 Naranja 897 a 1023 255 127 0 Repetir la actividad anterior mostrando el resultado por la consola. Realizar un programa con el sensor DHT11 que muestre los datos de temperatura y humedad en el serial plotter. Hacer un registro de datos con el datalogger y exportar los registros realizados.","title":"Propuestas"},{"location":"actividades/A_pulsador/","text":"Actividades con bot\u00f3n pulsador \u00b6 Actividad A008 \u00b6 Vamos a hacer que cuando accionamos el pulsador conectado al pin D2 se enciendan los faros de la autocaravana y cuando lo soltemos que se apaguen. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A008 . Soluci\u00f3n A008 Actividad A009 \u00b6 Vamos a hacer un programa que al accionar el pulsador se enciendan los faros de la autocaravana y el LED blanco interior y que permanezcan encendidos hasta que no pulsemos dos veces mas (3 pulsaciones en total), en cuyo caso se apagar\u00e1n. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A009 . Soluci\u00f3n A009 Actividad A010 \u00b6 Partiendo del alfabeto Morse y haciendo el equivalente directo a se\u00f1al con luz vamos a hacer un programa que al accionar el pulsador se enciendan los faros durante tiempos cortos y largos para emitir se\u00f1ales en este c\u00f3digo. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A010 . Soluci\u00f3n A010 En la figura siguiente vemos el alfabeto Morse. Alfabeto Morse Propuestas \u00b6 Resolver la actividad A008 de forma que el funcionamiento sea al contrario, es decir, que los faros est\u00e9n siempre encendidos y al accionar el pulsador se apaguen. Hacer un programa que al accionar el pulsador los faros de la autocaravana emitan la se\u00f1al SOS Morse de forma indefinida a intervalos de tres segundos hasta que se vuelva a accionar el pulsador.","title":"Bot\u00f3n pulsador"},{"location":"actividades/A_pulsador/#actividades-con-boton-pulsador","text":"","title":"Actividades con bot\u00f3n pulsador"},{"location":"actividades/A_pulsador/#actividad-a008","text":"Vamos a hacer que cuando accionamos el pulsador conectado al pin D2 se enciendan los faros de la autocaravana y cuando lo soltemos que se apaguen. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A008 . Soluci\u00f3n A008","title":"Actividad A008"},{"location":"actividades/A_pulsador/#actividad-a009","text":"Vamos a hacer un programa que al accionar el pulsador se enciendan los faros de la autocaravana y el LED blanco interior y que permanezcan encendidos hasta que no pulsemos dos veces mas (3 pulsaciones en total), en cuyo caso se apagar\u00e1n. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A009 . Soluci\u00f3n A009","title":"Actividad A009"},{"location":"actividades/A_pulsador/#actividad-a010","text":"Partiendo del alfabeto Morse y haciendo el equivalente directo a se\u00f1al con luz vamos a hacer un programa que al accionar el pulsador se enciendan los faros durante tiempos cortos y largos para emitir se\u00f1ales en este c\u00f3digo. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A010 . Soluci\u00f3n A010 En la figura siguiente vemos el alfabeto Morse. Alfabeto Morse","title":"Actividad A010"},{"location":"actividades/A_pulsador/#propuestas","text":"Resolver la actividad A008 de forma que el funcionamiento sea al contrario, es decir, que los faros est\u00e9n siempre encendidos y al accionar el pulsador se apaguen. Hacer un programa que al accionar el pulsador los faros de la autocaravana emitan la se\u00f1al SOS Morse de forma indefinida a intervalos de tres segundos hasta que se vuelva a accionar el pulsador.","title":"Propuestas"},{"location":"actividades/A_sonido/","text":"Actividades con el amplificador de potencia \u00b6 Actividad A013 \u00b6 Vamos a crear una simple sirena utilizando los bloques de sonido. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A013 . Soluci\u00f3n A013 Actividad A014 \u00b6 Reproducir las notas La (440 Hz), Mi (330 Hz) y Do (262 Hz) utilizando el bloque de la actividad A013 con una duraci\u00f3n de 500ms. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A014 . Soluci\u00f3n A014 Actividad A015 \u00b6 Reproducir la introducci\u00f3n de Donkey Kong a partir del dato de la teor\u00eda. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A015 . Soluci\u00f3n A015 Actividad A016 \u00b6 Reproducir tres de las melod\u00edas incluidas en ArduinoBlocks. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A016 . Soluci\u00f3n A016 Propuestas \u00b6 Repetir la actividad A013 cambiando las frecuencias y los tiempos para mejorar la sirena. Repetir la actividad A014 utilizando el bloque 'Tono' en lugar de especificar el valor de la frecuencia y completando la escala musical. Reproducir la melod\u00eda de la imagen siguiente sabiendo que las negras tienen una duraci\u00f3n de 500ms, las negras con un puntito 750ms y las blancas 1000ms. Himno a la alegria Reproducir diferentes melod\u00edas a partir de los bloques RTTTL (Ring Tone Text Transfer Language o lenguaje de tonos de llamada) que descarguemos de las p\u00e1ginas web propuestas.","title":"M\u00f3dulo amplificador"},{"location":"actividades/A_sonido/#actividades-con-el-amplificador-de-potencia","text":"","title":"Actividades con el amplificador de potencia"},{"location":"actividades/A_sonido/#actividad-a013","text":"Vamos a crear una simple sirena utilizando los bloques de sonido. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A013 . Soluci\u00f3n A013","title":"Actividad A013"},{"location":"actividades/A_sonido/#actividad-a014","text":"Reproducir las notas La (440 Hz), Mi (330 Hz) y Do (262 Hz) utilizando el bloque de la actividad A013 con una duraci\u00f3n de 500ms. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A014 . Soluci\u00f3n A014","title":"Actividad A014"},{"location":"actividades/A_sonido/#actividad-a015","text":"Reproducir la introducci\u00f3n de Donkey Kong a partir del dato de la teor\u00eda. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A015 . Soluci\u00f3n A015","title":"Actividad A015"},{"location":"actividades/A_sonido/#actividad-a016","text":"Reproducir tres de las melod\u00edas incluidas en ArduinoBlocks. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A016 . Soluci\u00f3n A016","title":"Actividad A016"},{"location":"actividades/A_sonido/#propuestas","text":"Repetir la actividad A013 cambiando las frecuencias y los tiempos para mejorar la sirena. Repetir la actividad A014 utilizando el bloque 'Tono' en lugar de especificar el valor de la frecuencia y completando la escala musical. Reproducir la melod\u00eda de la imagen siguiente sabiendo que las negras tienen una duraci\u00f3n de 500ms, las negras con un puntito 750ms y las blancas 1000ms. Himno a la alegria Reproducir diferentes melod\u00edas a partir de los bloques RTTTL (Ring Tone Text Transfer Language o lenguaje de tonos de llamada) que descarguemos de las p\u00e1ginas web propuestas.","title":"Propuestas"},{"location":"actividades/A_teclado/","text":"Actividades con teclado matricial de membrana de 4x4 \u00b6 Actividad A011 \u00b6 En esta actividad configuramos el teclado matricial y la consola serie para leer las teclas 1, *, A y 9 y si se pulsa algo distinto no se env\u00eda nada. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A011 . Soluci\u00f3n A011 Actividad A012 \u00b6 Vamos a hacer un sencillo control de clave por teclado guardando previamente la clave en la memoria EEPROM y leyendo la misma, pero la introducida por teclado, la comparamos con la de la memoria. Si la clave es correcta iluminamos los faros en blanco, si no lo es en rojo y si no pulsamos ninguna tecla deben permanecer apagados. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A012 . Soluci\u00f3n A012 Propuestas \u00b6 Hacer un programa que nos env\u00ede a la consola la tecla pulsada en el teclado de 4x4. Repetir la actividad A012 utilizando mas de un car\u00e1cter de los posibles con el teclado.","title":"Teclado matricial de 4x4"},{"location":"actividades/A_teclado/#actividades-con-teclado-matricial-de-membrana-de-4x4","text":"","title":"Actividades con teclado matricial de membrana de 4x4"},{"location":"actividades/A_teclado/#actividad-a011","text":"En esta actividad configuramos el teclado matricial y la consola serie para leer las teclas 1, *, A y 9 y si se pulsa algo distinto no se env\u00eda nada. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A011 . Soluci\u00f3n A011","title":"Actividad A011"},{"location":"actividades/A_teclado/#actividad-a012","text":"Vamos a hacer un sencillo control de clave por teclado guardando previamente la clave en la memoria EEPROM y leyendo la misma, pero la introducida por teclado, la comparamos con la de la memoria. Si la clave es correcta iluminamos los faros en blanco, si no lo es en rojo y si no pulsamos ninguna tecla deben permanecer apagados. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A012 . Soluci\u00f3n A012","title":"Actividad A012"},{"location":"actividades/A_teclado/#propuestas","text":"Hacer un programa que nos env\u00ede a la consola la tecla pulsada en el teclado de 4x4. Repetir la actividad A012 utilizando mas de un car\u00e1cter de los posibles con el teclado.","title":"Propuestas"},{"location":"actividades/A_vapor/","text":"Actividades con el sensor de vapor (steam) \u00b6 Actividad A028 \u00b6 Vamos a leer los datos del sensor de forma booleana, mostrarlos a trav\u00e9s de la consola serie y hacer sonar el amplificador cuando el sensor act\u00faa como detector t\u00e1ctil. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A028 . Soluci\u00f3n A028 El programa genera una salida por consola como la de la figura siguiente: Consola A028 Actividad A029 \u00b6 Leer y mostrar en la consola serie el valor entregado por el sensor steam. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A029 . Soluci\u00f3n A029 El programa genera una salida por consola como la de la figura siguiente: Consola A029 Propuestas \u00b6 Repetir la actividad A028 trabajando con el diodo LED interior. Repetir la actividad A029 mostrando los datos le\u00eddos en la pantalla LCD.","title":"Sensor de vapor (steam)"},{"location":"actividades/A_vapor/#actividades-con-el-sensor-de-vapor-steam","text":"","title":"Actividades con el sensor de vapor (steam)"},{"location":"actividades/A_vapor/#actividad-a028","text":"Vamos a leer los datos del sensor de forma booleana, mostrarlos a trav\u00e9s de la consola serie y hacer sonar el amplificador cuando el sensor act\u00faa como detector t\u00e1ctil. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A028 . Soluci\u00f3n A028 El programa genera una salida por consola como la de la figura siguiente: Consola A028","title":"Actividad A028"},{"location":"actividades/A_vapor/#actividad-a029","text":"Leer y mostrar en la consola serie el valor entregado por el sensor steam. El programa final queda como vemos en la figura siguiente y lo tenemos disponible en el enlace Actividad MH-A029 . Soluci\u00f3n A029 El programa genera una salida por consola como la de la figura siguiente: Consola A029","title":"Actividad A029"},{"location":"actividades/A_vapor/#propuestas","text":"Repetir la actividad A028 trabajando con el diodo LED interior. Repetir la actividad A029 mostrando los datos le\u00eddos en la pantalla LCD.","title":"Propuestas"}]}